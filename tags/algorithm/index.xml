<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on Heaciy&#39;s Blog</title>
    <link>https://heaciy.com/tags/algorithm/</link>
    <description>Recent content in algorithm on Heaciy&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://heaciy.com/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>常用内部排序算法</title>
      <link>https://heaciy.com/p/internal-sort/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://heaciy.com/p/internal-sort/</guid>
      <description>本文基于王道的数据结构考研复习指导，仅作为本人的学习笔记，如有误欢迎指正
 插入排序 直接插入排序 整个例表[0...i-1, i, i+1...n]，i前面的部分维持有序，从i开始向后遍历无序的部分，不断往前面有序的部分插入，插入流程是
 i与i-1（i前面的元素，即有序列表中最后一个，即最大值）比较 如果i大于i-1则说明i比0~i-1都大，故将i插入到有序部分的最后（即保持当前位置不变） 如果i比i-1小，则从i-1开始向前寻找合适的位置，一边比较，一边挪动，直到找到合适的位置，再将i对应的值放到该位置  不断地把i位置的元素
def insert_sort(A: List[int]): &amp;#34;&amp;#34;&amp;#34; 插入排序 稳定 O(n^2) &amp;#34;&amp;#34;&amp;#34; tmp = 0 for i in range(1, len(A)): # i从第二个位置开始 if A[i] &amp;lt; A[i-1]: # 与有序部分最大值比较判断是否需要挪动 tmp = A[i] # 暂存当前值 j = i-1 while(A[j] &amp;gt; tmp and j &amp;gt;= 0): # 向后挪动，将插入位置挪出来 A[j+1] = A[j] j -= 1 A[j+1] = tmp # 将当前值放入插入位置 折半插入排序 同样的道理，依次遍历后面无序的部分往前面有序的部分插入，只是将从有序部分中查找插入位置的过程改成二分查找，找到正确的插入位置后再依次挪动，把插入位置挪出来，将值放入
def insert_sort_binary(A: List[int]): &amp;#34;&amp;#34;&amp;#34;折半插入排序 稳定 O(n^2)&amp;#34;&amp;#34;&amp;#34; for i in range(1, len(A)): tmp = A[i] # 暂存当前值 low, high = 0, i-1 while(low &amp;lt;= high): # 二分查找 mid = int((low+high)/2) if A[mid] &amp;lt; tmp: low = mid+1 else: high = mid - 1 j = i-1 while(j &amp;gt; high): # 向后挪值，将插入位置挪出来 A[j+1] = A[j] j -= 1 A[high+1] = tmp # 总是在high的下一个位置插入 希尔排序 希尔排序也称缩小增量排序</description>
    </item>
    
  </channel>
</rss>
