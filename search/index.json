[{"content":"一、概述 本文将介绍一种使用 Python 脚本构造 HTTP1.* Pcap 包的方法，支持自定义 HTTP 所有参数。本文假设读者具有一定的网络协议基础，对 OSI 七层模型或 TCP/IP 模型有一定的了解。\n二、为什么要自己构造 Pcap 工作中经常需要用到各种 Pcap 包用于测试安全产品，比如测试各种安全规则、构造各种测试资产、测试产品的全流程数据处理是否正常等等。但是传统的 Pcap 包的获取方法较为耗时，如自己搭建各种靶场然后抓包，且抓包获取的数据也不一定 100% 贴合需求，定制五元组信息也不是很方便。\n但是如果我们能自己构造 Pcap 包，那我们就能自定义数据包中的内容，相较于抓包将更加灵活高效，测试时我们也不再需要到处找 Pcap 包。\n同时如果我们封装一套工具，每次都能通过配置一键生成我们所需 Pcap 那将更加方便，相当于我们根据需求准备了一套 Pcap 库。\n三、构造 Pcap 包的工具 Scapy Scapy 是一个由 Python 编写的强大交互式数据包处理程序。它能够伪造、发送、捕获、分析和操作网络数据包。它最大的特点是赋予了用户极低的层级和极高的自由度来定制和构建网络数据包，因此被广泛用于网络测试、扫描、攻击、探测以及教学等领域。\n我们知道 Pcap 中的数据其实就是数据链路层上的一个个帧，而这里的帧又是从 OSI 七层模型(或TCP/IP模型) 一层层的从上往下封包形成，要自己构造 Pcap 就得手动模拟这一层层的封包行为来模拟一层层的协议，所以构造 Pcap 包无非就是模拟还原相关协议。\nScapy 有趣的是通过 重载 / 运算符，把不同层次的协议“叠加”起来，清晰地表达了数据包的层级结构，大大简化了包构造的复杂度。\n例如，一个 TCP SYN 包可以这样写：\n1 2 3 from scapy.all import * packet = Ether() / IP(dst=\u0026#34;192.168.1.1\u0026#34;) / TCP(dport=80, flags=\u0026#34;S\u0026#34;) 更多相关的用法可以参考 Scapy 官方文档。Pcap 的底层数据构造分析见往期博客《Libpcap格式 pcap包分析》。\n四、HTTP 1.* 与 TCP 的关系 HTTP 协议为应用层协议，属于 OSI 七层模型的第五层。TCP 为传输层协议，属于 OSI 七层模型的第四层。我们知道 HTTP 1.* 是基于 TCP 协议的，那么下面使用一个时序图绘制一次 HTTP 请求响应对应的 TCP 层活动（注意 seq/ack 号的变化）：\nsequenceDiagram participant Client as 客户端 participant Server as 服务器 Client-\u0026gt;\u0026gt;Server: SYN (seq=x) Server-\u0026gt;\u0026gt;Client: SYN-ACK (seq=y, ack=x+1) Client-\u0026gt;\u0026gt;Server: ACK (seq=x+1, ack=y+1) Note right of Client: TCP 连接已建立！开始传输 HTTP 数据 Client-\u0026gt;\u0026gt;Server: HTTP 请求 [PUSH, ACK] (seq=x+1, ack=y+1) Note right of Client: 请求大小假设为 150 字节 Server-\u0026gt;\u0026gt;Client: 对请求的确认 [ACK] (seq=y+1, ack=x+1+150) Server-\u0026gt;\u0026gt;Client: HTTP 响应 [PUSH, ACK] (seq=y+1, ack=x+1+150) Note left of Server: 响应大小假设为 500 字节 Client-\u0026gt;\u0026gt;Server: 对响应的确认 [ACK] (seq=x+1+150, ack=y+1+500) Client-\u0026gt;\u0026gt;Server: FIN-ACK (seq=x+1+150, ack=y+1+500) Server-\u0026gt;\u0026gt;Client: ACK (seq=y+1+500, ack=x+1+150+1) Server-\u0026gt;\u0026gt;Client: FIN-ACK (seq=y+1+500, ack=x+1+150+1) Client-\u0026gt;\u0026gt;Server: ACK (seq=x+1+150+1, ack=y+1+500+1) Note right of Client: TCP 连接已关闭！ 整体过程可以总结为：\n三次握手建立 TCP 连接； 连接建立后开始传输 HTTP 数据，受限于 MTU 和 MSS，如果 HTTP 传输的数据比较多可能需要通过多个 TCP 数据包进行传输，即分包； 在 HTTP 数据传输完后，需要进行四次挥手关闭 TCP 连接； 要使用 Scapy 生成 HTTP Pcap 包，其实我们要模拟就是上述过程。\n有几点值得注意：\n纯 ACK 和 FIN 不占用序号，即 ACK 数据包和 FIN-ACK 数据包不占用序号； 推送数据使用 PUSH-ACK 数据包，对端在收到一个或多个此类的数据包后通常会回一个 ACK 包进行确认； 五、使用 Scapy 构造 HTTP1.*的 Pcap 包 本文主要讲解构造 HTTP1.* 的 Pcap 包，前面章节提到使用 Scapy 我们可以手动构造网络中每一层的协议，要构造 HTTP 这一应用层协议，我们就要手动处理应用层及往下的每一层协议：应用层(HTTP) / 传输层(TCP) / 网络层(IP) / 数据链路层(以太网)\nHTTP (应用层)：自定义 HTTP 协议相关内容，如请求头、请求体、响应头、响应体。 TCP (传输层)：自定义 TCP 协议相关内容，如源端口和目的端口。 IP (网络层)：自定义 IP 协议相关内容，如源 IP 和目的 IP。 Ether (数据链路层)：自定义以太网协议相关内容，如源 MAC 和目的 MAC。 整体用 Scapy 的代码表示就是：packet = Ether() / IP() / TCP() / Raw()\n需要注意的是我们不单要定制每一层的数据，还要维护每一层之间的关系。比如：在构造 HTTP 数据时，如果 HTTP 数据量较大时，可能需要我们手动进行“分片”，因为 HTTP 数据使用 TCP 协议发送，所以会受到 MSS 和 MTU 影响，当单个 HTTP 请求或者响应超过 MSS 时需要我们在 TCP 层分包。同时在构造 HTTP 层的数据时，还要注意 HTTP1 协议的一些细节，比如 Content-Length 的计算，需要计算 请求体/响应体 字节串的长度。以及 HTTP 请求头中的 Host 字段中的端口需要和 IP 层中指定数据包的目的端口一致，这样才不至于被认为是错误的数据包。\nHTTP1 协议使用 TCP 协议传输数据，所以本质上我们需要构造 TCP 协议的数据包来模拟 HTTP1 协议。因为我们需要自定义 HTTP 的请求和响应，并不是使用 Scapy 进行真实的网络请求，所以每个 TCP 包之间的关系也需要我们自己维护，其实就是要模拟真实的 TCP 连接，即维护 TCP 包的头部信息，如标志位、seq/ack 号。\n总结一下我们需要维护的几点：\n维护 HTTP 协议本身的格式，需要注意一些需要计算的字段，如：Content-Type。 根据 MSS / MTU 对 HTTP 数据包切割后再作为 TCP 协议的 Body。 HTTP 请求中 Host 字段中的端口信息与 IP 包中的端口信息保持一致。 维护 TCP 包中的标志位、seq/ack 号来维护模拟 TCP 连接（如果这里的数据有差错将生成错误的包，打开 Wireshark 查看将看到被标记为黑色）。 使用 Scapy 构造上一章节中举例的 HTTP 连接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 from scapy.utils import wrpcap from scapy.layers.l2 import Ether from scapy.layers.inet import IP, TCP from scapy.layers.http import Raw def gen_http_pcap(): \u0026#34;\u0026#34;\u0026#34;生成 HTTP Pcap\u0026#34;\u0026#34;\u0026#34; sip = \u0026#34;10.67.0.63\u0026#34; dip = \u0026#34;10.67.0.1\u0026#34; sport = 8080 dport = 80 smac = \u0026#34;fe:2d:90:f2:11:fe\u0026#34; dmac = \u0026#34;12:dd:2c:21:a2:bf\u0026#34; request = \u0026#34;GET / HTTP/1.1\\r\\n\u0026#34; \u0026#34;Host: example.com\\r\\n\u0026#34; \u0026#34;\\r\\n\u0026#34; response = \u0026#34;HTTP/1.1 200 OK\\r\\n\u0026#34; \u0026#34;Content-Length: 5\\r\\n\u0026#34; \u0026#34;Content-Type: text/plain\\r\\n\u0026#34; \u0026#34;\\r\\n\u0026#34; \u0026#34;Hello\u0026#34; seq_x = 0 seq_y = 0 # 通用的 IP 层包 sip_packet = Ether(src=smac, dst=dmac) / IP(src=sip, dst=dip) dip_packet = Ether(src=dmac, dst=smac) / IP(src=dip, dst=sip) client_port_pair = {\u0026#34;sport\u0026#34;: sport, \u0026#34;dport\u0026#34;: dport} server_port_pair = {\u0026#34;sport\u0026#34;: dport, \u0026#34;dport\u0026#34;: sport} # 三次握手: SYN, SYN-ACK, ACK syn_packet = sip_packet / TCP(**client_port_pair, flags=\u0026#34;S\u0026#34;, seq=seq_x) syn_ack_packet = dip_packet / TCP(**server_port_pair, flags=\u0026#34;SA\u0026#34;, seq=seq_y, ack=syn_packet[TCP].seq + 1) ack_packet = sip_packet / TCP( **client_port_pair, flags=\u0026#34;A\u0026#34;, seq=syn_ack_packet[TCP].ack, ack=syn_ack_packet[TCP].seq + 1 ) # HTTP 请求 request_packet = ( sip_packet / TCP( **client_port_pair, flags=\u0026#34;PA\u0026#34;, seq=syn_ack_packet[TCP].ack, ack=syn_ack_packet[TCP].seq + 1, ) / Raw(request.encode()) ) dst_ack_packet = dip_packet / TCP( **server_port_pair, flags=\u0026#34;A\u0026#34;, seq=request_packet[TCP].ack, ack=request_packet[TCP].seq + len(request_packet[Raw].load), ) # HTTP 响应 response_packet = ( dip_packet / TCP( **server_port_pair, flags=\u0026#34;PA\u0026#34;, seq=request_packet[TCP].ack, ack=request_packet[TCP].seq + len(request_packet[Raw].load), ) / Raw(response.encode()) ) src_ack_packet = sip_packet / TCP( **client_port_pair, flags=\u0026#34;A\u0026#34;, seq=response_packet[TCP].ack, ack=response_packet[TCP].seq + len(response_packet[Raw].load), ) # 四次挥手 fin_packet = sip_packet / TCP( **client_port_pair, flags=\u0026#34;FA\u0026#34;, seq=src_ack_packet[TCP].seq, ack=src_ack_packet[TCP].ack ) ack_packet_close = dip_packet / TCP( **server_port_pair, flags=\u0026#34;A\u0026#34;, seq=fin_packet[TCP].ack, ack=fin_packet[TCP].seq + 1 ) ack_packet_close2 = dip_packet / TCP( **server_port_pair, flags=\u0026#34;FA\u0026#34;, seq=fin_packet[TCP].ack, ack=fin_packet[TCP].seq + 1 ) fin_packet_ack = sip_packet / TCP( **client_port_pair, flags=\u0026#34;A\u0026#34;, seq=ack_packet_close2[TCP].ack, ack=ack_packet_close2[TCP].seq + 1 ) # 按顺序组合数据包 http_traffic = [ # 三次握手 syn_packet, syn_ack_packet, ack_packet, # 数据交换 request_packet, dst_ack_packet, response_packet, src_ack_packet, # 四次挥手 fin_packet, ack_packet_close, ack_packet_close2, fin_packet_ack, ] wrpcap(f\u0026#34;http.pcap\u0026#34;, http_traffic) if __name__ == \u0026#34;__main__\u0026#34;: gen_http_pcap() 使用 Wireshark 查看生成的数据包\n六、工具的封装和使用 上述的代码封装为生成 HTTP1.* Pcap 的工具脚本，整个过程其实可以抽象为两个部分\n封装生成 HTTP1.* 请求和响应的逻辑 封装模拟 TCP 传输数据生成相关网络包的逻辑 这一部分代码就不再展开介绍了，完整工具代码见 Github Gist，其实就是对上一章节中的样例代码进一步封装抽象。\n下面简单介绍一下上述提供的工具脚本的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import random from scapy.utils import wrpcap from gen_http_pcap import gen_http_request, gen_http_response, gen_http_pcap dip, dport = \u0026#34;10.67.2.42\u0026#34;, 80 sip, sport = \u0026#34;10.67.0.63\u0026#34;, 9000 def gen_vul_800001(): \u0026#34;\u0026#34;\u0026#34; desc: 测试弱密码 event: 800001 \u0026#34;\u0026#34;\u0026#34; # 模拟登录 url = \u0026#34;/auth/login/\u0026#34; req_body = {\u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;qaz123456\u0026#34;} res_header = {\u0026#34;Set-Cookie\u0026#34;: \u0026#34;sessionid=94hi2otc9ykaoufja1ailul871tf4ha0; \u0026#34; \u0026#34;expires=Fri, 19 Sep 2025 04:40:28 GMT; HttpOnly; Max-Age=3600; Path=/; SameSite=Lax\u0026#34;} res_body = {\u0026#34;status\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;登陆成功\u0026#34;, \u0026#34;data\u0026#34;: None} request = gen_http_request(dip, dport, url, body=req_body, method=\u0026#34;POST\u0026#34;) response = gen_http_response(header=res_header, body=res_body) # 模拟获取数据 url1 = \u0026#34;/user/admin/\u0026#34; req_head1 = {\u0026#34;Cookie\u0026#34;: \u0026#34;sessionid=94hi2otc9ykaoufja1ailul871tf4ha0\u0026#34;} res_body1 = {\u0026#34;status\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;获取用户信息成功\u0026#34;, \u0026#34;data\u0026#34;: {\u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;admin\u0026#34;}} request1 = gen_http_request(dip, dport, url1, header=req_head1) response1 = gen_http_response(body=res_body1) return gen_http_pcap(src_ip=sip, src_port=random.randint(20000, 50000), dst_ip=dip, dst_port=dport, request=[request, request1], response=[response, response1]) if __name__ == \u0026#39;__main__\u0026#39;: packets = gen_vul_800001() wrpcap(f\u0026#34;800001.pcap\u0026#34;, packets) 使用 Wireshark 查看生成的数据包\n七、更多 需要注意的是当前自己生成 Pcap 包并不能完全替代搭建靶场抓包的方式，因为构造的 Pcap 包中的数据毕竟是我们自己输入的，相较于真实的环境可能真实性并没有实际抓包的好。当然如果我们输入的数据与真实的数据一致，那也便没什么区别了。 只要知道一个协议的底层细节，我们便能通过 Scapy 进行模拟。故无论是 HTTP2.0、HTTP3.0 还是 TLS 都能通过 Scapy 构造，不同于 HTTP1.0 上述协议本身更加复杂，故使用 Scapy 模拟时将更为复杂。感兴趣的读者也可以自己尝试一下。不过话又说回来了，如果从底层掌握了网络细节，就算一个个字节拼接也能还原协议哈哈哈。 ","date":"2025-09-19T00:00:00Z","image":"https://heaciy.com/p/gen-http-pcap/dennis-cortes-4VC8YdQsjko-unsplash_hu_99fa4b1c22202288.jpg","permalink":"https://heaciy.com/p/gen-http-pcap/","title":"HTTP 1.* Pcap 生成方法"},{"content":"什么是文学？我的理解是：文学有时是一种思想，或深邃、或尖锐、或厚重的思想；文学有时是一种情感，或爱怜、或幽怨、或欣喜、或悲怆的情感；文学有时是一段故事，诉说着悲欢离合、演绎着人生艰辛坎坷的故事；文学有时就是一种生活，一种超越了时间和空间、真真切切展现在我们面前的生活。\n有人戏称文学之于社会生活，就如同蛋糕上的一颗樱桃，仅仅是一种点缀而已。我不同意这种说法。在我看来，当今社会生活中，文学的存在比任何时候都有着更为重要的意义。主要表现在以下三个方面：\n一是有助于我们去认识自己。\n古希腊有一个传说，说是有一个名叫“司芬克斯”的怪物，人面狮身，长着双翅，长年累月地蹬在一条大路旁向过往的行人提问，他所定下来的规则是，你回答出了他的问题，你可以打他前面经过，你如果回答不出来，那他就把你吃了。这个问题是：“一个能发出声音的东西，早上它用四条腿走路，中午它用两条腿走路，到了傍晚，它用三条腿走路，这个东西是什么？”许多人无法回答这个问题，自然司芬克斯脚下白骨累累，这个问题后来终于被一位英雄俄狄浦斯揭开了，他说，这个东西就是人，因为人在幼年时用两手两脚爬行，在壮年时用两脚走路，在老年时拄杖而行。这个传说更像是一个有关人类命运的隐喻，“认识你自己”不仅成了苏格拉底哲学中的一句名言，同时也成了整个西方文化的一块基石。人，作为宇宙的精华，万物的灵长，人应该懂得自己的高贵，明白自己的尊严，人只有认识了自己，才能把握自己，把握自己的命运；人只有认识了自己，才能去认识人所生活的这个世界，从而在这个世界中去实现自身的价值。否则，必将被像“司芬克斯”这样的“人之外”的异己力量所吞噬。\n文学作品的解读过程实质上是一个把作品中透露出来的客体世界重新还原为活的存在的过程，作为读者的我们，常常会在作者惨淡经营的世界里发现我们自己的影子。如果说杰出的文学创造是作者通过非同一般的个人视角的透视，对人生真谛做出独到的发现与昭示的话，那么，我们读者在对文学作品的解读过程中，也就不可避免地要触及到平日很少碰到的深层自我及其存在的意义问题。如果说陀思妥耶夫斯基的创作是一种“灵魂拷问”的话，那么我们的阅读活动，又何尝不是一次对灵魂的追寻或安顿呢。在墨西哥的印第安人中，长期流传着这样一个故事。故事里说，一群印第安人赶着羊群，朝落日方向走去，他们行走的速度很快，但是快速行走一段距离就会停下来。停下来的他们在夕阳映红的天空下跳舞，他们快乐的跳着。过路的人问，“你们还在等什么？再不赶路，日落之前就到不了目的地了。”印第安人回答说，“我们慢下来，是在等待我们的灵魂赶上来！”当迷失了自我的人们四顾茫然的时候，在文学的天地里慢慢地行走，或许真能为我们找得回家的路。\n二是有助于我们去弘扬一种人文精神。\n近年来，在商业高楼、经济巨厦大矗大立的同时，人们的精神家园却渐遭遗忘。灯红酒绿的热闹过后，人们终于发现除了钱的法则之外，这个世界还需要伦理的、道德的、文化的、良知的等等精神法则，否则人们也绝难共生下去。人文精神，也便在一片文学危机的叫声中被重新提了出来。“今天的文学危机是个触目的标志，不但标志了公众文化素养的普遍下降，更标志着整整几代人精神素质的持续恶化。文学的危机实际上暴露了当代中国人人文精神的危机，整个社会对文学的冷淡，正从一个侧面证实了，我们已经对发展自己的精神生活丧失了兴趣。”（《旷野上的废墟——文学和人文精神的危机》，《上海文学》1993年第6期）\n那么，什么是人文精神呢？人文精神一词应该源出于“人文主义”这一术语，西人称作humanism，是文艺复兴时期的时代精神，是作为中世纪基督教神权的对立物（至少是补充物）出现的，指的是一种超越动物性感性欲望和工具性功利的精神价值。中国与西方的主流文化都认为，这样一种精神价值是人之为人、人之区别于动物的根本特性。例如孟子说，作为精神价值的恻隐、羞恶、辞让、是非之心，是“人之所以异于禽兽者”，如果没有这种“心”，就“非人也”；荀子则说，“水火有气而无生，草木有生而无知，禽兽有知而无义。人有气、有生亦且有义，故为天下贵也。”所以，在我们先前有关人文精神的大讨论中，常常把人文精神描述为是对生命的关注，是对人类的存在的思考，是对认得价值、人的生存意义的关注，是对人类命运、人类痛苦与解脱的思悟与探索。\n在我们众多优秀的文学作品中，包蕴着对于我们现代社会生活来说极为可贵的人文精神，借助对文学作品的阅读，我们去发掘它，进而在我们当下的生活中去发扬光大它，也正是我们的责任。\n三是有助于我们去找回已经丢失或正在丢失的激情、温情和诗情。\n人类社会现已经进入到了信息时代。这个时代的人们有着许许多多值得骄傲的理由，因为我们再也不像祖先那样蒙昧无知，我们创造了令先民们瞠目结舌的无数奇迹。然后，就在我们创造奇迹的同时，无庸讳言，我们也失去了许多，尤其是一种激情、温情和诗情，正在远离我们的生活，已经成为一种不争的事实。\n当我们读着韩东《有关大雁塔》，“有关大雁塔，/我们又能知道些什么呢，/我们爬上去，/看看四周的风景，/然后再下来。”我们能感受的是生命在失去了血色之后的一份苍白和激情被抽离之后的人生的平庸、无聊和空洞。多变的时代、激烈竞争的社会以及快节奏的生活方式，也正抛弃着曾给我们许多心灵慰藉的温情，而日常生活的琐事、忙忙碌碌的人生，不仅时刻考验着我们的人性，也正日益磨损着曾荡漾在我们生活中的诗情。难怪周国平要在他的一本小册子《人与永恒》中这样感慨：“砖、水泥、钢铁、塑料和各种新型建筑材料把我们包围了起来。我们总是活得那样匆忙，顾不上看看天空和土地；我们总是生活在眼前，忘掉了无限和永恒。”连讲究实用和效率的戴尔·卡耐基也发出了如此的告诫：“我们且不要这么忙碌，生活得这么疾速，竟使得自己无法倾听草地的乐音，或森林壮丽的交响曲。”\n我想，读点文学，可以有助于我们找回已经丢失或正在丢失的激情、温情和诗情。在我们的生活中，遭遇到压力或艰辛是难免的，但如果我们拥有着一份生活的激情，我们就有了挑战压力和种种艰辛的勇气，我们的生命也会在一次又一次的抗争与搏击中走向辉煌和灿烂；我们也常常遭遇人生到的苦痛，经受种种的打击，我们需要心灵的抚慰，因为有了温情并且感受到了这份温情，我们受伤的心才会趋于宁帖、安逸，让我们对生活有一份发自心底的眷恋；忧郁或苦涩，同样地难以尽免，然而，浸融着诗情的忧郁，往往会净化人的灵魂，而诗意的悲怆，更可以使人趋于崇高。\n作者：潘水根\n链接：https://www.zhihu.com/question/24820932/answer/82635714\n","date":"2025-09-18T00:00:00Z","image":"https://heaciy.com/p/the-significance-of-literature/noah-silliman-y3IwQ9hUE4A-unsplash_hu_7a0a0acb6623921e.jpg","permalink":"https://heaciy.com/p/the-significance-of-literature/","title":"文学的意义"},{"content":" “浮生暂寄梦中梦，世事如闻风里风。”\n我记得 谢尔盖·叶赛宁\n我记得，亲爱的，记得\n你秀发焕发的光泽\n我既不欢喜也不愉悦\n因为不得不与你告别\n我记得秋天的月夜，\n白桦树影的簌簌低语\n那时但愿白日消逝如飞\n明月长照我你\n我记得，你曾说过：\n“蔚蓝色的年岁会远去\n你也会忘记，我的挚爱，\n会因另一个人把我永远忘记。”\n今日盛开的菩提\n又唤醒千愁万绪\n如此温柔，当我把鲜花\n撒向你如波的发髻，\n而心儿，却不愿冷淡\n和悲伤的移情别恋，\n仿佛读着一本喜爱的小说\n也会从别人身上想起你\n门前 顾城\n我多么希望，有一个门口\n早晨，阳光照在草上\n我们站着\n扶着自己的门扇\n门很低，但太阳是明亮的\n草在结它的种子\n风在摇它的叶子\n我们站着，不说话就十分美好\n有门，不用开开\n是我们的，就十分美好\n路边野餐 毕赣\n许多夜晚重叠，\n悄然形成黑夜，\n玫瑰吸收光芒，\n大地按捺清香。\n为了寻找你，\n我搬进鸟的眼睛，\n经常盯着路过的风。\n星空下 何三坡\n我们手牵着手\n在黑夜里走\n你的头顶是星光\n有时侯，我担心\n一只狗突然蹿出来\n弄脏你的裙子\n山岗一直是安静的\n一团橙色的光\n在低洼处一闪\n就不见了\n好多花在开，在落\n这样的美，我不会轻易说出来\n一定不是我 扎西拉姆·多多\n我知道感动我的那一丛夏花，\n不一定感动你；\n我知道唤醒我的那一片月光，\n从来没有惊扰过你\n我们是同一条河边的歌姬，\n歌颂着一样的流逝，\n却只能以不一样的方式老去。\n所以我必定不只是那个在众人面前朗诵的诗人，\n因为每一个词都只是——\n我一个人的秘密\n任何表达都让我羞涩不已\n我为什么爱你，先生 艾米莉·狄金森\n我为什么爱你，先生？\n因为\n风从不询问青草\n为何总在他经过时摆动身体\n因为他知道\n而你不知道\n我们也无从知晓\n这般智慧于我们足矣\n闪电从不询问眼眸\n为何总在他到来时紧紧闭上\n因为他知道\n双眸无法言语\n言语表达的也未必真切\n因此\n高雅的人宁愿会意\n见到日出我便不能自已\n而他就是日出\n于是——所以——\n我爱你\n未选择的路 弗罗斯特\n黄色的树林里分出两条路，\n可惜我不能同时去涉足，\n我在那路口久久伫立，\n我向着一条路极目望去，\n直到它消失在丛林深处。\n但我却选了另外一条路，\n它荒草萋萋，十分幽寂，\n显得更诱人、更美丽，\n虽然在这两条小路上，\n却很少留下旅人的足迹。\n虽然那天清晨落叶满地，\n两条路都未经脚印污染。\n呵，留下一条路等改日再见！\n但我知道路径延绵无尽头，\n恐怕我难以再回返。\n假如⽣活欺骗了你 普希金\n假如生活欺骗了你，\n不要悲伤，不要心急！\n忧郁的日子里须要镇静：\n相信吧，快乐的日子将会来临！\n心儿永远向着未来；\n现在却常是忧郁。\n一切都是瞬息，一切都将会过去；\n而那过去了的，就会成为亲切的怀恋。\n“一生中我作过多少旅行，进行过多少探索，最后发现——我所寻求的，原来是我在童年曾经有过而又失去的东西。”\n","date":"2025-07-09T00:00:00Z","image":"https://heaciy.com/p/some-poems/bookstore_hu_b61fedb875b93e24.jpg","permalink":"https://heaciy.com/p/some-poems/","title":"诗几首"},{"content":" 前言： 因为工作中的一个计算密码强度的需求，了解到 zxcvbn 这个库，花了段时间看了看它的 java 实现和相关论文，编写此文作为笔记存档。注意：本文侧重其算法实现和复杂度计算，不涉及其使用方法以及与其他库的对比。本文中的公式均摘自 Dropbox 相关博客和论文。\n概述 zxcvbn 是一个由 Dropbox 开发的密码强度估算库，灵感来自于密码爆破工具，其全称是 \u0026ldquo;zxcvbn: realistic password strength estimation\u0026rdquo;，旨在提供一种更准确、用户友好的密码强度评估方法。zxcvbn 的强度估计是基于一个想法：\n猜测密码难度 ≈ 破解者使用最优策略所需尝试的次数（guesses）\n换句话说，zxcvbn 试图模拟一个最聪明的黑客（利用所有已知技术和词库）如何最有效地破解这个密码。然后根据所需的尝试次数来估算破解时间和给出打分。\nzxcvbn 将密码破解难度的计算大致分为了三步：\n匹配：模式匹配，zxcvbn 会尝试对输入密码进行子串划分，它尝试以多种方式将密码拆成子串，每个子串对应一种模式(match)，即该子串符合什么特征，如若密码字典(包含常用单词、姓名)、键盘路径，具体有哪几种模式将在下文具体介绍。 评估：破解所需的尝试次数，对于每个识别出的模式子串，zxcvbn 会计算其可能的尝试次数。 搜索：使用 动态规划 算法，zxcvbn 试图找出一组首尾相接子串组合，使得总猜测数最小。 模式匹配 zxcvbn 包含的匹配模式 字典匹配：维护一个带排名的弱密码字典，如：admin、admin123、logitech 反向字典匹配：基于字典匹配，弱密码字典中的词汇倒序，如：drowssap，nimda leet 匹配：基于字典匹配，将一些字符做相似替换，如：p@ssw0rd 键位匹配：键盘上的连续字符，如：qwerty、qazwx 重复匹配：重复的字符或者序列，如：zzz、ababab 顺序匹配：有顺序的连续字符，如：abc、123、246 日期匹配：日期字符串，如：20000102、7/8/1947 暴力破解匹配：无法使用上述方法匹配的序列，如：x$JQhMzt 正则匹配：实际代码中比论文中还多了一种正则匹配，内置常见的数据格式正则比如最近的年份 模式匹配的实现原理 字典匹配、反向字典匹配、leet 匹配 ：首先将整个密码字符串小写，然后再获取该小写密码的所有子串，遍历子串看其是否在密码排名字典中；反向字典匹配在此基础上将子串反转判断其是否在排名字典中；leet 匹配则会根据替换规则，得到一个子串的所有 leet 替换值，再判断替换后的子串是否在排名字典中，如@ba1one，l33t 表会将@映射到a，将1映射到i或者l(即按照 leet 规则将字符串中的符号和数字替换为对应的字母)，因此它会通过替换 [@-\u0026gt;a, 1-\u0026gt;i] 和 [@-\u0026gt;a, 1-\u0026gt;l]分两次尝试去排名字典中匹配，第二次会匹配中单词abalone(单词：鲍鱼)； zxcvbn 的密码字典包括：英语词汇表、常用人名、常用密码、常用姓氏、美国电影和电视剧名 顺序匹配：通过计算相邻字符的 unicode 码的差值来找到顺序，一个”递增“或”递减“的子串其相邻字符的 unicode 码的差值是相同的； 重复匹配：通过使用贪婪正则\u0026quot;(.+)\\1+\u0026quot;和懒惰正则\u0026quot;(.+?)\\1+\u0026quot;来识别密码字符串中的重复块。对于字符串 \u0026ldquo;aabaab\u0026rdquo; 贪婪模式的结果(aab)较懒惰模式的结果(aa)会胜出，因为贪婪模式覆盖的长度为 6(\u0026ldquo;aabaab\u0026rdquo;)而贪婪模式覆盖的长度为 2(\u0026ldquo;aa\u0026rdquo;)；对于 \u0026ldquo;aaaaa\u0026rdquo; 懒惰模式覆盖长度为 5(\u0026ldquo;aaaaa\u0026rdquo;)，而贪婪模式覆盖长度为 4(\u0026ldquo;aaaa\u0026rdquo;)，故懒惰模式胜出。在得到整个密码的所有重复单元后，会再对每个重复单元再执行完整的匹配过程(即对子串再执行一遍搜索的模式匹配)，以此识别重复的单词或日期； 键位匹配：遍历密码字符串，对比多种键盘键位的邻接图，找到密码中键位相邻的模式子串，并记录每个模式子串的长度、转折次数、shift 键(如!@#$%QAZ)的数量以及键盘种类。如密码“zxcvfR$321”将会被记录为以下数据：键盘种类-qwerty、转折次数-3、shift键数量-2(R和$)、长度-10； 日期匹配：对于不带分隔符( / \\ _ . - 空格)的日期格式，遍历整个密码字符串，匹配长度为 4~8 的数字子串如'1191'、'11111991'，然后针对不同长度使用不同的分割策略分割为三部分组合、过滤出日期，再从这些日期中挑出离现在最近的日期作为最优解；对于带分隔符的日期格式，遍历整个密码字符串，匹配长度为 6~10 的数字子串如'1/1/91'、'11/11/1991'，使用正则匹配分割为三部分，然后重复上述的逻辑； 正则匹配：实际代码实现中只内置了一种常用正则即最近年份用于匹配 19** 或者 20** 这种年份，如 1999、2019； 评估尝试次数 每种模式的猜测次数计算 对于模式匹配阶段的结果，在评估阶段会计算其中每一个模式子串的猜测次数，对每种模式的子串的猜测计算方法根据模式匹配特点决定：\n字典和反向字典匹配：假设攻击者按照弱密码流行度顺序猜测\n对于字典匹配，模式子串的猜测次数即为弱密码字典排名值； 对于反向字典匹配，由于需要尝试字典值的正反两种情况，因此还要在流行度排名值的基础上乘二； 对于仅首字母、仅尾字母和全部字母为大写的三种情况，也需要在流行度排名值得基础上乘二； 对于其他的大小写情况(如：对于密码paSswOrd，需要在猜出password的基础上，再猜出哪些位置的字母是大写)使用下面的公式计算： $$ \\frac{1}{2}\\sum_{i=1}^{\\min(U,L)}\\binom{U+L}{i} $$公式解读：\n$U$：大写字母数量 $L$：小写字母数量 $\\min(U,L)$：取两值中的较小值，当大写字母数量大于小写字母数量时，改为猜测小写字母 $\\binom{U+L}{i}$：组合公式 $C^{i}_{U+L}$ ，即从 $U+L$ 个中选出 $i$ 个有多少种选法 $\\frac{1}{2}\\sum_{i=1}^{\\min(U,L)}\\binom{U+L}{i}$：攻击者不知道其中有多少个大写字母，假设攻击者从 1 个大写字母尝试到 $min(U,L)$，当尝试到大写字母数量为 $i$ 时，此轮共需要尝试 $C^i_{U+L}$ 次，记为 $\\binom{U+L}{i}$，$i$ 需要从 1 尝试到 $min(U,L)$，总数为 $\\binom{U+L}{i}+\\binom{U+L}{i}+\u0026hellip;+\\binom{U+L}{min(U,L)}$ 记为 $\\sum_{i=1}^{\\min(U,L)}\\binom{U+L}{i}$，最后添加一个 $\\frac{1}{2}$ 来取平均猜测次数。 Leet 匹配：在字典匹配的基础上，与上述大小写替换的计算方式一致，只不过是将大写字符替换改为了 leet 字符替换。\n键位匹配：对于键位匹配，假设攻击者总是从较短的键位匹配长度(最短为 2)和较少的方向(最少为 1)开始计算。以 qwertyhnm 为例，它从 q 开始，长度为 9，包含 3 个方向：最开始向右(qwerty)，然后向右下(yhn)，然后向右(nm)。\n$$ \\frac{1}{2}\\sum_{i=2}^{L}\\sum_{j=1}^{\\min(T,i-1)}\\binom{i-1}{j-1}SD^j $$公式解读：\n$L$：密码的长度 $T$：密码在键盘上方向段数 $D$：键盘上每个键平均的相邻键数 $S$：键盘上键的个数 $i$：假设键位匹配模式子串的长度为 $i$，从 2 开始（1 长度没有“转向”的意义） $j$：假设长度为 $i$ 的键位匹配模式子串包含 $j$ 个方向段，即对应 $j-1$ 次转向，不能超过 $i-1$ 或最大方向段数 $T$ $SD^j$：键盘上任意一个字符都有可能作为起始字符，每一个方向段都有 $D$ 种方向选择，共 $j$ 段。(这里应该也是估算，因为第二个方向段的方向肯定与第一个方向段方向不同，那能选的方向应该是 $D-1$，对应 $S \\cdot D \\cdot (D-1)^{j-1}$，不过这里的数量级应该是一样的且 $D$ 本身不是精确值，所以直接简化为 $SD^j$ 也无妨) $\\binom{i-1}{j-1}$：在 $i$ 个键上包含 $j$ 个方向段，可以这样理解：$j$ 个方向段对应 $j-1$ 次转向，转向应该发生在“内部键”上，而 $i$ 个键位对应 $i-2$ 个内部键(即去除首尾键)，那位该问题转化为在 $i-2$ 个内部键中挑选出 $j-1$ 个作为转向键，对应的组合公式即为 $\\binom{i-2}{j-1}$。⁉️ 离谱的来的，怎么跟论文里的公式对不上 😅 $\\frac{1}{2}\\sum_{i=2}^{L}\\sum_{j=1}^{\\min(T,i-1)}\\binom{i-1}{j-1}SD^j$：假设攻击者总是从较短的序列长度(最短为 2)和较少的方向段数(最少为 1)开始猜测，针对 $i$ 从 $2$ 到 $L$ 的每种序列长度的情况，方向段数从 1 最多尝试到 $min(T,i-1)$ 次；每种长度的模式子串的首字符有 $S$ 种选择，每个方向段有 $D$ 种方向选择，共有 $j$ 个方向段，故针对每种空间模式的模式子串都有 $SD^j$ 种可能；$\\frac{1}{2}$ 用于计算平均情况； ⚠️ 注意 ⚠️：上述个人理解与论文中的公式对不上 😅，不必惊慌数量级应该是一样的那就先凑合用论文中的公式吧，当然我的理解可能也是错的欢迎指正。\n其实下面参考链接里的论文中存在多处公式与代码实现不符且存在错误……经过查看 Dropbox 官方的代码库实现和相关的 java 库实现后发现，实际并没有使用论文中提到的 $\\frac{1}{2}$ 来计算平均尝试情况，除了键位匹配，字典匹配的实现中也没有使用 $\\frac{1}{2}$ 来计算平均值。代码实现中实际使用的公式如下：\n$$ \\sum_{i=2}^{L}\\sum_{j=1}^{\\min(T,i-1)}\\binom{i-1}{j-1}\\cdot S \\cdot D^j \\cdot \\text{shift\\_factor} $$公式解读：\n$\\text{shift\\_factor}$：大写因子，即按住 shift 键输入的值，比如大写的字母或是数字键对应的符号如 !@# 等。 当整个模式子串全部为\u0026quot;小写\u0026quot;时因子值为 1； 当整个模式子串全部大写时，因为值为 2，因为假定攻击者先尝试全部小写再尝试全部大写，所以尝试了两次； 其余情况使用公式 $\\sum_{i=1}^{\\min(\\text{shifted},\\text{unshifted})}\\binom{\\text{shifted}+\\text{unshifted}}{i}$ 计算，$shifted$ 是按住 shift 键输入的个数，$unshifted$ 是不需要按住 shift 键输入的个数，这个公式就不展开介绍了，原理与上面的字典匹配中的大小写模式计算一致。 重复匹配：整个重复的模式子串由 n 个重复的基础字串组成，如 nownownow 由基础子串 now 重复 3 次组成；重复匹配首先会递归的检测基础子串 now 的匹配模式，并计算其猜测次数 $g$；子串 now 的模式为字典模式，在字典表中排名第 42 位，子串重复了 3 次，整个重复模式子串的猜测次数为：$g\\times n$，即 nownownow 的猜测次数为 $42\\times 3$。\n如何理解这里的乘法呢：密码 123abcabcabc 中存在一段重复的子串 abcabcabc，只看基础单元 abc 攻击者需要尝试 $g$ 次才能猜对，在猜对基础单元后对于整个重复子串 abcabcabc 需要尝试将基础单元重复 3 次才能完整匹配中这段完整的重复子串：尝试重复 abc、尝试 abcabc、尝试 abcabcabc，即从重复 1 次 一直到重复 $n$ 次，所以要猜对这段完整的重复子串需要猜测 $g\\times n$\n顺序匹配：顺序匹配的猜测次数计算方法为：$S\\cdot N\\cdot \\lvert d\\lvert$，$S$ 为起始字符的可选个数，$N$ 为长度，$d$ 为相邻前后字符的 Unicode 编码差值（如 9753 的前后字符差值为 -2）。当模式子串首字符为 ['a','A','z','Z','0','1','9'] 中的任何一个时，$S$ 将被赋值为 4，如果首字符不在上述列表中，但是首字符为其他数字，则 $S$ 将被赋值为 10，其他情况 $S$ 将被赋值为 26，当字符序列为倒序时，还要在 $S\\cdot N\\cdot \\lvert d\\lvert$ 的基础上乘以二(因为猜完正序还要再猜一次倒叙)，即 $2\\cdot S\\cdot N\\cdot\\lvert d\\lvert$\n日期匹配：日期匹配的猜测次数计算方法为：$365\\cdot \\lvert now.year-date.year \\lvert$，可以看出这里的计算为估算\n暴力破解匹配：暴力破解的猜测次数计算方法为：$C^N$，$C$ 为常数被赋值为 10，即假设暴力破解时每个位置上的字符需要尝试 10 次，$N$ 为密码长度\n正则匹配：该模式在最终的代码实现中有但是论文中并未提及，猜测次数计算公式为：\n对于最近年份的正则：$\\lvert now.year-date.year \\lvert$，即年份差值的绝对值 对于其他正则：$C^N$，$C$ 为常数，每一种正则表达式都有一个对应的常数，代表破解一位需要尝试的次数，$N$ 为密码长度。可以看出此类匹配模式其实与暴力破解匹配模式类似 整个密码的猜测次数计算 整个猜测过程可由以下启发式搜索表示：\n$$ \\argmin\\limits_{S\\subseteq\\mathcal{S}}(D^{\\lvert S\\lvert-1}+\\lvert S\\lvert!\\prod\\limits_{m\\in S}m.guesses) $$公式含义：\n$\\mathcal{S}$：密码字符串的所有模式子串的集合，如：[levono(字典模式), eno(字典反转模式), no(单词模式), no(单词反转模式), 1111(重复模式), 1111(日期模式)]\n$S$：首尾相接能组成密码的非重叠模式子串序列，如：[levono(字典模式), 1111(重复模式)]，可以看出 $S$ 是 $\\mathcal{S}$ 的子集，即 $S\\subseteq\\mathcal{S}$\n$\\lvert S\\lvert$：首尾相接组成密码的模式子串序列 $S$ 的长度，即密码由几段模式子串组成，如上述子串序列的长度为 2\n$m$：$S$ 中的某个模式子串，可表示为：$m\\in S$ ；$m.guesses$ 为该模式子串的所需猜测次数\n$\\lvert S\\lvert!\\prod\\limits_{m\\in S}m.guesses$：假设攻击者知道密码由 $\\lvert S\\lvert$ 个模式子串组成，即假设攻击者知道密码中模式子串的数量，但是不知道这几个模式子串的排列顺序。\n比如一个密码由：字典模式子串 A、单词模式子串 B、日期模式子串 D 组成，那么这个密码可能为 ABC、ACB、BAC、BCA、CAB、CBA，共有 6 种。由排列公式 $P_{n}^{m}=\\frac{n!}{(n-m)!}$ 可知从 $\\lvert S\\lvert$ 个元素中选 $\\lvert S\\lvert$ 个元素进行排列，共有 $P_{\\lvert S\\lvert}^{\\lvert S\\lvert}=\\frac{\\lvert S\\lvert!}{(\\lvert S\\lvert-\\lvert S\\lvert)!}=\\frac{\\lvert S\\lvert!}{0!}=\\frac{\\lvert S\\lvert!}{1}={\\lvert S\\lvert!}$ 种可能；\n每个组成密码的模式子串 $m$ 的猜测次数为 $m.guesses$，那么不考虑模式子串顺序时整个密码的猜测次数为：组成密码的所有模式子串的猜测次数的累乘，即 $\\prod\\limits_{m\\in S}m.guesses$ ；\n由上可知，当考虑模式子串之间的顺序时，整个密码的猜测次数为 $\\lvert S\\lvert!$ 乘以 $\\prod\\limits_{m\\in S}m.guesses$ ，即 $\\lvert S\\lvert!\\prod\\limits_{m\\in S}m.guesses$\n$D$：一个常数，为经验值，即平均每个模式子串大概需要的猜测次数。根据 Dropbox 的经验，D 为 1000~10000 时公式表现较优\n$D^{\\lvert S\\lvert-1}$：为 $\\sum_{l=1}^{\\lvert S\\lvert-1}D^l$的近似值。假设攻击者不知道密码由多少个模式子串组成，每个模式子串的猜测次数假定为 $D$ ，那么 $l$ 个模式子串的猜测次数即为 $D^l$ 。假设攻击者总是从较少的模式子串数量开始猜测，在猜到正确的模式子串个数 $\\lvert S\\lvert$ 前，总的猜测次数即为 $\\sum_{l=1}^{|S|-1} D^l = \\frac{D(D^{|S|-1} - 1)}{D - 1} \\approx D^{|S|-1}$，即可近似简化为 $D^{\\lvert S\\lvert-1}$。\n$D^{\\lvert S\\lvert-1}+\\lvert S\\lvert!\\prod\\limits_{m\\in S}m.guesses$：现在从整体上来看，前半部分表示：在猜到正确的模式子串个数 $\\lvert S\\lvert$ 前的累计猜测次数；后半部分表示：在猜到正确的模式子串个数 $\\lvert S\\lvert$ 后，不知道这几个模式子串排列顺序的情况下需要的猜测次数；两部分相加即为总的猜测次数；\n$\\argmin\\limits_{S\\subseteq\\mathcal{S}}(D^{\\lvert S\\lvert-1}+\\lvert S\\lvert!\\prod\\limits_{m\\in S}m.guesses)$：可能存在多种首尾相接能组成密码的模式子串的组合 $S$，猜测次数最少的 $S$ 即为最优的组合，此时的猜测次数即为最小猜测次数\n从整个公式中可以看出，$D^{\\lvert S\\lvert-1}$ 和 $\\lvert S\\lvert!$ 以不同的方式惩罚过于复杂的模式子串组合。当两个不同长度的模式子串组合具有相近的 $\\prod\\limits_{m\\in S}m.guesses$ 猜测次数时，$\\lvert S\\lvert!$ 会倾向于较短的模式子串组合。$D^{\\lvert S\\lvert-1}$ 倾向于反对较长的模式字串组合，即使其具有较小的 $\\lvert S\\lvert!\\prod\\limits_{m\\in S}m.guesses$ 值。\n搜索最佳模式组合 给定一个密码字符串的所有模式子串(模式子串之间可能存在重叠)集合 $\\mathcal{S}$，最后一步是从 $\\mathcal{S}$ 中搜索出不存在重叠的模式子串的序列，使得整个序列能够刚好覆盖住整个密码，并使得猜测次数最小。下面将描述搜索使用的动态规划算法，可以很好的完成搜索任务。\n💡 整体思想是搜索能够覆盖从index=0到index=K的密码子串且猜测次数最小的模式子串序列。K从0迭代到password.length-1，进而逐渐的从局部最优迭代至整体最优。\n下面使用伪代码阐述该算法：\n简单介绍一下几个初始值： 解释 $n$ 为密码字符串的长度，$k$为索引值，$k\\in{0,1,2,…,password.length-1}$ $\\mathcal B_{opt}$ 为反向指针列表，用于记录密码上每个字符的相关数据。$\\mathcal B_{opt}[k][l]$ 是能覆盖密码子串 password[0~k] 且长度为 $l$ 的模式子串序列中的最后一个模式子串(该子串以 password[k] 结尾；该模式子串序列为尾字符是 password[k] 长度是 $l$ 的模式子串序列中猜测次数最少的子串序列，即 end=password[k] \u0026amp;\u0026amp; length=l 的局部最优解) $\\prod_{opt}[k][l]$ 为上述最佳模式子串序列中所有模式子串猜测次数的累乘。 $l_{opt}$ 是最佳模式子串序列的长度 $g_{opt}$ 上述模式子串序列的猜测次数 搜索函数： 解释 K 值从 0 迭代到 n-1，即从头到尾遍历密码上的每一个字符 以 K 索引对应字符为结尾的密码前缀子串的最佳猜测次数，初始值赋值为无限大 遍历密码所有模式子串 $\\mathcal S$ 中以 $k$ 结尾的模式子串 $m$ 如果该模式子串 $m$ 的起始位置 $m.i$ 大于 0，即该模式子串不是从密码的起始位置开始，其前面还有其他模式子串 遍历 $\\mathcal B_{opt}$ 中以 $m.i-1$ 结尾的所有最佳解模式子串序列的长度值(层级数) $l$ 在 $\\mathcal B_{opt}$ 中记录下以 $k$ 结尾，长度为 $l+1$ 的最佳模式子串序列的信息 如果该模式子串 $m$ 的起始位置 $m.i$ 为 0 在 $\\mathcal B_{opt}$ 中记录下以 $k$ 结尾，长度为 1 的最佳模式子串序列的信息 在 $\\mathcal B_{opt}$ 中记录下以 $k$ 结尾，暴力破解匹配的模式子串序列的信息 返回完整的 $\\mathcal B_{opt}$ 中以 $n-1$ 结尾的最佳模式子串序列的猜测次数值 补充暴力破解匹配的函数： 解释 构建一个从 0 到 $k$ 的暴力破解模式子串 $m$ 在 $\\mathcal B_{opt}$ 中记录下以 $k$ 结尾，长度为 1 的最佳模式子串序列的信息 遍历 $\\mathcal B_{opt}$ 中所有以 $k-1$ 结尾的模式子串序列，其长度为 $l$，结尾的模式子串为 $m$ 如果该模式子串 $m$ 的匹配方式为暴力破解 构建一个从 $m.i$ 到 $k$ 的模式子串，赋值给新的 $m$ 以 $m$ 更新在 $\\mathcal B_{opt}$ 中以 $k$ 结尾，长度为 $l$ 的最佳模式子串序列的信息 如果该模式子串 $m$ 的匹配方式不是暴力破解 构建一个只有 $k$ 的模式子串，赋值给新的 $m$ 以 $m$ 更新在 $\\mathcal B_{opt}$ 中以 $k$ 结尾，长度为 $l+1$ 的最佳模式子串序列的信息 更新 $\\mathcal B_{opt}$ 表的函数： 更新 $\\mathcal B_{opt}$ 中以模式子串 $m$ 结尾长度为 $l$ 的最佳模式子串序列 解释 将模式子串 $m$ 的猜测次数赋值给 $\\prod$ 如果模式子串序列的长度 $l$ 大于 1，即模式子串序列以 $m$ 结尾但是 $m$ 前面还有其他模式子串 $\\prod$ 等于该模式字串序列中所有模式子串的猜测次数的累乘值 如果模式子串序列的长度 $l$ 等于 1，即该序列中只有 $m$ 一个模式子串 则模式子串序列的猜测值 $\\prod$ 等于其中唯一的模式子串 $m$ 的猜测次数 $m.guesses$ 使用上面讲解的启发式计算整个模式子串序列的猜测次数 $g$ 如果 $g$ 小于$g_{opt}=\\mathcal B_{opt}[k][l]$ $g_{opt}$ 赋值为 $g$ $l_{opt}$ 赋值为 $l$ $\\prod_{opt}[k][l]$ 赋值为 $\\prod$ $\\mathcal B_{opt}[k][l]$ 赋值为 $m$ 从完整的 $\\mathcal B_{opt}$ 表中选出覆盖整个密码且猜测次数最小的模式子串序列： 解释\n由前一个步骤知最佳模式子串序列的长度为 $l_{opt}$，于是从 $\\mathcal B_{opt}[k][l_{opt}]$ 不断向前倒推便能得到完整的最佳的模式子串序列（动态规划——从局部最优中搜索出整体最优）\n根据最终评估出的密码猜测次数，会将密码分为四个等级：\n1 2 3 4 5 6 7 8 public static int guessesToScore(double guesses) { int DELTA = 5; if (guesses \u0026lt; 1e3 + DELTA) return 0; else if (guesses \u0026lt; 1e6 + DELTA) return 1; else if (guesses \u0026lt; 1e8 + DELTA) return 2; else if (guesses \u0026lt; 1e10 + DELTA) return 3; else return 4; } 参考 Five Algorithms to Measure Real Password Strength zxcvbn: realistic password strength estimation zxcvbn: Low-Budget Password Strength Estimation github: zxcvbn4j github: zxcvbn ","date":"2025-06-19T00:00:00Z","image":"https://heaciy.com/p/zxcvbn-explained/artiom-vallat-y7nZ4ENg7ic-unsplash_hu_9630a3b201cb1257.jpg","permalink":"https://heaciy.com/p/zxcvbn-explained/","title":"zxcvbn 原理详解"},{"content":" 前言： 因为工作中经常要接触到 Pcap 这种文件格式，无论是利用其进行网络数据分析，还是测试时使用其进行流量回放。但是 Pcap 文件的底层数据结构是什么样子呢？里面装的又是什么东西呢？这是本文将要解答的两个核心问题\nPcap 是什么 Pcap 是 Packet Capture 的缩写，即网络数据包捕获。将捕获的数据包按照一定格式存入文件即 Pcap 文件。在 Linux 平台上使用 Tcpdump，在 Windows 上使用 Wireshark 抓包，可以保存为 .pcap 后缀的文件。\n💡实际上 Pcap 文件存在多种格式，最常用的两种格式为 Libpcap 和 PcapNG(PCAP Next Generation) 格式，本文主要讲解 Libpcap 格式\nLibpcap 格式最新草案：\nhttps://datatracker.ietf.org/doc/html/draft-ietf-opsawg-pcap https://github.com/IETF-OPSAWG-WG/draft-ietf-opsawg-pcap Wireshark 说明：\nhttps://wiki.wireshark.org/FileFormatReference https://wiki.wireshark.org/Development/PcapNg https://wiki.wireshark.org/Development/LibpcapFileFormat Pcap 文件的数据结构 文件整体格式 Pcap 文件由一个全局的头部（Global Header）和零至多个数据包（Packet，与网络层的 Packet 不是一个概念）组成，全局头部主要用于存储字节顺序、文件版本、单个数据包最大长度等信息。每一个数据包又由 Header 和 Data 组成，Header 中主要用于存储时间戳和 Data 的长度信息。\n全局头部格式（Global Header） 现在来分析 Pcap 文件的全局头部，构造信息如下，每行 4 个字节（Byte）即 32 比特（bit），全局头部共计 24 个字节：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 1 2 3 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0 | Magic Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4 | Major Version | Minor Version | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8 | Thiszone | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12 | Sigfigs | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 16 | SnapLen | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 20 | LinkType | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ --- title: \u0026#34;PCAP Global Header\u0026#34; --- packet-beta 0-31: \u0026#34;Magic Number\u0026#34; 32-47: \u0026#34;Major Version\u0026#34; 48-63: \u0026#34;Minor Version\u0026#34; 64-95: \u0026#34;Thiszone\u0026#34; 96-127: \u0026#34;Sigfigs\u0026#34; 128-159: \u0026#34;SnapLen\u0026#34; 160-191: \u0026#34;LinkType\u0026#34; C 语言实现（来自Wireshark 文档），Github 上 Libpcap 的最新实现略有不同，不过无实质差别，具体见链接\n1 2 3 4 5 6 7 8 9 typedef struct pcap_hdr_s { guint32 magic_number; /* magic number */ guint16 version_major; /* major version number */ guint16 version_minor; /* minor version number */ gint32 thiszone; /* GMT to local correction */ guint32 sigfigs; /* accuracy of timestamps */ guint32 snaplen; /* max length of captured packets, in octets */ guint32 network; /* data link type */ } pcap_hdr_t; 相关字段解释如下表：\n字段 字节数 含义 Magic Number\nmagic_number 4 十六进制数字0xA1 B2 C3 D4，标记文件开始，并用来识别文件的字节顺序。 Major Version\nversion_major 2 一个无符号值，给出 pcap 格式的当前主要版本的编号，一般为2。 Minor Version\nversion_minor 2 一个无符号值，给出 pcap 格式的当前次要版本的编号，一般为4。（与上面的 Major Version 一起组成版本号 2.4 ） ThisZone\nthiszone 4 当地的标准时间，如果用的是UTC则全零，一般全零（在最新的标准中已弃用，因为现在都使用UTC时间，为向下兼容设置为全0） SigFigs\nsigfigs 4 时间戳的精度，一般全零（在最新的标准中已弃用，为向下兼容设置为全0） SnapLen\nsnaplen 4 设置所抓获的单个数据包的最大长度，一般设置为65535（单个数据链路层帧大小一般为1518字节包括14字节首部和4字节尾部，但是巨帧可达9000字节甚至更多，设置为65535大于任何标准或巨型以太网帧的大小，它提供了足够的空间来捕获几乎所有类型的网络数据包，包括非标准或实验性协议） LinkType\nnetwork 4 数据链路层协议类型。解析数据包首先要判断它的LinkType，所以这个值很重要。常见的值如 1，代表着以太网。相关定义和枚举值见参考链接 💡注意：对于 Magic Number，在其他地方或许会看到有人说除了0x A1 B2 C3 D4还有0x A1 B2 3C 4D，在较新的版本中确实存在A1 B2 3C 4D（大端模式）或者4D 3C B2 A1（小端模式）的情况，用于标记 Packet Header 中时间戳的精度为纳秒。\n故从 Pcap 文件的低位到高位度读取，存在以下四种情况：\nA1 B2 C3 D4：大端模式，Packet Header 中时间戳为毫秒精度 D4 C3 B2 A1：小端模式，Packet Header 中时间戳为毫秒精度 A1 B2 3C 4D：大端模式，Packet Header 中时间戳为纳秒精度 4D 3C B2 A1：小端模式，Packet Header 中时间戳为纳秒精度 ❗️ 网上的很多文档混淆了大小端和时间戳精度，注意甄别\n在最新草案中，全局头部的最后四字节数据也有所变化，感兴趣的朋友可以自行查看\n数据包头部格式（Packet Header） 数据包构造信息如下，每行 4 个字节（Byte）即 32 比特（bit），每个数据包头部共计 16 个字节：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0 1 2 3 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 0 | Timestamp (Seconds) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 4 | Timestamp (Microseconds) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 8 | Captured Packet Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 12 | Original Packet Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 16 / / / Packet Data / / variable length / / / +---------------------------------------------------------------+ --- title: \u0026#34;PCAP Packet Record\u0026#34; --- packet-beta 0-31: \u0026#34;Timestamp (Seconds)\u0026#34; 32-63: \u0026#34;Timestamp (Microseconds)\u0026#34; 64-95: \u0026#34;Captured Packet Length\u0026#34; 96-127: \u0026#34;Original Packet Length\u0026#34; 128-191: \u0026#34;Packet Data (variable length)\u0026#34; C 语言实现（来自Wireshark 文档），Github 上 Libpcap 的最新实现略有不同，不过无实质差别，具体见链接\n1 2 3 4 5 6 typedef struct pcaprec_hdr_s { guint32 ts_sec; /* timestamp seconds */ guint32 ts_usec; /* timestamp microseconds */ guint32 incl_len; /* number of octets of packet saved in file */ guint32 orig_len; /* actual length of packet */ } pcaprec_hdr_t; 相关字段解释如下表：\n字段 字节数 含义 Timestamp(Seconds)\nts_sec\n4 秒级时间戳，秒值是一个 32 位无符号整数，表示自 1970 年 1 月 1 日 00:00:00 UTC 以来经过的秒数 Timestamp(Microseconds)\nts_usec 4 微秒值表示自秒值之后经过的微秒(可以理解为秒数小数点后的数) Captured Packet Length\nincl_len 4 一个无符号值，表示从网络中实际中捕获的字节数（即 Packet Data 的长度）。它的值为原始数据包长度（Original Packet Length）和快照长度（上表中的 SnapLen）中的较小值。 Original Packet Length\norig_len 4 一个无符号值，表示数据包在网络上传输时的实际长度。如果数据包在捕获过程中被截断，则捕获的数据包长度与实际网络中传输的数据包长度不同。 Packet Data\ndata 由上述 Captured Packet Length 字段决定 实际被捕获的数据链路层帧，包括链路层标头。该字段的实际长度为 Captured Packet Length。链路层头部的格式取决于文件全局头部中指定的 LinkType 字段。可以理解为：每一个 Packet 中都装着一个数据链层的帧。 使用 ImHex 查看 Pcap 包 经过上文的介绍我们知道了 Pcap 文件的全局头部格式和数据包头部格式，下面我们使用十六进制编辑器开始查看和分析一个实际的 Pcap 文件：\n图 3.1：使用 ImHex 打开 Pcap 文件\n全局头部 根据上述章节的分析可知全局头部占24个字节，于是让我们分析上述 Pcap 文件的前24个字节，如下图：\n图 3.1.1：Pcap 文件的全局头部\n具体内容如下：\n1 2 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 D4 C3 B2 A1 02 00 04 00 00 00 00 00 00 00 00 00 FF FF 00 00 01 00 00 00 前四个字节为 Magic Number，从低地址到高地址依次为 D4 C3 B2 A1，由上述章节可知该 Pcap 文件的字节顺序为小端序，那么对于多字节数据需要倒排字节才能得到实际的数据，具体数据转换如下表：\n字段 字节序号 小端序数据 大端序数据 实际数据(由大端序计算) Magic Number(4B) 0-3 0xD4 C3 B2 A1 0xA1 B2 C3 D4 LE 小端模式标记 Major Version(2B) 4-5 0x02 00 0x00 02 2 Minor Version(2B) 6-7 0x04 00 0x00 04 4 ThisZone(4B) 8-11 0x00 00 00 00 0x00 00 00 00 0 SigFigs(4B) 12-15 0x00 00 00 00 0x00 00 00 00 0 SnapLen(4B) 16-19 0xFF FF 00 00 0x00 00 FF FF 65535 LinkType(4B) 20-23 0x01 00 00 00 0x00 00 00 01 LINKTYPE_ETHERNET 以太网 数据包头部 根据上述章节可知，数据包头部为 16 字节，那么全局头后面的16个字节即为 Pcap 文件中第一个数据包的头部，如下图：\n图 3.2.1：Pcpa 文件中第一个数据包的头部信息\n具体信息如下：\n1 2 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 1F 90 D1 66 69 B3 07 00 36 00 00 00 36 00 00 00 依次分析，数据包头由四个字段组成，每个字段 4 个字节，具体数据转换如下表：\n字段 字节序号 小端序数据 大端序数据 实际数据(由大端序计算) Timestamp(Seconds)(4B) 24-27 0x1F 90 D1 66 0x66 D1 90 1F 1725009951 Timestamp(Microseconds)(4B) 28-31 0x69 B3 07 00 0x00 07 B3 69 504681 Captured Packet Length(4B) 32-35 0x36 00 00 00 0x00 00 00 36 54 Original Packet Length(4B) 36-39 0x36 00 00 00 0x00 00 00 36 54 秒级时间戳为 1725009951，微妙精度值为 504681，因此完整的秒级时间戳为1725009951.504691，转换为UTC +8时间为：2024-08-30 17:25:51\n数据包捕获长度（Captured Packet Length）和网络上该包实际长度（Original Packet Length）是相同的说明网络上的数据包被完整捕获。意味着此 Packet Header 对应的 Packet Data 的长度为 54 字节。\n数据包负载 由上述信息可知第一个 Packet 数据包的数据体长度为 54 字节，因此从该数据包包头的最后一个字节后向后读取 54 字节即为第一个 Packet 数据包的数据体。\n循环上述流式读取过程（先读取全局头部 24 字节，读取Packet 数据包头部 16 字节，读取 Packet 包头（Packet Header）中字段 Captured Packet Length 记录长度的数据作为数据体（Packet Data），读取第二个包头，读取第二个数据体……）\n这里的一个个 Packet 数据包，便对应着 Wireshark 工具中的一条条记录，现在让我们使用 ImHex 和 Wireshark 查看该 Pcap 文件中的第一个数据包的数据体：\n图 3.3.1 使用 ImHex 查看第一个数据包的数据体\n图 3.3.2 使用 Wireshark 查看第一个数据包\n可以看出图 3.3.1 中选中的 54 字节数据，与图 3.3.2 中最下面显示的 54 字节数据一致。\n那么这 54 字节数据是什么呢？以及为什么是 54 字节而不是其他数字呢？对网络比较熟悉的朋友可能已经知道答案了：54 = 14 + 20 + 20；下面让我们按照网络协议栈从上往下，来看看这里的 14 和 20 都是什么：\n图 3.3.3 网络模型和协议\n由上述图 3.3.2 Wireshark 的截图我们可知，第一个数据包捕获的内容即为 HTTP 协议在建立 TCP 连接前（HTTP 1.* 协议是基于 TCP 协议的）由客户端发起的第一个 ACK 请求。于是我们从 TCP 协议所在的传输层往下分析：\n图 3.3.4 网络模型 数据发送流程中数据的传递过程\n传输层：第一个数据包捕获的是 TCP 建立连接前的第一个由客户端发起的 ACK 请求，由于此次只使用到了 TCP 协议的头部，故为传输层的报文段（segment）的长度即为 TCP 协议头部的长度，即 20 字节。 网络层：上述传输层的报文向下交由网络层处理，网络层会为其增加一个网络层头部（20字节），然后继续向下层数据链路层传递。故而网络层封装好后数据包（Packet，这里的Packet指网络层数据包，与 Pcap 文件中的数据包为不同概念）大小为： 网络层数据包头长度（20 字节）+ 网络层数据包的数据体长度（20 字节）= 40 字节 数据链路层：上述网络层的数据包（40 字节）向下交由数据链路层处理，数据链路层会为其加上一个数据链路层头部（14 字节）和数据链路层尾部（FCS 即帧校验序列，4字节）进而组成一个数据链路层的帧。故而此帧的大小为： 帧头（14字节）+ 帧负载（40字节）+ 帧尾（4字节）= 54 + 4 = 58字节 此时有朋友可能已经发现异常了，为什么我们上述 Pcap 文件中第一个数据包的数据体只有 54 字节，相比我们的计算值少了 4 个字节的数据，原因很简单因为数据链层的帧尾是由网卡负责处理的，网卡负责帧尾的计算和校验，在发送数据时网卡计算并添加帧尾后将数据发出，在收到数据时网卡校验并去除帧尾后再向上层传递，故而我们拿到的数据链路层帧其实是通过了帧尾校验并去除了帧尾之后的数据，所以就是 58 - 4 = 54 字节。 由上述信息可知，Pcap 文件中第一个数据包的 54 字节数据体中，前 14 字节为数据链路层头部，往后中间的 20 字节为网络层头部，最后 20 字节即为传输层头部（为什么只有头部没有数据体？因为TCP建立连接前的第一次 ACK 请求用不上数据体）。\n这里我们就不再按照字节去分析链路层、网络层或是传输层的头部信息了，因为 Wireshark 已经可以很好的帮我们分析。有一个细节是，虽然该 Pcap 文件的字节序是小端序，但是在计算链路层、网络层等层的头部信息时，对于多字节字段不需要倒排字节，因为网络传输使用的是大端序，又因为 Pcap 文件中每一个数据包的数据体都是一个”数据链路层帧”，并未做其他转换，故而数据体中的数据也是大端序，在计算跨字节数据时不需要逆转字节顺序。\n总结 至此我们完成了 Libpcap 格式的 Pcap 文件数据构造分析。并以一个实际的 Pcap 文件作为例子进行了对照学习。解答了前言中提出的问题：\nPcap 文件的数据构造？\nPcap 文件由一个 24 字节的全局头部（Global Header），和多个数据包（Packet）组成；每一个数据包又由 16 字节的头部（Packet Header）和数据体（Packet Data）组成，数据体的长度由头部字段 Captured Packet Length 记录；\nPcap 文件的数据包中的数据体（Packet Data）保存的是什么内容？\nPcap 文件中的每一个数据包对应 WireShark 中的一条记录；每一个数据包中的数据体对应一个捕获到的“数据链路层的帧”（无 FCS 帧尾）；\n本文并未提及 Pcap 包的捕获和回放方法，感兴趣的读者可以自行检索，具体实现方法包括但不限于：原始套接字、DPDK、XDP\n参考链接 Libpcap File Format Capture File Format Reference Pcap link types ","date":"2025-01-05T00:00:00Z","image":"https://heaciy.com/p/analyzing-libpcap-pcap-file/cover_hu_b2017c6ff17a514d.jpg","permalink":"https://heaciy.com/p/analyzing-libpcap-pcap-file/","title":"Libpcap格式pcap包分析"},{"content":" 本文基于王道的数据结构考研复习指导，仅作为本人的学习笔记，如有误欢迎指正\n插入排序 直接插入排序 整个例表[0...i-1, i, i+1...n]，i前面的部分维持有序，从i开始向后遍历无序的部分，不断往前面有序的部分插入，插入流程是\ni与i-1（i前面的元素，即有序列表中最后一个，即最大值）比较 如果i大于i-1则说明i比0~i-1都大，故将i插入到有序部分的最后（即保持当前位置不变） 如果i比i-1小，则从i-1开始向前寻找合适的位置，一边比较，一边挪动，直到找到合适的位置，再将i对应的值放到该位置 不断地把i位置的元素插入到i前面的有序部分中，直到最后一个插入完成即有序\n1 2 3 4 5 6 7 8 9 10 11 def insert_sort(A: List[int]): \u0026#34;\u0026#34;\u0026#34; 插入排序 稳定 O(n^2) \u0026#34;\u0026#34;\u0026#34; tmp = 0 for i in range(1, len(A)): # i从第二个位置开始 if A[i] \u0026lt; A[i-1]: # 与有序部分最大值比较判断是否需要挪动 tmp = A[i] # 暂存当前值 j = i-1 while(A[j] \u0026gt; tmp and j \u0026gt;= 0): # 向后挪动，将插入位置挪出来 A[j+1] = A[j] j -= 1 A[j+1] = tmp # 将当前值放入插入位置 空间效率：仅使用了常数个辅助单元，因此空间复杂度为O(1)\n时间效率：在排序时向有序子表中插入当前元素共进行了n-1趟，每趟操作都在进行比较和移动，而比较次数和移动次数取决于待排表的初始状态\n最好情况：初始表基本有序，每趟都只需要比较一次而不用移动元素，时间复杂度为O(n) 最坏的情况：初始表逆序，总比较次数$\\sum_{i=2}^n{i}$，总移动次数$\\sum_{i=2}^n{i+1}$ 平均情况：初始表状态随机，取最坏和最好的平均值，总比较和总移动次数均约为O($\\frac{n_2}{4}$) 稳定性：由于每次插入前总是先比较再移动，所以不会出现相同元素位置发生变化的情况，故直接插入排序是一种稳定的排序方法\n适用性：适用于顺序存储和链式存储的线性表。为链式时，可以从前往后的查找元素位置\n注意：大部分排序算法都仅适用于顺序存储的线性表\n折半插入排序 同样的道理，依次遍历后面无序的部分往前面有序的部分插入，只是将从有序部分中查找插入位置的过程改成二分查找，找到正确的插入位置后再依次挪动，把插入位置挪出来，将值放入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def insert_sort_binary(A: List[int]): \u0026#34;\u0026#34;\u0026#34;折半插入排序 稳定 O(n^2)\u0026#34;\u0026#34;\u0026#34; for i in range(1, len(A)): tmp = A[i] # 暂存当前值 low, high = 0, i-1 while(low \u0026lt;= high): # 二分查找 mid = int((low+high)/2) if A[mid] \u0026lt; tmp: low = mid+1 else: high = mid - 1 j = i-1 while(j \u0026gt; high): # 向后挪值，将插入位置挪出来 A[j+1] = A[j] j -= 1 A[high+1] = tmp # 总是在high的下一个位置插入 时间效率：相比直接插入排序只是减少了比较次数，约为O($n\\log_2{n}$)，且与表的初始状态无关，仅取决于表中元素数量n。而元素移动次数不变，依赖于待排表的初始状态。因此时间复杂度仍为O($n^2$)\n稳定性：折半插入排序是一种稳定的排序方法\n适用性：适用于线性表为顺序存储的情况，对于数据量不是很大的排序表，折半插入排序往往具有较好的性能\n希尔排序 希尔排序也称缩小增量排序\n设置一个步长，每次从第一个元素开始，每隔一个步长取一个元素，将这些间隔步长的一组元素使用插入排序进行排序，然后逐渐缩短步长，直至步长为1。\n一边缩短步长，一边对使用当前步长划分的小组进行插入排序。每一次根据步长的排序都会使当前列表逐渐有序。列表逐渐有序，也就逐渐减小了后面几趟排序时的工作量。最后一趟步长为1，也就意味着对当前整个列表进行插入排序，但是得益于前面几趟的排序使得整个列表基本有序，那么当前的排序工作量就被减少了很多。经过最后一趟排序，整个列表就有序了\n整个过程就体现了它的名字：缩小增量排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def shell_sort(A: List[int]): \u0026#34;\u0026#34;\u0026#34;希尔排序 不稳定 O(n^1.3)~O(n^2)\u0026#34;\u0026#34;\u0026#34; n = len(A) dk = int(n/2) # 初始步长 while(dk \u0026gt;= 1): # 结束出口 for i in range(dk, n, dk): # 从当前小组的第二个开始 if A[i] \u0026lt; A[i-dk]: # 与小组内前一个比较 tmp = A[i] j = i-dk while(A[j] \u0026gt; tmp and j \u0026gt;= 0): # 比较、挪动 A[j+dk] = A[j] j -= dk A[j+dk] = tmp dk = int(dk/2) # 不断地减小步长 空间效率：仅使用了常数个辅助单元，空间复杂度为O(1)\n时间效率：依赖于增量序列的函数，涉及数学上尚未解决的难题，当n在某个特定范围时时间复杂度约为O($n^{1.3}$)。最坏情况为O($n^2$)\n稳定性：当相同关键字记录被划分到不同子表时，可能会改变原有相对次序，故希尔排序是一种不稳定的排序方法\n适用性：希尔排序仅适用于线性表为顺序存储的情况\n交换排序 冒泡排序 从前往后（或从后往前）两两比较相邻元素的值，若为逆序（A[i]\u0026gt;A[i+1]）则交换他们，直到序列比较完。这一过程成为冒泡，第一次从A[0]到A[n-1]，最大值将被冒泡到最后一个位置即A[n-1]；第二次从A[0]到A[n-2]，次大值将被冒泡到A[n-2]……每一趟冒泡都将一个元素放到其最终的位置。最多n-1趟冒泡就能把所有元素排好序\n1 2 3 4 5 6 7 8 9 10 11 12 def bubble_sort(A: List[int], n:int): \u0026#34;\u0026#34;\u0026#34;冒泡排序 稳定 O(n^2)\u0026#34;\u0026#34;\u0026#34; tmp = n-1 # 需要n-1趟冒泡,tmp也为最后一个元素的下标 while(n \u0026gt; 0): flag = False # 表示本趟冒泡是否发生值交换的标志 for i in range(0, tmp): # 一趟冒泡排序，从0到tmp-1 if A[i] \u0026gt; A[i+1]: # 若为逆序则交换 A[i], A[i+1] = A[i+1], A[i] flag = True if not flag: return # 本趟没有发生交换，则说明序列已经有序，无需再调整 tmp -= 1 空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)\n时间效率：\n最好情况：原始序列初始有序，第一趟冒泡后flag为False，即结束排序，共比较了n-1次，移动次数为0，故时间复杂度为O(n) 最坏情况：原始序列逆序，需要n-1趟排序，第i趟要进行i-1次比较，而每次比较后都必须移动元素3次来交换元素位置（针对原书中的C语言版本tmp=a;a=b;b=tmp）故共比较了$\\sum_{i=1}^{n-1}{(n-1)}=\\frac{n(n-1)}{2}$，移动次数$\\sum_{i=1}^{n-1}3(n-i)=\\frac{3n(n-1)}{2}$。从而最坏情况下时间复杂度为O($n^2$) 平均时间复杂度：O($n^2$) 稳定性：从前往后，先比较再移动，相邻两元素若相等则不会发生交换，故稳定。\n注：冒泡排序不同于插入排序，对于冒泡排序，每一趟排序后都有一个元素被放置到最终的位置上，也就是说全局有序。\n快速排序 选定一个枢轴，将小于它的值都交换到它前面，将大于它的值都交换到它的后面，然后对前后两个部分继续递归划分。一般选列表中的第一个作为枢轴，对整个列表进行划分。设置两个标志low和high，low从第一个元素开始，high从最后一个元素开始。\n设有一个列表L\n首先将一个元素赋值给枢轴pivot 开始划分 将high所指元素与pivot比较，如果L[high]\u0026gt;=pivot，则将high前移指向前一个元素，从后往前直到找到第一个小于pivot的值，将这个值覆盖到L[low] low从第一个往后走，直到找到第一个大于pivot的值，将这个值覆盖到L[high] 上述1、2两部交替执行，直到low=high，此时这个位置就是pivot的最终位置，将pivot放置到该位置 经过上面一趟划分之后，pivot前面的元素都小于它，后面的元素都大于它。pivot将列表L划分为前面小于它的子表，和后面大于它的子表。然后再基于分治的思想对前后两个子表进行划分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def quick_sort(A: List[int], low: int, high: int): \u0026#34;\u0026#34;\u0026#34;快排 不稳定\u0026#34;\u0026#34;\u0026#34; def partition(L: List[int], low: int, high: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;划分函数\u0026#34;\u0026#34;\u0026#34; pivot = L[low] # 将当前表中第一个元素作为枢轴,对表进行划分 while(low \u0026lt; high): # 循环跳出条件low=high # 操作1、2交替进行直到low=high，此位置即为pivot的最终位置 # 1.high从后往前，当high的值比枢轴值大时将其放到low对应的位置 while(low \u0026lt; high and L[high] \u0026gt;= pivot): high -= 1 L[low] = L[high] # 2.low从前往后前，当low对应的值大于大于枢轴值时将其放到high的位置 while(low \u0026lt; high and L[low] \u0026lt;= pivot): low += 1 L[high] = L[low] L[low] = pivot # 此时low=high,将枢轴放置该位置 return low # 返回枢轴的最终位置 if low \u0026lt; high: # 当传入的low=high时不再需要划分 pivotpos = partition(A, low, high) # 根据上一趟枢轴的位置划分子表 quick_sort(A, low, pivotpos-1) # 依次递归排序两个子表 quick_sort(A, pivotpos+1, high) 选择排序 简单选择排序 “设排序表为L[1\u0026hellip;n]，第i趟排序即从L[i..n]中选择关键字最小的元素与L[i]交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可以使得整个排序表有序”，通俗的说就是从前往后不断地把最小的值换到前面去。\n1 2 3 4 5 6 7 8 9 def select_sort(A: List[int], n:int): \u0026#34;\u0026#34;\u0026#34;选择排序 不稳定\u0026#34;\u0026#34;\u0026#34; for i in range(0, n-1): # 一共进行n-1趟排序 min = i # 记录最小值位置 for j in range(i+1, n): # 在A[i...n-1]中选择最小的元素 if A[j] \u0026lt; A[min]: min = j # 更新最小元素位置 if min != i: A[i], A[min] = A[min], A[i] # 将最小值替换到前面的位置 空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)\n时间效率：简单选择排序移动次数较少，最多不会超过3(n-1)次对应逆序，最少0次对应排序表初始有序。比较次数与初始状态无关，始终是$\\frac{n(n-1)}{2}$次，因此时间复杂度始终是O($n^2$)\n稳定性：在第i趟找到最小元素后，和第i个元素交换，可能导致第i个元素与其含有相同关键字元素的相对位置发生改变。比如{2，2，1}经一趟排序后是{1，2，2}，显然2和2的相对位置发生了变化。因此，简单选择排序是一种不稳定的排序方法。\n比较直接插入、冒泡和简单选择排序\n直接插入排序：从后往前，从无序部分中取值往前面有序部分中插入，稳定\n冒泡排序：从后往前，一边比较一遍交换挪动位置，每趟都会确定一个元素的最终位置，稳定\n简单选择排序：从当前元素往后找出最小值的位置，然后将最小值和当前位置的元素交换，每趟都会确定一个元素的最终位置，但是不稳定，比如[2,2,1]交换排序后就是[1,2,2]，第一个2和第二个2相对顺序发生了变化\n堆排序 堆的定义如下：\nL[i]\u0026gt;L[2i]且L[i]\u0026gt;L[2i+1] 或\nL[i]\u0026lt;L[2i]且L[i]\u0026lt;L[2i+1] (1≤i\u0026lt;≤⌊n/2⌋)\n可以将一个一维数组视为一颗完全二叉树，满足上述条件一的为大根堆，注意：节点序号是从1开始的\n当前节点序号为n，其左孩子序号为2*n，其右孩子节点为2*n+1\n借助最大堆或最小堆进行排序（注意：最大堆、最小堆与二叉排序数不同！最大堆只是根节点比子节点大，但是左右子节点之间并没有固定的大小关系；二叉排序树中，左儿子最小，根节点居中，右儿子最大，所以二叉排序树的中序遍历得到的序列即是有序的）。构建出初始最大堆后，输出堆顶元素，然后“删除”，将最后一个叶节点移到堆顶位置，重新调堆，输出堆顶元素……重复上述过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def heap_sort(A: List[int], length: int): \u0026#34;\u0026#34;\u0026#34;堆排序 不稳定 O(nlog2n)\u0026#34;\u0026#34;\u0026#34; def bulid_max_heap(L: List[int], length: int): \u0026#34;\u0026#34;\u0026#34;构建最大堆\u0026#34;\u0026#34;\u0026#34; i = int(length/2) # 最后一个父节点，根据完全二叉树的性质 while(i \u0026gt; 0): # 从i= ⌊n/2⌋~1，反复调堆，注意节点下标是从1开始的 adjust_heap(L, i, length) i -= 1 def adjust_heap(L: List[int], k: int, length: int): # 调整以元素K为根节点的子树 # 第一个节点要预留（即下标为0的节点） L[0] = L[k] # 使用L[0]暂存子树的根节点 i = 2*k # 第一个子节点 while i \u0026lt;= length: if i \u0026lt; length and L[i] \u0026lt; L[i+1]: # 沿key较大的子节点向下筛选 i += 1 # 取key较大的子节点的下标 if L[0] \u0026gt; L[i]: # 根节点大于最大的子节点，不需要再调整 break else: L[k] = L[i] # 将L[i]调整到双亲节点上 k = i # 修改K值，继续向下筛选，K值即为当前的双亲节点 i *= 2 # 继续 L[k] = L[0] # 被筛选节点的值放入最终位置 bulid_max_heap(A, length) # 创建初始堆 n = length while n \u0026gt;= 1: # 注意下标为0的节点“不存储数据” A[1], A[n] = A[i], A[n] # 交换堆顶和堆低元素，相当于把最大值移到最后的位置 n -= 1 # \u0026#34;缩短长度\u0026#34;，调整堆的大小，把剩余n-1个元素整理成堆 adjust_heap(A, 1, n) 归并排序 “归并就是将前后两个有序表归并成一个有序表。设两段有序表A[low\u0026hellip;mid], A[mid+1\u0026hellip;high]存放在同一顺序表中的相邻位置，先将他们复制到数组B中。每次从对应B中的两个段中取出一个记录进行关键字比较，将较小者放入A中，当数组B中有一段的下标超出其对应的表长（即该段的所有值都已复制到A中）时，将另一段中剩余的部分直接复制到A中。”\n通俗的说：归并就是将两个有序表合成一个，将原表先拷贝一份，然后从中间分为左右两个子表，依次比较左右两个表中的值，并将较小值插入原表，若最后左右子表中还有一个有剩余的，则将剩余的元素直接复制到原表中\n递归形式的2路归并排序是基于分值的，先一直向下划分 mid = ( low + high ) / 2，直到low=high-1（递归出口），即low与high相邻，此实左右子表都只有一个元素，即左右子表此时都是有序的，然后就可以开始合并了，一直向上合并直到最上面一层合并完成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def merge_sort(A: List[int], low: int, high: int): \u0026#34;\u0026#34;\u0026#34;归并排序 二路归并 稳定 O(n*log2n)\u0026#34;\u0026#34;\u0026#34; def merge(A: List[int], low: int, mid: int, high: int): # 合并左右两段有序的序列A[low..mid]和A[mid+1...high] B = A.copy() # 把A拷贝一份，然后直接在A上调整 i = low j = mid+1 k = i while i \u0026lt;= mid and j \u0026lt;= high: # 比较、挪动、将较小值放回A中 if B[i] \u0026lt; B[j]: # 比较B中左右两段中的元素 A[k] = B[i] i += 1 # 将较小值放入A中 else: A[k] = B[j] j += 1 k += 1 # 下面两个while只有一个会执行 while i \u0026lt;= mid: # 左侧序列未检测完、复制 A[k] = B[i] k += 1 i += 1 while j \u0026lt;= high: # 右侧序列未检测完、复制 A[k] = B[j] k += 1 j += 1 if low \u0026lt; high: # 递归条件，只有当low=high-1时，即low、high相邻时才停止递归 # 此时，左右两段各有一个值，即左右两段都有序，则开始执行merge合并有序段 # 然后向上回退，一边回退一边merge # 递归形式的二路归并 mid = int((low+high)/2) # 从中间划分两个子序列 merge_sort(A, low, mid) # 对左侧子序列进行递归排序 merge_sort(A, mid+1, high) # 对右侧子序列进行递归排序 merge(A, low, mid, high) # 归并 各种排序算法的比较 算法 O(最好情况) O(平均情况) O(最坏情况) 空间复杂度 是否稳定 直接插入排序 O(n) O($n^2$) O($n^2$) O(1) ✅ 冒泡排序 O(n) O($n^2$) O($n^2$) O(1) ✅ 简单选择排序 O($n^2$) O($n^2$) O($n^2$) O(1) ❌ 希尔排序 ❌ 快速排序 O($nlog_2n$) O($nlog_2n$) O($n^2$) O($log_2n$) ❌ 堆排序 O($nlog_2n$) O($nlog_2n$) O($nlog_2n$) O(1) ❌ 2路归并排序 O($nlog_2n$) O($nlog_2n$) O($nlog_2n$) O(n) ✅ ","date":"2021-06-17T00:00:00Z","image":"https://heaciy.com/p/internal-sort/internal-sort_hu_abbfe825e4d8c72d.jpg","permalink":"https://heaciy.com/p/internal-sort/","title":"常用内部排序算法"},{"content":" 我承认，是标题党！哈哈哈哈哈哈哈，本来是准备写一篇“Django Signal源码解析——从Observer Pattern到Django Signal”的，但是我又不能一两句话把观察者模式讲清楚的，干脆就直接贴了一些相关的链接……后面越写越多、越拖越长就干脆改成简析算了…… 本文只作为个人学习记录，仅供参考，如有误欢迎讨论指正 题图来自 unsplash，原图链接🔗\n观察者模式 “观察者模式是一种对象行为模式。它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。[1]”\n“观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。[2]”\n观察者模式有多种实现方式，比较经典的一种实现，有四个角色：Subject（被观察对象抽象类）、Observer（观察者抽象类）、ConcreateObserver（具体观察者）、ConcreateSubject(具体的被观察者)……\n这里就不赘述了……可以参见下面的链接\nwikipedia：Observer pattern 百度百科：观察者模式 观察者模式（Observer模式）详解 观察者模式 菜鸟教程：观察者模式 观察者模式的python简单实现 Signal简述 可以先看看Django的官方文档\nhttps://docs.djangoproject.com/zh-hans/3.0/topics/signals/ https://docs.djangoproject.com/zh-hans/3.0/ref/signals/ 与观察者模式对应：sender就是被观察者、receiver是观察者。有所不同的就是多了个signal，也就是“信号”（也可使说是信号的“管理者”）。在普通观察者模式中，被观察对象抽象类中一般会维护一个观察者抽象类的引用列表，以此来传递消息，而django中则是借助Signal类进一步解耦，通过Signal类进行“信号传递”，具体解析如下：\n1. signal 信号类，维护一个receivers列表，用于存储sender和receiver的对应记录\nsignal.connect()用于往signal.receivers中添加对应的receiver和sender记录\nsignal_send()，在signal.receivers中查找sender对应的receivers并将对应信号(参数)传递给对应的receivers\ndjango预置了一些信号对象，pre_init、post_init、pre_save、post_save等，这些都是直接或间接的继承自Siganl类，单一职责原则，每个具体的信号对象只负责存储“一类信号”，比如前面列举的四个信号对象都是django model相关的。以pre_save为例，只有在调用某个model对象的save方法时（前）才会调用pre_save.send()发送相关数据（“信号”）。也就是说pre_save这个Signal对象的receivers列表中存储的sender都是model而receiver都是我们希望在进行model.save()前调用的函数来进行的一些相关操作。\n2. sender 信号的发送方，即调用signal.send()方法的类。比如，所有model类的父类都是BaseModel，而BaseModel有一个__init__函数在该函数中，首先就会调用pre_init.send(self.__class__,**kwargs)发送即将开始init的信号，然后再进行具体的init操作，在init之后再调用post_init.send发送init完成的信号。故这里的BaseModel类就是这两个信号对象(pre_init、post_init)的sender。而我们的model类都是继承自BaseModel，init方法也是继承来的，故此时的sender就是我们定义的model类。\n3. receiver 信号的接收方，为可调用对象，一般是个函数，接收signal.send()传递过来的参数，再进行相关的操作\n假如我们有个model对象为People，我们想要在构造每一个People时（new_people = People(name=\u0026quot;haha\u0026quot;,email=\u0026quot;haha@mail.com\u0026quot;)）打印出其相关信息，我们可以用一个函数打印其信息：\n1 2 def print_info(*args,**kwargs): print(f\u0026#34;args: {args}\\nkwargs: {kwargs}\u0026#34;) 然后使用pre_init.connect(print_info, sender=People)将其与sender绑定起来,即在pre_init的receivers列表中存一条对应的记录:\n1 ((People_id,print_info_id),print_info_weakref) 此处的print_info函数即为一个receiver，pre_init信号中People类对应的receiver。\n当然也可以直接使用装饰器，不过也是同样的道理\n1 2 3 @receiver(pre_init,sender=People) def print_info_before_init(sender,*args,**kwargs): print(f\u0026#34;args: {args}\\nkwargs: {kwargs}\u0026#34;) 最终打印出来的结果是\n1 2 args: [] kwargs: {\u0026#39;name\u0026#39;:\u0026#39;haha\u0026#39;,\u0026#39;email\u0026#39;:\u0026#39;haha.mail.com\u0026#39;} 原理简析 django的整个信号模块都是依赖Signal这个类完成的\n1. Signal的属性和__init__方法 1.receivers：一个列表用于存取该Signal中对应的sender和receiver并存下receiver的引用(或弱引用)，在调用connect()方法时会往receivers中添加对应关系，而在调用send()方法时会在其中查找对应关系\n数据结构：\n1 2 3 4 5 6 7 8 # 如果在调用connect方法添加时weak参数为True（默认为True） # 则存储receiver的弱引用，在垃圾回收时会自动处理 [((receiver_id,sender_id),receiver_weakref),] # 弱引用 # 如果connect方法的weak参数为False # 则存储receiver的强引用，最终需要调用disconnect销毁记录 # 否则相关变量无法被垃圾回收，也就是”内存泄露“ [((receiver_id,sender_id),receiver),] # 强引用 2.providing_args：该signal接受的参数的列表\n3.lock：threading.lock，对相应操作加锁以保证安全\n4.use_caching：bool类型，标识是否使用缓存，如果使用缓存我们会缓存每一个sender类的receivers并存储到self.sender_receivers_cache中\n5.sender_receivers_cache：signal对每一个sender的receivers进行缓存\n数据结构：\n1 2 3 4 { \u0026#34;sender1\u0026#34;: [receiver1_weakref, receiver2_weakref,...], \u0026#34;sender2\u0026#34;: [receiver3_weakref, receiver4_weakref,...], } 每次send时会使用sender_receivers_cache快速判断该sender是否有receiver，如果有则再调用_live_receivers获取其对应的receivers的强应用列表\n6._dead_receivers：bool类型，用于标识self.reivers中是否含有失效的 receiver的弱引用。当弱引用指向的receiver被垃圾回收时会调用Signal._remove_receiver方法将_dead_receivers置为True\n2. Signal中的方法 说在前面：receiver和sender都必须是可哈希的\n1.connect：将receiver和sender通过对应的Signal连接起来（即将对应记录添加到对应Signal对象的receivers属性列表中）\n参数解析：\nreceiver：需要接收信号的receiver sender：发送该信号的sender weak：是否使用弱引用，默认为True。如果为True则存储receiver对应的weakref否则直接存储强引用。由于设置了weakref.finalize(receiver_object, self._remove_receiver)若存储弱引用则可以在receiver垃圾回收时自动清除Signal.receivers中对应的记录（见下面的分析）若存储强引用则需要先手动调用disconnect方法删除Signal.receivers中对应的记录否则该receiver将无法被垃圾回收导致“内存泄漏” dispatch_uid：默认为None，如果使用了该值（一般为一个字符串），相当于为该receiver自定义个唯一名称（不允许重复），存储时将会使用dispatch_uid代替id(sender) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def connect(self, receiver, sender=None, weak=True, dispatch_uid=None): if dispatch_uid: lookup_key = (dispatch_uid, _make_id(sender)) # 如果设置了dispatch_uid则使用其期待id值作为唯一标识 else: lookup_key = (_make_id(receiver), _make_id(sender)) if weak: # 如果使用弱引用 ref = weakref.ref receiver_object = receiver # Check for bound methods if hasattr(receiver, \u0026#39;__self__\u0026#39;) and hasattr(receiver, \u0026#39;__func__\u0026#39;): # 如果该receiver是对象方法，则receiver_object为包含该receiver的对象 ref = weakref.WeakMethod receiver_object = receiver.__self__ receiver = ref(receiver) # 获取该receiver的弱引用 weakref.finalize(receiver_object, self._remove_receiver) # receiver_object垃圾回收时调用self._remove_receiver将self._dead_receivers置为True # 在后面的send或send_robust中对self.receivers加锁后清理 with self.lock: self._clear_dead_receivers() if not any(r_key == lookup_key for r_key, _ in self.receivers): # 检查是否有重复 self.receivers.append((lookup_key, receiver)) self.sender_receivers_cache.clear() # 每次connect或disconnect后都要清除缓存 # 该缓存会在send时构建 ​\n2.disconnect：从对应Signal对象的receivers列表中删除对应记录（一般用于手动删除在connect时使用weak=False的情况，即该条记录存的是receiver的强引用，若不手动删除该条记录会导致“内存泄漏”，与gc的引用计数有关）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def disconnect(self, receiver=None, sender=None, dispatch_uid=None): \u0026#34;\u0026#34;\u0026#34; 将signal中的receiver与sender“断开连接” 该函数主要针对那些在connect时weak参数为False的情况，即signal的receivers列表 中存储的是rceiver的强引用 如果在connect时使用的弱引用(weak=True), 则不需要手动调用disconnect方法 receiver和sender的记录会被自动删除 \u0026#34;\u0026#34;\u0026#34; if dispatch_uid: lookup_key = (dispatch_uid, _make_id(sender)) # 如果提供了dispatch_uid则使用其替代 id(receiver) else: lookup_key = (_make_id(receiver), _make_id(sender)) disconnected = False with self.lock: self._clear_dead_receivers() # 先清除dead_receivers for index in range(len(self.receivers)): (r_key, _) = self.receivers[index] if r_key == lookup_key: # 根据lookup_key在self.receivers中查找 disconnected = True del self.receivers[index] # 删除self.receivers中的对应记录 break self.sender_receivers_cache.clear() # 变更后清除缓存 return disconnected ​\n3.has_listeners：检查某个sender是否有receiver\n1 2 def has_listeners(self, sender=None): return bool(self._live_receivers(sender)) ​\n4.send：给某个sender对应的所有receivers发送相应的信号，首先会检查这个sender是否有receivers。如果有，先调用_live_receivers获取当前sender对应的所有的receiver的强引用，然后依次调用每个receiver传入相关的参数。最后，返回[(receiver,response),]（这里的receiver是强引用即可直接调用的receiver函数，response是调用receiver函数返回的结果）\n参数解析：\nsender：发送信号的类 **named：传递给该sender对应的receivers的参数 1 2 3 4 5 6 7 8 def send(self, sender, **named): if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS: return [] return [ (receiver, receiver(signal=self, sender=sender, **named)) for receiver in self._live_receivers(sender) # _live_receivers返回的是该sender对应的所有的receivers的强引用 ] 注： 当调用某个receiver发生异常时程序会直接退出，可能导致其他剩下的receiver并没有被调用执行\n​\n5.send_robust：“健壮版”的send，当调用某个receiver发生异常时会将异常捕捉并存储起来，故该sender的所有的receiver都能被调用执行。该函数会返回[(receiver,response / err),]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def send_robust(self, sender, **named): # 相比send方法调用receiver方法异常时直接退出，send_robust会收集异常并返回 if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS: return [] # Call each receiver with whatever arguments it can accept. # Return a list of tuple pairs [(receiver, response), ... ]. responses = [] for receiver in self._live_receivers(sender): try: response = receiver(signal=self, sender=sender, **named) except Exception as err: responses.append((receiver, err)) # 如果调用receiver出现异常则捕获并返回相应的异常而不影响其他receiver的调用 else: responses.append((receiver, response)) return responses ​\n6._clean_dead_receivers：清除Signal.receivers中的dead receiver，该函数会在send或send_robust中对Signal.receivers加锁了的情况下调用\n1 2 3 4 5 6 7 8 9 10 def _clear_dead_receivers(self): # Note: caller is assumed to hold self.lock. # 清除dead_receivers if self._dead_receivers: self._dead_receivers = False # 还原_dead_receivers为False self.receivers = [ r for r in self.receivers if not(isinstance(r[1], weakref.ReferenceType) and r[1]() is None) # 弱引用，并且该弱引用对应的对象已消亡 ] ​\n注： 其实这里说的清除dead receiver，就是删除Signal.receivers中那些原函数/对象（即receiver函数或包含receievr函数的对象）已经被垃圾回收了的weakref，至于那些在connect时使用weak=False添加的强引用则需要手动调用disconnect进行手动清除，否则可能会导致内存泄露\n7._live_receivers：先通过self._dead_receivers检查是否有dead receivers如果有则先过滤一遍Signal.receivers，然后从Signal.receivers中找出该sender对应所有的receiver，并返回包含所有receiver强引用的列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def _live_receivers(self, sender): \u0026#34;\u0026#34;\u0026#34; Filter sequence of receivers to get resolved, live receivers. This checks for weak references and resolves them, then returning only live receivers. \u0026#34;\u0026#34;\u0026#34; receivers = None if self.use_caching and not self._dead_receivers: # 如果使用缓存并且self.receivers中无dead_receivers receivers = self.sender_receivers_cache.get(sender) # 直接从缓存中获取 # We could end up here with NO_RECEIVERS even if we do check this case in # .send() prior to calling _live_receivers() due to concurrent .send() call. # 其实我们在调用_live_receivers方法的send方法中已经检查过一次了 if receivers is NO_RECEIVERS: return [] if receivers is None: # 如果不使用缓存或者存在待清理的dead receivers with self.lock: self._clear_dead_receivers() # 先清理dead_receivers senderkey = _make_id(sender) receivers = [] for (receiverkey, r_senderkey), receiver in self.receivers: # 遍历self.receivers进行查找匹配 if r_senderkey == NONE_ID or r_senderkey == senderkey: # 如果senderkey为id(None)或匹配 receivers.append(receiver) # 将receiver(weakref)添加到receivers中 # 更新缓存 if self.use_caching: # 如果使用缓存 if not receivers: # 如果该sender没有receiver (receivers为空) self.sender_receivers_cache[sender] = NO_RECEIVERS # 将cache中该sender的receivers置为空 else: # 如果该sender存在对应的receiver # Note, we must cache the weakref versions. # 注意我们应该缓存弱引用 self.sender_receivers_cache[sender] = receivers # 将该sender及其所有的receivers缓存起来 non_weak_receivers = [] for receiver in receivers: # receivers要么为[] 要么为[receiver] if isinstance(receiver, weakref.ReferenceType): # Dereference the weak reference. # https://www.kite.com/python/docs/weakref.ReferenceType receiver = receiver() # 获取弱引用所指的实际对象，若已消亡则返回None，否则返回对象的强引用(“可直接调用”) if receiver is not None: # weakref所指的原对象尚未消亡 non_weak_receivers.append(receiver) # 添加实际可调用的receiver对象 else: non_weak_receivers.append(receiver) # 不是弱引用则直接添加 return non_weak_receivers # 可调用对象receiver的列表 8._remove_receivers：将Signal._dead_receivers置为True，在后面调用send或send_robust方法时会先检查_dead_receivers，如果为True则先调用_clean_dead_receivers进行清理\n1 2 3 4 5 6 7 8 9 10 11 12 def _remove_receiver(self, receiver=None): # Mark that the self.receivers list has dead weakrefs. If so, we will # clean those up in connect, disconnect and _live_receivers while # holding self.lock. Note that doing the cleanup here isn\u0026#39;t a good # idea, _remove_receiver() will be called as side effect of garbage # collection, and so the call can happen while we are already holding # self.lock. # 标记self.receivers中有dead weakrefs(weakref所指对象已消亡).如果存在dead receiver # 程序会在调用connect, disconnect和_live_receivers时在加锁的情况下清除dead weakrefs # 注意在这里执行具体的清除操作并不是一个好主意，在垃圾回收时_remove_receiver()会被 # 自动触发，而我们可能在其他操作中对receivers加了锁，此时清理receivers将会导致冲突 self._dead_receivers = True 注： 由于在connect方法中的设置了weakref.finalize(receiver_object, self._remove_receiver)，在receiver_object垃圾回收时会自动触发_remove_receiver方法。如果将清除过滤Signal.receivers的过程放在这个函数中，而其它地方可能正在在加锁的情况下使用receivers则会导致冲突。故_remove_receivers只将Signal._dead_receivers置为True，从而把清理dead receiver的过程延迟到了connect、disconnect、send、send_robust中加锁进行\n3. 大概流程 通过Signal.connect向Signal.receivers中注册对应的((receiver_id, sender_id), receiver_weakref)记录，然后sender会在恰当的时候调用恰当的Signal并使用Signal.send发送恰当的信号给对应的所有receiver。这就是信号的大致传递过程\n4. 很奇怪的一点 程序里面有个奇怪的None，在connect时不指定sender则sender，默认sender就会是None，而在sender中调用Siganl.send方法该方法又会调用Signal._live_receivers方法，在Signal._live_receivers中会寻找该sender对应的receiver，而匹配条件居然是if r_senderkey == NONE_ID or r_senderkey == senderkey，sender为None的receivers也会被匹配？有点不太理解这里的做法\n5. 多说一句 异步问题，当一个sender注册的receiver过多时，调用send方法时可能会非常占用时间造成阻塞，观察者模式好像都有这个问题，可以使用异步改善？（在网上看到的，具体如何改善我还没搞清楚，等弄明白了再补上……）\n源码简析 源码：\nGithub Django Docs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 import threading import weakref from django.utils.inspect import func_accepts_kwargs # 返回对象的id,在connect存储记录和send查询记录时会用到 # 注意：sender和receiver都必须是可哈希的 def _make_id(target): if hasattr(target, \u0026#39;__func__\u0026#39;): # 如果是对象方法 return (id(target.__self__), id(target.__func__)) return id(target) # django.utils.inspect.func_accepts_kwargs # 检查传入的函数是否接受**kwargs参数 def func_accepts_kwargs(func): return any( p for p in inspect.signature(func).parameters.values() if p.kind == p.VAR_KEYWORD ) NONE_ID = _make_id(None) # A marker for caching NO_RECEIVERS = object() class Signal: \u0026#34;\u0026#34;\u0026#34; 所有signal的基类 Base class for all signals Internal attributes: receivers { receiverkey (id) : weakref(receiver) } \u0026#34;\u0026#34;\u0026#34; def __init__(self, providing_args=None, use_caching=False): \u0026#34;\u0026#34;\u0026#34; 创建新的signal providing_args: 在调用send()方法时可以传入这个signal的参数列表 \u0026#34;\u0026#34;\u0026#34; self.receivers = [] # ((receiver_id,sender_id),receiver_weakref)或者是((dispatch_id,sender_id),receiverweak_ref) # 具体是强引用还是weakref取决于connect时的weak参数是True还是False # 默认weak为True使用弱引用，若为False则删除该条记录时需要手动disconnect if providing_args is None: providing_args = [] self.providing_args = set(providing_args) self.lock = threading.Lock() # 加锁保证操作数据时线程安全 self.use_caching = use_caching # 是否使用缓存 # 为了便利即使不使用缓存我们也会创建空的缓存 # 关于缓存需要注意的一点是：如果use_caching为True，对于每一个sender # 我们会在sender_receiver_cache中缓存其所有的receiver。 # 该缓存在调用.connect()或者.disconnect()时会被清除，而在调用send时会被填充 self.sender_receivers_cache = weakref.WeakKeyDictionary() if use_caching else {} self._dead_receivers = False # receivers属性列表中是否含有“失效”的receiver引用(已被垃圾回收) # 在_clear_dead_receivers方法中会检查其值，如果为True则代表其中 # 有失效的receiver引用，则过滤清理一遍receivers属性列表 def connect(self, receiver, sender=None, weak=True, dispatch_uid=None): \u0026#34;\u0026#34;\u0026#34; # 通过signal将receiver连接到sender Arguments: receiver A function or an instance method which is to receive signals. Receivers must be hashable objects. If weak is True, then receiver must be weak referenceable. Receivers must be able to accept keyword arguments. If a receiver is connected with a dispatch_uid argument, it will not be added if another receiver was already connected with that dispatch_uid. sender The sender to which the receiver should respond. Must either be a Python object, or None to receive events from any sender. weak Whether to use weak references to the receiver. By default, the module will attempt to use weak references to the receiver objects. If this parameter is false, then strong references will be used. dispatch_uid An identifier used to uniquely identify a particular instance of a receiver. This will usually be a string, though it may be anything hashable. \u0026#34;\u0026#34;\u0026#34; from django.conf import settings # If DEBUG is on, check that we got a good receiver # 如果在DEBUG模式下，则检查该receiver是否满足要求 if settings.configured and settings.DEBUG: assert callable(receiver), \u0026#34;Signal receivers must be callable.\u0026#34; # Check for **kwargs if not func_accepts_kwargs(receiver): raise ValueError(\u0026#34;Signal receivers must accept keyword arguments (**kwargs).\u0026#34;) if dispatch_uid: lookup_key = (dispatch_uid, _make_id(sender)) # 如果设置了dispatch_uid作为某receiver的标识 else: lookup_key = (_make_id(receiver), _make_id(sender)) # 没有dispatch_uid则使用receiver的id if weak: # 如果使用weak则存储该receiver的弱引用，否则就直接存储强引用(强引用最终需要手动disconnect) ref = weakref.ref receiver_object = receiver # 强引用 # Check for bound methods if hasattr(receiver, \u0026#39;__self__\u0026#39;) and hasattr(receiver, \u0026#39;__func__\u0026#39;): # 检查是否是对象方法 # https://docs.python.org/zh-cn/3/library/weakref.html#weakref.WeakMethod ref = weakref.WeakMethod receiver_object = receiver.__self__ # 包含该对象方法的对象 # 使用弱引用替代强引用 receiver = ref(receiver) # 普通函数方法则直接取其弱引用 # 当receiver方法、或包含该方法对象消亡时从signal的receivers列表中清除该条记录 weakref.finalize(receiver_object, self._remove_receiver) # https://docs.python.org/zh-cn/3/library/weakref.html#weakref.finalize # 当receiver对象垃圾回收时调用_remove_receiver置self._dead_receivers = True with self.lock: self._clear_dead_receivers() # 清除、过滤dead_receivers if not any(r_key == lookup_key for r_key, _ in self.receivers): # 查重 self.receivers.append((lookup_key, receiver)) # 添加((receiver_id,sender_id),receiver_weakref) self.sender_receivers_cache.clear() # 变更后清除缓存 def disconnect(self, receiver=None, sender=None, dispatch_uid=None): \u0026#34;\u0026#34;\u0026#34; 将signal中的receiver与sender“断开连接” 该函数主要针对那些在connect时weak参数为False的情况，即signal的receivers列表 中存储的是rceiver的强引用 如果在connect时使用的弱引用(weak=True), 则不需要手动调用disconnect方法 receiver和sender的记录会被自动删除 Arguments: receiver The registered receiver to disconnect. May be none if dispatch_uid is specified. sender The registered sender to disconnect dispatch_uid the unique identifier of the receiver to disconnect \u0026#34;\u0026#34;\u0026#34; if dispatch_uid: lookup_key = (dispatch_uid, _make_id(sender)) # 如果提供了dispatch_uid则使用其替代 id(receiver) else: lookup_key = (_make_id(receiver), _make_id(sender)) disconnected = False with self.lock: self._clear_dead_receivers() # 先清除dead_receivers for index in range(len(self.receivers)): (r_key, _) = self.receivers[index] if r_key == lookup_key: # 根据lookup_key在self.receivers中查找 disconnected = True del self.receivers[index] # 删除self.receivers中的对应记录 break self.sender_receivers_cache.clear() # 变更后清除缓存 return disconnected def has_listeners(self, sender=None): # 通过调用_live_receivers方法看sender的recivers是否为空 return bool(self._live_receivers(sender)) def send(self, sender, **named): \u0026#34;\u0026#34;\u0026#34; Send signal from sender to all connected receivers. 从sender中发送信号给所有连接到该sender的receiver If any receiver raises an error, the error propagates back through send, terminating the dispatch loop. So it\u0026#39;s possible that all receivers won\u0026#39;t be called if an error is raised. Arguments: sender The sender of the signal. Either a specific object or None. named Named arguments which will be passed to receivers. Return a list of tuple pairs [(receiver, response), ... ]. \u0026#34;\u0026#34;\u0026#34; if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS: # 如果该signal得receivers为空或者该sender对应的receivers缓存为空 return [] return [ (receiver, receiver(signal=self, sender=sender, **named)) # 这里的receiver就是具体的receiver函数 for receiver in self._live_receivers(sender) # _live_receiver返回的是receiver的可调用对象(就是具体的receiver函数，强引用)的列表 ] # 返回[(receiver函数,调用receiver函数的结果)]如果调用某个receiver时发生异常程序会直接退出 # 导致其他的剩下的receiver并未被执行 def send_robust(self, sender, **named): \u0026#34;\u0026#34;\u0026#34; Send signal from sender to all connected receivers catching errors. Arguments: sender The sender of the signal. Can be any Python object (normally one registered with a connect if you actually want something to occur). named Named arguments which will be passed to receivers. These arguments must be a subset of the argument names defined in providing_args. Return a list of tuple pairs [(receiver, response), ... ]. If any receiver raises an error (specifically any subclass of Exception), return the error instance as the result for that receiver. 相比send方法调用receiver方法异常时直接退出，send_robust会收集异常并返回 \u0026#34;\u0026#34;\u0026#34; if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS: return [] # Call each receiver with whatever arguments it can accept. # Return a list of tuple pairs [(receiver, response), ... ]. responses = [] for receiver in self._live_receivers(sender): try: response = receiver(signal=self, sender=sender, **named) except Exception as err: responses.append((receiver, err)) # 如果调用receiver出现异常则捕获并返回相应的异常而不影响其他receiver的调用 else: responses.append((receiver, response)) return responses def _clear_dead_receivers(self): # Note: caller is assumed to hold self.lock. # 清除dead_receivers if self._dead_receivers: self._dead_receivers = False self.receivers = [ r for r in self.receivers if not(isinstance(r[1], weakref.ReferenceType) and r[1]() is None) # 弱引用，并且该弱引用对应的对象已消亡 ] def _live_receivers(self, sender): \u0026#34;\u0026#34;\u0026#34; Filter sequence of receivers to get resolved, live receivers. This checks for weak references and resolves them, then returning only live receivers. \u0026#34;\u0026#34;\u0026#34; receivers = None if self.use_caching and not self._dead_receivers: # 如果使用缓存并且self.receivers中无dead_receivers receivers = self.sender_receivers_cache.get(sender) # 直接从缓存中获取 # We could end up here with NO_RECEIVERS even if we do check this case in # .send() prior to calling _live_receivers() due to concurrent .send() call. # 在调用_live_receivers方法的方法中已经检查过一次了 if receivers is NO_RECEIVERS: return [] if receivers is None: # 如果不使用缓存或者存在待清理的dead receivers with self.lock: self._clear_dead_receivers() # 先清理dead_receivers senderkey = _make_id(sender) receivers = [] for (receiverkey, r_senderkey), receiver in self.receivers: # 遍历self.receivers进行查找匹配 if r_senderkey == NONE_ID or r_senderkey == senderkey: # 如果senderkey为id(None)或匹配 receivers.append(receiver) # 将receiver(weakref)添加到receivers中 # 更新缓存 if self.use_caching: # 如果使用缓存 if not receivers: # 如果该sender没有receiver (receivers为空) self.sender_receivers_cache[sender] = NO_RECEIVERS # 将cache中该sender的receivers置为空 else: # 如果该sender存在对应的receiver # Note, we must cache the weakref versions. # 注意我们应该缓存弱引用 self.sender_receivers_cache[sender] = receivers # 将该sender及其所有的receivers缓存起来 non_weak_receivers = [] for receiver in receivers: # receivers要么为[] 要么为[receiver] if isinstance(receiver, weakref.ReferenceType): # Dereference the weak reference. # https://www.kite.com/python/docs/weakref.ReferenceType receiver = receiver() # 获取弱引用所指的实际对象，若已消亡则返回None，否则返回对象的强引用(“可直接调用”) if receiver is not None: # ref所指的原对象尚未消亡 non_weak_receivers.append(receiver) # 添加实际可调用的对象 else: non_weak_receivers.append(receiver) # 不是弱引用则直接添加 return non_weak_receivers # 可调用对象receiver的列表 def _remove_receiver(self, receiver=None): # Mark that the self.receivers list has dead weakrefs. If so, we will # clean those up in connect, disconnect and _live_receivers while # holding self.lock. Note that doing the cleanup here isn\u0026#39;t a good # idea, _remove_receiver() will be called as side effect of garbage # collection, and so the call can happen while we are already holding # self.lock. # 标记self.receivers中有dead weakrefs(weakref所指对象已消亡).如果存在dead receiver # 程序会在调用connect, disconnect和_live_receivers时在加锁的情况下清除dead weakrefs # 注意在这里执行具体的清除操作并不是一个好主意，在垃圾回收时_remove_receiver()会被 # 自动触发，而我们可能在其他操作中对receivers加了锁，此时清理receivers将会导致冲突 self._dead_receivers = True def receiver(signal, **kwargs): \u0026#34;\u0026#34;\u0026#34; A decorator for connecting receivers to signals. Used by passing in the signal (or list of signals) and keyword arguments to connect:: 用来将receivers连接到对应signal的装饰器. 使用时传入signal(或者是装有signal的列表) 以及相关的关键字参数 @receiver(post_save, sender=MyModel) def signal_receiver(sender, **kwargs): ... @receiver([post_save, post_delete], sender=MyModel) def signals_receiver(sender, **kwargs): ... \u0026#34;\u0026#34;\u0026#34; def _decorator(func): if isinstance(signal, (list, tuple)): # 传入的是signal列表 for s in signal: s.connect(func, **kwargs) # 调用connect方法，sender的信息包含在kwargs中了 else: signal.connect(func, **kwargs) return func return _decorator 除此之外，django已经为我们预置了一些信号:\npre_init、post_init、pre_save、post_save、pre_delete、post_delete、m2m_change……(详细用法见官方文档)\ndjango在django/db/models/signals.py中定义了与数据库Model相关的信号对象:\npre_init \u0026amp; post_init pre_save \u0026amp; post_save pre_delete \u0026amp; post_delete m2m_change class_prepared pre_migrate \u0026amp; post_migrate 在django/core/signals.py中定义了与request和setting相关的信号对象:\nrequest_started \u0026amp; request_finished got_request_exception setting_changed django为我们预置这些信号对象，并且在适当的时候调用适当的信号对象发送适当的“信号”。比如在django/db/models/base.py中，在Model类的__init__方法开始位置调用pre_init.send()在__init__的结束位置调用post_init.send()，而我们的model又都是继承自该Model。\ndjango为我们预置好了一些信号，并且在做相应操作时会发送对应的信号，所以我们需要做的就是在需要用到时，定义对应的receiver去接收对应的信号📶即可。当然我们也可以直接实例化或继承Signal类来定义我们自己的信号。具体的使用可以参见这篇博客\n一些可能有用的链接 Python 弱引用 Python 垃圾回收 python gc模块接口文档 简书 Python垃圾回收机制 知乎 Python垃圾回收机制 ","date":"2021-06-10T00:00:00Z","image":"https://images.unsplash.com/photo-1494129935429-873eafa78178?crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;fm=jpg\u0026amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDF8fHNpZ25hbHN8ZW58MHx8fA\u0026amp;ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;w=2000","permalink":"https://heaciy.com/p/django-signal-principle-analysis/","title":"Django Signal简析"},{"content":" 苹果木桌子——或一桩前所未见的灵异事件1 作者：[美] 赫尔曼·麦尔维尔 本文出自《苹果木桌子及其他简记》，读完之后我觉得整本书就数这篇最有趣了（剩下的都很催眠……😴）\n我第一眼看见那张陈旧发暗、布满灰尘的桌子时，它摆放在一间漏斗状老阁楼最偏僻的角落里，表面搁着大大小小碎裂而结满污垢的紫色旧玻璃瓶，以及一部样子瘆人、脱胶落线的古老四开本图书。这张破烂的小桌子似乎萦绕着巫术，没准儿是培根修士2的私人器物。它有两个不乏魅力、魔力的明显特征——圆盘和三叉支架——桌板的弧度完美，由一根扭来扭去的柱子撑持，并在离底部大约一英尺的位置岔开，形成三条弯弯曲曲的桌脚，末端是三只马蹄足。确确实实，这张古旧的小桌子看起来相当邪恶。\n为使读者更好地了解它，不妨也介绍一下它所处的环境。非常古老的阁楼，非常古老的房子，位于全美国最古老市镇的古老街区之中。该阁楼已闲置多年。大伙认为里面闹鬼——不得不承认，谣言虽很荒谬（依我之见），但本人购买宅子时不曾大加驳斥，因为颇有可能，是它帮助我在财力允许的范围内，更顺利地拿下了这份房产。\n所以，定居此间的五年时光里，尽管并不害怕高处鼎鼎大名的妖魔鬼怪，我却从未走进过阁楼。没有特别的理由非上去不可。屋顶铺得严严实实，滴水不漏。为宅子承保的公司也从不探访这间阁楼，既然如此，房主本人又何必费心劳神？它根本派不上用场，下面的房子完全够住。再说楼梯门的钥匙也已经丢失。锁头粗大且老旧。想撬开它，必须请来一名铁匠，我觉得这是自找麻烦。另外，我虽小心翼翼不让两个女儿接触以上谣言，可她们道听途说，屡有耳闻，因此挺高兴见到闹鬼场所大门紧锁。如果不是一次偶然的发现，它或许还要封闭更长时间。在我家古老、幽深、依斜坡而建的花园某处，本人找到一枚奇特的大钥匙，样式古旧，铁锈斑驳，我立即推断它应该能打开阁楼的门锁——经过试验，猜想获得证实。眼下，拥有一枚蕴含着许多未知的钥匙，我很快产生了开锁并好好探索一番的渴望。当然啰，这只是为了满足好奇的天性，而不是为了去搜求任何具体的好处。\n瞧啊，我转动生锈的旧钥匙，然后独自往上走，步入闹鬼的阁楼。\n它的面积跟宅子地基的面积相同。阁楼的天花板即屋顶，可以看见铺着页岩瓦的房椽与梁架。屋顶中央隆起，让雨水从四个方向下泄，阁楼因此很像一位将军的帐篷——不过当中摆了一座木头柱子的迷宫，起支撑作用，无数蜘蛛网悬垂此间，在夏天的正午旳旳闪烁，宛如巴格达的轻丝薄纱。到处可见奇形怪状的昆虫，在横梁和地板上或飞或窜或爬。\n屋顶最高处下方有一条粗糙、狭窄、朽烂的梯子，状若哥特式教堂的讲坛台阶，通往一个讲坛式的平台，而它又搭了一条更狭窄的梯子——类似于雅各的梯子3——通往更高处的巍然天窗。这个天窗约莫两平方英尺见方，乃是一个整体，给一小块玻璃板配了一副巨大的框子，嵌套如舷窗。亮光从这个唯一的入口照进阁楼，穿过密集的重重蛛网。的确，整座楼梯，以及平台和梯子统统由蜘蛛网点缀、覆盖、笼罩，而这些层层堆积的阴郁物质同样垂挂于幽暗的拱形屋顶，犹如柏树林里生长的卡罗莱纳苔藓。蜘蛛网好比空中坟墓，众多不同种群的昆虫木乃伊在其间悠悠摆荡。\n登上平台，我停下来调整呼吸，看到一个奇异的景象。太阳悬在半空。日光穿过小天窗，将一条清晰的彩虹隧道斜斜扎入阁楼的黑暗之中。亿万浮尘在此泛涌。成百上千的飞虫聚成金灿灿的一群，紧贴着天窗，铙钹般嗡嗡作响。\n我想让光线更为充足，打算拿掉天窗的挡板。可是找不到插销或者搭扣。我眼睛瞪了半天，才看见一个小小的挂锁，像海底的牡蛎一样深深嵌入杂草般互相绞缠的大团蛛网、蛹壳和虫卵之间。我将杂物拂开，发现它锁死了，于是试着用一片弯曲的指甲将它拧开，这时候，几十只昏昏沉沉的小蚂蚁和苍蝇钻出锁孔，感受到窗玻璃上阳光的热度，开始在我周围乱爬。其他虫子也来凑热闹。很快我便不胜其扰。它们似乎被我毁人清静的举动激怒了，成群结队从下方扑来，难以计数，马蜂似的不断在我头上叮咬。最终，我一发狠，猛然将挡板推开。啊！形势大变。仿佛离开了阴暗的墓穴，摆脱了蛆虫的陪伴，你将欣喜若狂地升向鲜活的绿意和永生的辉煌，与之相仿，在蛛网密布的旧阁楼里，我硬是把脑袋挤入芳香怡人的空气之中，望见小花园里栽植的雄伟巨木正凭借其繁茂的树冠冲我致意，它们的枝叶高高伸展于屋顶的瓦片上方。\n窗外的景致让人精神一振，我随即转过身来，仔细察看阁楼，它已十分明亮，非比往常。尽是些大而无当的过时家具。有一张旧写字桌，老鼠在它的文档格上跳来跳去，隐秘的吱吱声从它暗处的抽屉中传出，恍如从林间花栗鼠的树洞里传出一般。还有一张散架的旧椅子，布满怪诞的花纹，似乎很适合魔法师的集会。又有一只没盖子的铁皮箱，锈迹斑驳，装满发霉的旧文件，其中一份，底端能看见一道褪色的红色墨迹，颇像是浮士德博士与梅菲斯特签订的灵魂契约4。最后，在光线最昏暗的角落里，在一大堆难以描述的破旧垃圾当中，在坏掉的望远镜和凹陷破损的星象仪之间，支着一张年深日久的小桌子。马蹄足，跟撒旦的脚形一样，并因蜘蛛网的遮挡而若隐若现。灰尘极厚，落在陈旧的小药瓶和长颈瓶上几乎黏结成块，它们往日曾盛满液体。而桌子中央霉烂的旧书——科顿·马瑟5的《辉煌业绩》6——看上去非常诡异。\n我把桌子和书拿到楼下，分别修好，补好。这张悲惨的遁世小木桌被放逐得太久，远离热情的友邻，所以我决定，要用温暖的锅碗瓢盆、温暖的壁炉和温暖的心包围它，让它如沐春风。我有点儿想知道，上述一切温暖的关照究竟能孕育出什么东西来。\n我很高兴看到这张桌子的材质并不是普通的红木，而是苹果木，年月使之发黑发暗，几乎变为胡桃木的色泽。它加入家具的行列之后，效果令人惊异，竟相当契合我们的香柏木客厅——这个房间有此称呼，是因为它本属于老派风格，镶着木质的护壁板。桌子的台面，或者说圆案，格外精巧，能够轻易从平放状态折叠为垂直状态，所以不使用时，可以将其靠墙搁在角落里。我觉得，把它当作我自己、我妻子以及两个女儿的小茶桌和小餐桌，应该很不错。这对于一张安静的桌子也颇为适宜。另外，想到它还可以变成一张极好的读书桌，本人甚感愉快。\n我妻子对以上设想却没什么兴趣。她讨厌这个主意，不欢迎苹果木桌子像一个殊为落伍、寒酸的陌生人那样，闯入光鲜华丽的家具群体之中。然而，桌子接下来去了一趟木匠铺子，回家后焕然一新，锃亮夺目有如一枚畿尼7，于是我妻子比任何人都更积极地接纳它。这张桌子在香柏木客厅占据了备享尊荣的一席之地。\n但是，我的女儿朱莉娅却始终未能摆脱第一次撞见苹果木桌子时产生的怪异情绪。很不幸，那天正赶上我把它从阁楼搬下来。当时我两手抓着桌子的圆案，将它举起，因此一只结满蛛网的马蹄足直戳于前，而在楼梯拐弯处，这个奇怪的部件突然碰到了正往上走的姑娘。于是乎，她一转身，没看见任何人——我完全被桌子挡住了——只看见马蹄足鬼魅般显现，好似撒旦的一条腿，她尖声大叫，要不是我立即开口说话，真不知接下去情况会变得多严重。\n我可怜的女儿，这件事让她精神紧张了好久，迟迟无法复原。姑娘很迷信，认为我走进了不应涉足的封闭场所，故而十分悲伤。在她意识里，这张三足分岔的桌子与臭名昭著的鬼怪息息相关。她恳求我别再倒腾什么苹果木桌子。她的姐妹也支持她。我的两个女儿天生就同气连枝。而我讲究实际的妻子如今却宣布她喜欢那张桌子。她一向意志坚定，精力充沛。对她而言，朱莉娅和安娜的成见简直荒唐透顶。她觉得，作为母亲她有义务将这股柔弱之风扫荡干净。渐渐地，吃早餐以及喝午茶时，我们让两个女儿一起坐到桌子旁。持续的接触不乏成效。没多久，她们已能安坐如常，但朱莉娅仍尽量不去看桌子的马蹄足，而我若发笑，她必定投来严肃的目光，仿佛在说，啊，爸爸，换成你大概也会这么做。姑娘预言，迟早要发生跟这桌子有关的怪事。结果我反倒笑得更欢，妻子则恼怒地责备女儿。\n同时，我把它当成一张晚间的读书桌，并因此深感满意。在一场女士们张罗的大集上，我给自己买了一只漂亮的读书靠垫，可以将胳膊肘搁在上面，再用手遮挡灯光，消磨漫长的时间——屋内悄无人声，唯有那本从阁楼里拿下来的古怪旧书与我相伴。\n原本诸事皆顺，直到发生了以下变故——请记住，这个小插曲跟本文的其他叙述一样，时间上远远早于“福克斯姑娘”8活跃的年代。\n那是十二月一个星期六的夜晚。又小又旧的香柏木客厅里，我坐在又小又旧的苹果木桌子前，像往常一样独自一人。我不止一次试图起身离开，上床睡觉，却怎么也办不到。当时我兴许是着魔了。不知为何，反正我运用理智的能力大不如前。我颇为紧张。实际上，虽然科顿·马瑟在以往的夜读时分让我愉快，这个晚上却让我害怕。那些故事曾千百次使我发笑。奇闻怪谈，我原本认为还挺有趣的。可是眼下，情形大大不同。它们开始显露真实的一面。此刻，我第一次觉得《辉煌业绩》的作者绝无拉德克利芙夫人9的浪漫情调，是一个实事求是、勤奋努力、热情真挚的正直之士，也是一位满腹经纶的大学者，以及一名优秀的基督徒和正统的牧师。这样一个人又怎么可能欺世盗名？他行文的风格朴实无华，直指真理，毫无避讳地向读者详细讲解了新英格兰的巫术，每一件重要的事情均有可敬的市民作证，而其中不少最令人惊奇的例子是他本人亲眼所见。科顿·马瑟固然证实了他看到的东西。但我自问，巫术是不是确有可能。我随即想到了约翰逊博士10，这位踏踏实实的字典编纂者相信幽灵存在，其他众多杰出卓异的名流亦然。顺从于那股使人着魔的力量，我一直阅读到三更半夜。最终，我发现几乎听不到一丁点儿声音，真希望别那么安静。\n我旁边放着一杯微热的潘趣酒。每逢星期六晚上，我喜欢不温不火地来些这样的饮料。然而，本人的好太太长年反对我这嗜好，断言除非我改过自新，否则一定死得像个惨兮兮的醉鬼。有必要说明一下，事实上，在那一个个紧跟着周六之夜到来的周日早晨，我不得不极其小心谨慎，如遇突发状况，绝不能流露哪怕最轻微的焦躁情绪，否则必然留下口实，被说成是夜间纵酒的恶果。至于我妻子，她从未品尝过潘趣酒，却很喜欢没事就发发小牢骚。\n在前文提到的那个晚上，我一反平时小酌怡情的习惯，调了杯烈酒。我渴求刺激。我需要一份鼓舞以抵抗科顿·马瑟——阴郁的、可怕的、鬼气森森的科顿·马瑟。我越来越紧张。仅仅是因为着了魔，我才没有从客厅逃走。烛光昏暗，烛泪长流，烛花成堆。可是我不敢用烛剪清理它们。那么做动静过大。而先前我还指望能有点儿声响。我读啊读啊。我头发的触觉变得异常敏锐。我的眼睛干涩、疼痛。我很清楚这一点。我知道我正使它们受损。我知道第二天我会因为用眼过度而懊悔。但我还是继续往下读。我已不由自主。我是鬼上身了。\n忽然间——听！\n我的头发根根倒竖。\n从什么东西的内部传出一阵轻微的敲打声或刮擦声——奇奇怪怪、莫名其妙的响动，混合着一些细小的叩击声或嘀嗒声。\n嘀嗒！嘀嗒！\n没错，是一种微弱的嘀嗒声。\n我抬头看了看墙角伫立的斯特拉斯堡大座钟。声音不是从那儿发出来的。座钟已经停摆。\n嘀嗒！嘀嗒！\n是不是我的怀表在响？\n按照妻子往常的做法，她去睡觉时会把我的怀表拿到卧室，挂在钉子上。\n我凝神倾听。\n嘀嗒！嘀嗒！\n是护壁板在格格响？\n我颤悠悠地沿墙走了一圈，将耳朵贴到护壁板上。\n不，这声音并非来自护壁板。\n嘀嗒！嘀嗒！\n我在发抖。我为自己的胆怯而害臊。\n嘀嗒！嘀嗒！\n声音的准确度和强度均在增加。我丢下护壁板走回来。这声音似乎要来找我。\n我四下张望，什么也没看到，只瞧见小苹果木桌子的一只马蹄足。\n上帝保佑，我喃喃自语，突然感觉一阵恶心。肯定很晚了。妻子是不是在叫我？对啊，对啊。我得睡觉去。门窗大概全锁上了。没必要再巡查一番。\n着魔的状态已经解除，恐惧却有增无减。我双手颤抖，将科顿·马瑟丢到一边，拿上烛台，快步走到卧室，怀着一份撤退的奇异感觉，好像一条狗落荒而逃。我急于进入卧室，半路上撞到了一张椅子。\n“别那么吵吵闹闹，亲爱的，”妻子躺在床上说，“恐怕你喝了太多的潘趣酒。你这可悲的嗜好一天比一天严重。啊，我从没见过你晚上这样跌跌撞撞地走进房间。”\n“太太，太太，”我嗓音嘶哑，低声道，“有什么东西——嘀嘀嗒嗒的东西——在香柏木客厅里一个劲儿响。”\n“可怜的老头子——快神志不清了——我就知道要搞成这个样子。上床。来睡个好觉。”\n“太太，太太！”\n“上来吧，上床。我原谅你了。明天我不会跟你提这茬儿。不过，亲爱的，你不许再喝潘趣酒了。这是为你好。”\n“别逗我发火，”此刻我终于回过魂来，喊道，“我可出门去了！”\n“不要去！不要这个鬼样子出去。上床来，亲爱的，我不再多说一个字。”\n第二天早上，妻子醒来后压根儿不提昨晚的事情，而我觉得非常尴尬，尤其是自己一度如此恐慌，所以我也不吭气。自然，妻子把我的怪异举动归结为精神错乱，不是幽灵作祟，而是潘趣酒添堵。至于我自己，躺在床上望着窗外的太阳时，我开始认为深夜读科顿·马瑟没什么益处，那会给神经造成不良影响，并引发幻觉。我决定把科顿·马瑟束之高阁。这样一来，我就不必担忧自己再听到任何嘀嗒声。实际上，我已转而相信屋子里的嘀嗒声不过是某种在我耳内回响的嗡嗡声。\n妻子一直习惯比我起得更早。我仔仔细细、舒心惬意地洗漱完毕。意识到大多数精神失常往往有身体状况上的根源，我用洁面刷使自己看起来活力四射，又用新英格兰的朗姆酒洗头，以前有人把这个偏方推荐给我，说是可以治耳鸣。我穿上晨袍，认真系好围巾，精心修剪过指甲，洋洋自得地走到楼下，去香柏木小客厅吃早饭。\n我很惊讶看到妻子正跪在苹果木小桌近旁边的地毯上找什么东西，早餐置于桌面无人理睬，而我的两个女儿，朱莉娅和安娜，正在房间里心烦意乱地跑来跑去。\n“哦，爸爸，爸爸！”朱莉娅快步向我走来，喊道，“我就知道会这样。桌子，那张桌子！”\n“鬼魂！鬼魂！”安娜站得远远的，指着桌子大叫。\n“安静！”妻子喝道，“你们一个劲儿吵，我怎么听得清？不要动。到这边来，老头子，这是你说的嘀嗒声吗？你干吗不过来？是它吗？这儿，跪下来听听。嘀嗒，嘀嗒，嘀嗒！——现在你听到了吧？”\n“来了，来了。”我喊道，而两个女儿却恳求我们从那儿走开。\n嘀嗒，嘀嗒，嘀嗒！\n就在洁白如雪的桌布、令人愉快的大茶壶，以及热气腾腾的牛奶吐司下面，正传出不可理喻的嘀嗒声。\n“隔壁不是有炉子吗，朱莉娅？”我说，“咱们上那儿吃早饭去，亲爱的，”我朝妻子转过身来，“咱们走——留下这张桌子——让比迪把东西挪开。”\n言语间，本人泰然自若地走向房门，妻子却拦住我。\n“离开客厅之前，我一定要弄清楚这嘀嗒声是什么，”她斩钉截铁说道，“我们肯定能搞明白，毫无疑问。我不信有鬼，尤其是在早餐时间。比迪！比迪！来，把这些东西搬回厨房。”她将大茶壶递过去，然后扯掉桌布，让小桌子光秃秃地暴露在我们眼皮底下。\n“桌子，是这张桌子！”朱莉娅大喊。\n“胡诌八扯，”妻子道，“谁听说过嘀嗒作响的桌子？声音是地板传出来的。比迪！朱莉娅！安娜！把房间清空——移走桌子和其他所有的东西。平头锤在哪儿？”\n“天啊，妈妈，你不是要把地毯给掀开吧？”朱莉娅尖叫。\n“夫人，锤子。”比迪有点儿发颤，走上前说道。\n“快给我。”妻子喊道。可怜的比迪拿着锤子，离得她老远，仿佛女主人染上了瘟疫。\n“好了，老头子，你拽地毯那一边，我拽这一边。”她随即跪下来，于是我也照做不误。\n地毯移开了，耳朵直接贴在裸露的地板上，听不到一丝声响。\n“桌子——果然是那张桌子，”妻子大喊，“比迪，把它搬回来。”\n“哦，不，夫人，求求你，别叫我去，夫人。”比迪哭丧道。\n“蠢货！——老头子，你来搬。”\n“亲爱的，”我说，“桌子我们多的是，何必非要那一张？”\n“那张桌子在哪儿？”妻子喊道，完全无视我温和的反对。\n“在柴房，夫人。我把它有多远就撂多远，夫人。”比迪哭道。\n“是我去一趟柴房，还是你去？”妻子用一种可怕的、公事公办的口吻对我说。\n我立即冲出门外，找到那张苹果木小桌，它正大头朝下搁在一个料斗里。我急忙将它拎回来。妻子再度仔细检查了一番。嘀嗒，嘀嗒，嘀嗒！没错，是桌子在响。\n“夫人，请问，”比迪走进房间，“夫人，请问，能把薪水结给我吗？”\n“脱下你的帽子和披巾，”妻子说，“重新摆桌子。”\n“摆桌子，”我激动地大吼，“摆桌子，否则我叫警察来。”\n“天啊！天啊！”我的两个女儿同时大呼，“我们会变成些什么人？——鬼魂！鬼魂！”\n“你是摆桌子还是不摆？”我走向比迪，喊道。\n“我摆，我摆——遵命，夫人——遵命，老爷——我摆，我摆。鬼魂！——圣母玛利亚！”\n“老头子，”妻子说，“现在我确信，不论是什么东西在嘀嗒嘀嗒响，这声音或这桌子对我们并没有损害。但愿，那是因为我们全都善良虔诚。而且我打定主意，非搞清楚其中缘故不可，我有时间，有耐性，准能办到。只要还在这座宅子里生活一天，我就只用这张桌子吃早餐，所以，坐下来，东西都重新摆好了，让我们安安静静吃顿早饭。亲爱的，”她对朱莉娅和安娜说，“回你们的房间去，平静下来。别再跟孩子似的大呼小叫。”\n有时候，我妻子在家里说一不二。\n早餐期间，妻子徒劳地一次次打开话匣子，徒劳地说些轻松愉快的话题，想让其他人也像她一样快活有生气。朱莉娅和安娜的脑袋耷拉在她们的茶杯上方，仍旧倾听着嘀嗒声。必须承认，我也受到她们的传染。可是，有一阵子，什么也听不见。要么是嘀嗒声已经彻底消失，要么是它太过轻微，而街头的喧嚣不断增长，再加上白昼的混响，这与夜间和清晨的宁谧形成了强烈反差，因此将那道声音盖住。我们藏在心底的不安让妻子非常恼火，也让她毫无惧意的形象更为光辉。吃完早餐，她拿来我的怀表，放在桌子上，并以开玩笑的挑衅语调对所谓的鬼魂说：“来啊，继续嘀嗒响啊，看看谁嘀嗒得更大声！”\n那天我有事外出，却一直在思索那张神秘的桌子。难道科顿·马瑟所言不虚？世上真有鬼魂？而且会附在一张茶桌上？撒旦竟敢在一个清清白白的家庭里显露他的马蹄足？想到自己不顾女儿的严重警告，执意将恶魔的象征摆在那儿，我突然一阵颤抖。是的，三只马蹄足。但接近中午时，这种感觉开始消失。在街上与那么多大活人反复挨挤，令我不再胡思乱想。我记得，昨晚或今早我可没有这么勇敢地解放自己。我决心重新去赢回妻子的好感。\n为了表现得非常积极，喝过茶，玩过三局惠斯特牌11之后，而且此刻听不见嘀嗒声——这使我备感鼓舞——我点上烟斗，说接下来该睡觉了，再将椅子挪到壁炉前，脱掉拖鞋，把脚搁在壁炉的围栏上，气定神闲的样子就如同老德谟克利特12身处阿布底拉13的墓地中一般，那是一天深夜，城里顽皮的孩子们装妖作怪，企图吓唬意志坚定的哲学家。\n我还想到，面对此等情境，这位卓越的老先生以自己的举动为所有时代树立了榜样。他在那个阴森恐怖的时刻仍专注于研究学问，听见奇怪的声响，他没有从书页上移开目光，只淡淡说道：“孩子们，小调皮，回家去吧。这里不是耍闹的地方。你们会着凉的。”上述词句蕴含的哲理是：它们暗示了意料之中的结论，即我们对任何可能的灵异现象的任何可能的探查皆属荒谬。神志健全之人一看到这些事情，会本能地认定它们是装神弄鬼，丝毫不值得关注，尤其是此类现象出现在墓地时，而墓地又格外寂静冷清、死气沉沉。顺便提一句，老先生正是看中这些特质，才将阿布底拉的墓地当成了自己研究学问的场所。\n眼下我孤身一人，周围悄无声息。我放下烟斗，并不觉得此刻自己足够镇定，可以全然沉醉其间。我拿起一张报纸，借着炉旁小烛台放射的光芒，以一种紧张兮兮、匆忙潦草的方式开始阅读。至于苹果木桌子，我近来才发现它太矮，不适合做一张读书桌，那晚上我最好别用它干这个。但它离我不远，摆在屋子中央。\n尽管我努力读报，却不大成功。不知为什么，我似乎全神贯注于听，而根本没有在看。我竖着耳朵，专心致志。很快，寂静被打破了。\n嘀嗒，嘀嗒，嘀嗒！\n虽然并非第一次听到这个声音，不，应该说虽然我特意留下来等待这个声音，可是，当它出现时，似乎还是让我始料未及，好像隆隆炮声从窗外传来。\n嘀嗒！嘀嗒！嘀嗒！\n我坐着一动不动，竭力想控制——如果可能——自己最初的惊慌情绪。然后我离开座椅，颇为镇定地望着那张桌子，颇为镇定地向它走去，颇为镇定地举起它，又轻轻放下。我就这么举起放下，每次间隔那么一会儿，屏息谛听。同时，在内心深处，惊恐与哲学的较量仍未见分晓。\n嘀嗒！嘀嗒！嘀嗒！\n嘀嗒声以令人惊骇的清晰在夜间响起。\n我脉搏狂震，心脏剧烈跳动。若非德谟克利特在这一刻施以援手，我真不知道该怎么办才好。说来惭愧，我自言自语道，如果一个如此美妙的哲学范例不可以效法，那么它还有何益处？我决意直接模仿它，甚至模仿老圣人的言行和态度。\n我重新坐到椅子上阅读报纸，背对那张桌子，长久不动，仿佛埋首于研究。而嘀嗒声仍在持续，我极力以漠然、冷淡的嘲讽语气慢吞吞说道：“响吧，响吧，嘀嗒响吧，小家伙，今晚真够来劲的。”\n嘀嗒！嘀嗒！嘀嗒！\n此刻的嘀嗒声里似乎暗含着揶揄轻蔑。它好像十分欢悦，原因是本人刚才的表演收效甚微。然而，尽管遭到奚落，这份奚落却只会让我坚持下去。我拿定主意，绝不削弱言辞之锋利。\n“响吧，响吧，你越来越闹腾了，嘀嗒响吧，小家伙，真够搞笑的——该歇一歇啦。”\n话音方落，嘀嗒声便停止了。命令执行得如此精准，简直前所未见。就算天塌下来，我也要转过身去，面对那张桌子，如同面对一个能跟你有问有答的活物。这时候——我该不该相信自己的感官？——我看到什么东西在桌面上移动，或者扭动，或者蠕动。它像萤火虫一样发光。我下意识地攥紧了手中的拨火棍，但想到用拨火棍去打一只萤火虫非常荒唐，于是又把它放下。说不准我到底恍恍惚惚地坐了多久，看了多久，反正我假装云淡风轻而内心里波澜万丈。最终，我站起来，将外套从上往下扣好，突然勇猛地迈出大步，直奔那张桌子。结果呢，千真万确，我看到桌面上接近中央的位置有一个不规则的小孔，或者毋宁说类似于一个蛀蚀的小洞，发光的东西（不管它是什么）在里面极力要挣脱束缚（犹如蝴蝶破茧而出）。它动来动去的架势，显然是生物。我愣愣站着，思忖：这就是所谓的鬼魂？就是它？不，我一定是在做梦。我把目光移至壁炉的火焰上，随即又回到桌子上的苍白光芒。我看见的并不是幻象，而是真正的奇迹。震动不断加剧，此时，德谟克利特再一次使我振作精神。即便这闪烁感觉上是超自然现象，我仍努力以纯粹的科学眼光去观察它。如此一来，它又显得像是一类未知的发光小甲壳虫或小飞虫，另外，我认为，它还能发出某种声响。\n我仍在注视它，而且越来越冷静。它也仍在不停挣扎，闪闪发亮。有一阵子，它几乎就要逃出樊笼。我灵机一动，跑去拿了一只平底玻璃杯来，罩在这虫子上面，不让它飞走。\n我透过平底玻璃又看了好一会儿，随后转身离开，心安理得地回房睡觉。\n当时，我无论如何也无法理解这个现象。活生生的虫子从一张死气沉沉的桌子里钻出来？发光的虫子从一块天知道在阁楼上存放了多少年的老旧木料里钻出来？你听说过，或至少梦见过这样的事情吗？虫子是怎么进去的？没关系。我想到了德谟克利特，并决心保持冷静。反正，嘀嗒声的谜团解开了。那不过是虫子啃出一条生路时噬咬、掏挖、敲打的动静。嘀嗒声已经永远消失，令人满意。我要从中捞到些赞扬，不让这个机会轻易溜走。\n“太太，”第二天早上，我说，“你再也不必苦恼我们的桌子嘀嗒作响了。我把一切都解决了。”\n“真的吗，老头子。”她有点儿怀疑。\n“是的，太太，”我稍嫌自负地答道，“我给嘀嗒声来了一记巨石压顶。跟你打包票，那嘀嗒声往后不会来烦你了。”\n妻子请求我解释一番，可是白费功夫。我才不管她。此前我一度暴露自己的胆怯，为了扳回一城，如今我留下想象空间，让她好好猜一猜本人消灭嘀嗒声的英雄业绩。这是一个靠沉默来实施的诡计，既无恶意，也无损害，而且我认为，还相当有效。\n但我去吃早饭时，看到妻子又一次在桌子旁跪下来，我的两个女儿看上去比原先还要害怕十倍。\n“你干吗跟我吹牛皮？”妻子怒道，“你应该知道那很容易被戳破。瞧瞧这个裂缝。嘀嗒声也没停下来，反倒更响亮。”\n“不可能。”我大呼。可仔细一听，嘀嗒！嘀嗒！嘀嗒！确实嘀嗒声还在。\n我竭尽全力恢复了常态，询问虫子的情况。\n“虫子？”朱莉娅尖叫道，“天啊，爸爸！”\n“我希望，先生，你没把臭虫带进这座宅子。”妻子语气严肃。\n“那个虫子，虫子！”我喊道，“平底玻璃杯下面的虫子。”\n“平底玻璃杯下面的虫子！”姑娘们喊道，“不是我们的平底玻璃杯吧，爸爸？你没把虫子放进我们的平底玻璃杯里吧？哦，这到底——到底是什么意思？”\n“你们看到这个小孔，看到这条裂缝了吗？”我指着那地方说。\n“看到了，”妻子说，极为不满，“它怎么来的？你对桌子做了什么？”\n“你们看没看到这条裂缝？”我气呼呼地重复。\n“看到了，看到了。”朱莉娅说，“它真够吓人的。瞧着就像巫术弄成的。”\n“鬼魂！鬼魂！”安娜喊道。\n“安静！”妻子说，“请继续，先生，跟我们讲讲，这条裂缝有什么蹊跷。”\n“太太，女儿们，”我严肃道，“昨天晚上，我一个人坐在客厅，从这条裂缝或者小洞里，钻出一只美妙的……”\n说到此处，我不由自主停下来，陶醉于朱莉娅和安娜满脸的期待以及灼灼的目光。\n“一只什么？一只什么？”朱莉娅喊道。\n“一只虫子，朱莉娅。”\n“一只虫子？”妻子喊道，“一只虫子从桌板里钻出来？你对它做了什么？”\n“用一只平底玻璃杯罩住了它。”\n“比迪！比迪！”妻子走到门口喊道，“你打扫房间时，在桌子上看见过一只平底玻璃杯吗？”\n“当然看见了，夫人，里边还有一只讨厌的虫子。”\n“你怎么处理它的？”我问。\n“把虫子丢进了火里，老爷，然后把平底玻璃杯反复洗了好多遍，夫人。”\n“那只平底玻璃杯在哪儿？”安娜喊道，“希望你擦过，总之留下过记号。我绝不用那只杯子喝水。比迪，永远别把它拿到我跟前。一只虫子——虫子！啊，朱莉娅！啊，妈妈！我觉得它爬遍了我全身，眼下也正在爬！这邪乎的桌子！”\n“鬼魂！鬼魂！”朱莉娅喊道。\n“孩子们，”她俩的母亲说，眼神中透着威严，“回房间去，恢复一些理智了再出来。难道一只虫子，就可以把你们原本拥有的一丁点儿智识全吓没了？离开客厅。真让我吃惊。你们的幼稚举动使我很难过。”\n“现在，告诉我，”两个女儿一走，她立即对我说，“一五一十告诉我，从桌面的这条裂缝里当真钻出了一只虫子？”\n“太太，的确如此。”\n“你亲眼看见它钻出来？”\n“没错。”\n她俯向那条裂缝，认真观察。\n“你确定？”她抬头问道，依然弯着腰。\n“确定，我确定。”\n她沉默不语。我觉得，事物的神秘甚至也开始对她产生影响。是啊，我思忖，眼下我本该看到妻子浑身发抖，天知道会不会喊来一个老牧师给桌子驱魔，将鬼魂赶跑。\n“我打算这么干。”她突然说，表情相当兴奋。\n“什么，太太？”我极为迫切地问道，期待听到一个神奇的主意，“你要干什么？”\n“我要用以前听说过的一款大名鼎鼎的蟑螂粉，把这张桌子里里外外擦个遍。”\n“好家伙！那么说你不认为是鬼魂在作祟？”\n“鬼魂？”\n她加重的语气充满了轻蔑的怀疑之意，比之德谟克利特本人也不遑多让。\n“可是这嘀嗒声，这嘀嗒声呢？”我说。\n“我会把它烤出来的。”\n“唉，唉，太太，”我说，“你别走到另一个极端去啊。不管是抹蟑螂粉，还是搁到火上烤，都没办法救这张桌子。你不能否认，太太，它是一张古怪的桌子。”\n“那么我会它把擦干净，”她回答，“好好擦个通透。”妻子随即叫来比迪，要她给桌子打蜡，刷洗，让它焕然一新。做完了这一切，桌布重新铺好，我们坐下来吃早餐。不过两个女儿并未露面。朱莉娅和安娜当天没吃早餐。\n撤掉桌布之后，妻子高效地展开工作，用一种深色的胶剂将桌面上的小孔彻底封死。\n两个女儿脸色苍白，那天早上我坚持要带她们去散步，于是有了以下交谈。\n“爸爸，我对于那张桌子最糟糕的预感正在变成现实，”朱莉娅说，“它的马蹄足杵到我肩膀上，这样一个暗示并不是无缘无故的。”\n“净胡扯，”我说，“我们去布朗夫人餐馆，买个冰激凌。”\n眼下德谟克利特的精神在我身上越发旺盛。它随着阳光的增强而增强，奇妙的巧合。\n“但真够神的，”安娜说，“虫子怎么会从一张桌子里钻出来？”\n“没什么，我的女儿。虫子从木头里钻出来，这很平常。你肯定见过它们从壁炉里那些劈柴的一端钻出来。”\n“啊，可是这类木头几乎是刚从林中砍下来的。而那张桌子至少有一百年了。”\n“那又如何？”我快活说道，“在岩块内部，不也发现过极其古老的活蟾蜍吗？”\n“随便你怎么讲，爸爸，反正我觉得是鬼魂，”朱莉娅说，“当机立断，亲爱的爸爸，把那张闹鬼的桌子从家里弄走吧。”\n“净胡扯。”我说。\n她俩越是害怕，我越是胆壮，又一个奇妙的巧合。\n夜幕降临。\n“这嘀嗒声，”妻子说，“你觉得是另一只虫子在继续打洞吗？”\n很奇怪，我原先从未考虑过这个问题。我可没想到会有双胞胎虫子。但现在，天知道，说不定还有三胞胎虫子。\n我决定防患于未然，再者，如果第二只虫子即将现身，得确保它安全无虞。夜间，嘀嗒声重新响起。十点钟左右，我靠耳朵找到发声的大致区域，往上边罩了一只平底玻璃杯。随后我们回房休息，并把香柏木客厅锁好，钥匙揣在我裤袋里。\n第二天早晨，桌子上什么也没有，可依然能听见嘀嗒声。两个女儿又开始害怕。她们想上邻居家待着，但妻子大力反对。我们将成为整个镇子的笑柄。所以我们一致同意，家丑不可外扬。比迪受到严格的限制，而且，为了确保她不向牧师走漏消息，那个星期我们不许她去忏悔。\n我一整天足不出户，每隔一两个小时就仔细观察桌子一次，又是听又是看。随着夜晚来临，我觉得嘀嗒声越来越清晰，而且木板上凭耳朵圈定的发声区域也越来越狭小。另外我还觉得，在我倒扣平底玻璃杯的地方，可以观察到一阵微弱的搏动，或者是木头的鼓胀。为了不再瞎猜，妻子建议用刀子把那儿的桌面切开，但我有一个稍具耐心的计划，亦即她和我在桌子旁坐一晚，因为从刻下的状况来判断，虫子很可能在天亮之前钻出木板。对我而言，目睹它来到世间是很有意思的事情，好比破壳小鸡的第一次耀眼亮相。\n这个主意打动了我妻子。她坚持要朱莉娅和安娜也参与进来，好让两个女儿亲眼见识一番，抛弃所有荒谬幼稚的观念。在我妻子看来，什么鬼魂在嘀嗒作响啦，什么鬼魂可以从虫子身上跑到她们身上啦，尽是愚蠢到无以复加的妄想。确实，她没法解释这个现象，但她坚信有答案，而且迟早会找到答案，该答案也完全能够让她满意。我妻子并不知道，她其实是个女德谟克利特。至于我本人，目前的认识还很含混。在德谟克利特和科顿·马瑟之间，我正以一种既奇特又让人讨厌的方式轻轻摆荡。不过，在妻子和女儿眼里，我是个纯粹的德谟克利特主义者，对所有茶桌鬼魂不屑一顾。\n于是乎，我们准备了充足的蜡烛和饼干，四个人一同坐在桌子旁，围着它熬夜。有好一阵子，我和妻子大聊特聊，两个女儿却一声不吭。此后我和妻子又想玩他一局惠斯特牌。可是女儿们完全打不起精神，结果我们等于跟两个名副其实的木偶在打牌。妻子赢了一局，但赢得很没劲，索性也将扑克牌丢到了一边。\n十一点半。看不到虫子的影子。蜡烛开始变暗。妻子正打算掐灭它们，突然间传来一阵狂暴、空洞、洪亮的隆隆巨响。\n朱莉娅和安娜一跳三尺高。\n“万事平安！”街头有个声音大喊。是守夜人。他先拿棍棒敲打石子路面，继而来上那么一句极其令人安心的吆喝。\n“万事平安！姑娘们，听到了吗？”我高兴道。\n事实上，跟三个女人为伴，我感觉自己像布鲁斯14一样充满勇气，这可真让人吃惊，而两名姑娘几乎吓傻了。\n我起身去拿烟斗，吐了一口饱含哲思的烟雾。\n永远应选择德谟克利特，我想。\n在深沉的静默中，我坐着抽烟。这时候，你听！——嘭！嘭！嘭！——正好是桌子下面，嘭嘭声大作。\n这一次，我们四个统统一跳三尺高，我的烟斗摔裂了。\n“天啊！是什么在响？”\n“鬼魂！鬼魂！”朱莉娅喊道。\n“啊，啊，啊！”安娜喊道。\n“真丢人，”妻子说，“是地窖里新装瓶的苹果酒炸开了。今天我告诉过比迪，要用绳子捆好。”\n以下是我从那天晚上的记录中转抄的字句：\n一点钟。无虫子踪迹。嘀嗒声仍在持续。太太越来越困。\n两点钟。无虫子踪迹。嘀嗒声断断续续。太太已熟睡。\n三点钟。无虫子踪迹。嘀嗒声相当稳定。朱莉娅和安娜越来越困。\n四点钟。无虫子踪迹。嘀嗒声有规律，但不激烈。太太、朱莉娅和安娜均在椅子上熟睡。\n五点钟。无虫子踪迹。嘀嗒声微弱。我昏昏欲睡。其他人仍在睡觉。\n笔录到此为止。\n——梆！梆！梆！\n大门传来一阵可怕、不祥的敲打声。\n我们从梦中惊醒，起身站立。\n梆！梆！梆！\n朱莉娅和安娜连连尖叫。\n我缩在墙角。\n“你们这些笨蛋，”妻子喊道，“是面包师来送面包。”\n六点钟。\n妻子去拉开百叶窗，还没弄完，便听到朱莉娅一声大呼。桌板上，虫子半藏半露，正扭动不已，像颗火蛋白石一样照亮了昏暗的房间。\n即使这只虫子佩有一柄小小的利剑——一柄大马士革剑，脖子上再挂一串小小的项链——一串钻石项链，并且手中握着一支小枪——一支黄铜枪，嘴巴里还塞着一份手稿——一份占星术手稿，即使如此，朱莉娅和安娜也不会更加痴迷了。\n千真万确，这是一只漂亮的虫子——一只犹太珠宝商的虫子——一只闪耀如夕晖的虫子。\n朱莉娅和安娜从没想到会有那么一只虫子。她们原以为，虫子即丑陋的同义词。然而这只虫子堪称虫子中的炽天使。甚至，它就是美丽的化身，因为它如此美丽，宛似蝴蝶。15\n朱莉娅和安娜仔细看了又看。她们不再紧张兮兮。她们满心欢喜。\n“可是，这个奇特、漂亮的生灵是怎么钻进桌子里的？”朱莉娅问道。\n“精灵想去哪儿就去哪儿。”安娜回答。\n“哼！”妻子道。\n“你们还能听见嘀嗒声吗？”我说。\n她们竖起了耳朵，不过什么也没听到。\n“好吧，太太，女儿们，现在一切都结束了，今天上午我得去好好查一查这件事。”\n“哦，去吧，爸爸，”朱莉娅说，“去问一问帕齐太太，那个巫女。”\n“最好去问约翰逊教授，那位博物学家。”妻子说。\n“好极了，德谟克利特夫人，”我说，“我去找约翰逊教授。”\n很幸运，这位教授没出门。我简单讲了讲事情的原委，他颇有兴趣，又颇为冷静而镇定，并且郑重其事地跟我回家。我们向他展示了那张桌子、那两个小洞、那只虫子，又描述了事件的种种细节。我妻子和两个女儿均在场。\n“好了，教授，”我问道，“你怎么看？”\n戴上眼镜，这位博学的教授盯着桌子，用刀子轻轻在小洞里刮铲，但什么也没说。\n“这事情，并不寻常？”安娜焦急问道。\n“很不寻常，小姐。”\n朱莉娅和安娜交换了一个意味深长的眼神。\n“可这非常美妙，对吧？”朱莉娅问道。\n“非常美妙，小姐。”\n两个女儿交换了一个更加意味深长的眼神。受到鼓舞，朱莉娅再次开腔说话。\n“先生，您一定不承认，在这事情上发挥作用的，是鬼……”\n“鬼魂？不是。”回答不容辩驳。\n“女儿们，”我轻声道，“你俩应该清楚，回答你们提问的可不是巫女帕齐太太，而是知名的博物学家，约翰逊教授。好了，教授，”我补充说，“请您指教，让我们也长长见识。”\n我不再逐字逐句复述这位博学绅士的讲解，实际上，他虽然说得明白无误，言辞却有失单调——我将他的阐释总结如下，想来应该足够了。\n此事并非孤例。那张桌子的材质是苹果木，很受各种昆虫的欢迎，它们飞进果园，飞到活树上，把卵产在树皮下面。仔细检查最后一只虫子钻出桌面的地方，会发现它咬穿了一寸半的木头，而根据这一厚度所包含的木质层数，可以推算出桌板的木质总层数，再合理估测加工时削去的层数，则不难判断，虫卵产下的时间差不多是在苹果树遭砍伐的九十年以前。但从树木倒下到今天，又流逝了多少光阴？这张桌子的样式极其老旧。姑且认为它有八十年的历史吧，那么虫卵就存在了一百七十年。至少，这是约翰逊教授的计算。\n“朱莉娅啊，”我说，“听完这件事的科学解释（虽然，我承认，我并不完全明白），你还信是鬼魂作祟？它确实很奇妙，可鬼魂在哪里？”\n“是啊，在哪里？”妻子说。\n“如今她可不把这个纯粹的自然现象跟那些见神见鬼的浅陋说法联系到一起了，对吧？”博学的教授语带讥讽评论道。\n“随便你们怎么讲，”朱莉娅说，拿起瓶底玻璃杯里那枚莹莹发亮、光芒四射、璀璨夺目的鲜活蛋白石，“随便你们怎么讲，就算这个美丽的生物不是魂灵，它依旧让我们感受到超自然世界的力量。你看，经过一百七十年的休眠，这只小小的虫子终于来到世间，它那么灿烂，难道其中不含一星半点人类灵魂的辉煌复生？鬼魂！鬼魂！”她欣喜若狂，大叫道，“我依然相信神灵，只不过我现在满怀愉悦地相信它们，而以前我一想到它们就感到害怕。”\n那只神秘的昆虫，它没能让自己绚丽的生命延续多久，第二天便死去了。但姑娘们将它保存下来，装进一只银质的香盒里，放在苹果木桌子上，置于香柏木客厅的两扇窗户之间。\n如果哪位女士怀疑这个故事，我的两个女儿会很乐意向她展示那只虫子和那张桌子，并且指给她看，在后者经过修补的桌板上，有两个以蜡滴封好的小洞，它们正是两只虫子钻成的，这多少有点儿像人们在布拉托街教堂16标出了它被炮弹击中的地方。\n此篇原题“The Apple-Tree Table”，1856年5月首刊于《普特南氏月刊》 （Putnam’s Monthly Magazine）。——译者注（本书注释，均为译者所加，以下不再逐一标明）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n培根修士（Friar Bacon），应指罗杰·培根（Roger Bacon，约1214—1293），英国修士，唯名论者，有唯物主义倾向的哲学家和自然科学家，知识广博，素有“奇异博士”之称。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n雅各的梯子（Jacob’s ladder），典出《旧约》，象征通往神圣和幸福的途径。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n据欧洲民间传说，浮士德博士（Doctor Faust）将灵魂出卖给魔鬼梅菲斯特（Mephistopheles），才创造出了许多奇迹。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n科顿·马瑟（Cotton Mather，1663—1728），北美清教牧师，马萨诸塞的领袖人物。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《辉煌业绩》（Magnalia），全名为《基督在北美的辉煌业绩》（Magnalia Christi Amricana），是科顿·马瑟在1702年出版的一本著作。该书详尽记述了开拓新英格兰殖民地的历程，鼓吹清教徒遵循上帝的旨意到荒原上建立神圣国度。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n畿尼（guinea），英国的旧金币，值一镑一先令。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n“福克斯姑娘”（Fox Girls），又称为“福克斯姐妹”（Fox Sisters），指十九世纪美国纽约姓福克斯的三姐妹，她们分别是利亚·福克斯（Leah Fox，1831—1890）、玛格丽特·福克斯（Margaret Fox，1833—1893）、凯瑟琳·福克斯（Catherine Fox，1837—1892），三人创建了神秘主义派别唯灵派（Spiritualism）。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n拉德克利芙夫人（Mrs Radcliffe），即安·拉德克利芙（Ann Radcliffe，1764—1823），英国小说家，以创作浪漫主义的哥特小说见长，作品融恐怖、悬念和浪漫气息于一体。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n约翰逊博士（Dr. Johnson），指塞缪尔·约翰逊（Samuel Johnson，1709—1784），英国作家、评论家。于1755年编成《英语大辞典》，牛津大学给他颁发荣誉博士学位，因此人们称他为“约翰逊博士”。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n惠斯特牌（whist），类似于桥牌的纸牌游戏。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n德谟克利特（Democritus，约公元前460—370），古希腊哲学家。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n阿布底拉（Abdera），古希腊色雷斯的海滨城市，德谟克利特的出生地。传说德谟克利特常去一些荒凉之处，或者待在墓地中，以激发想象力。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n布鲁斯（Bruce），应指罗伯特·布鲁斯（Robert the Bruce，1274—1329），苏格兰国王，领导苏格兰打败了英格兰，赢得民族独立。被称为“勇敢的心”（Braveheart）。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n“甚至……蝴蝶”一句的原文为“or, rather, all it had of the bug was the B, for it was beautiful as a butterfly”。这是一个文字游戏，直译为“B就是这只虫子所具有的一切，因为它美丽如蝴蝶”。“美丽”（beautiful）和“蝴蝶”（butterfly）的英文单词首字母大写均为“B”，故作者会如此说。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n布拉托街教堂（Brattle Street Church），美国波士顿市的一座教堂，建于十七世纪末，十九世纪七十年代拆除。该教堂原有一座方塔，嵌着一枚炮弹，传说是美国独立战争时期，美军攻占波士顿时发射的。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2021-06-06T00:00:00Z","image":"https://heaciy.com/p/the-apple-tree-table/the-apple-tree-able_hu_50ad3f5199a2b35a.jpg","permalink":"https://heaciy.com/p/the-apple-tree-table/","title":"苹果木桌子"},{"content":" 作者👨‍💻：Pablo Iglesias 时间🕐：2018/06/27 原文链接🌐：https://www.bedjango.com/blog/top-6-django-decorators/ 声明👉：本文为转载，仅作为个人学习记录\nWhat is a Decorator? A decorator is the name of one of the most popular design patterns used nowadays, many times we use it without knowing that we are using a design pattern. And what\u0026rsquo;s so special about this pattern? As we can read at Python Wiki using It is a way of apparently modifying an object\u0026rsquo;s behavior, by enclosing it inside a decorating object with a similar interface. You can get more information about Pattern Design here.\nWhy I should use decorators in my web application? Decorators dynamically alter the functionality of a function, method or class without having to make subclasses or change the source code of the decorated class. Thanks to this our code will be more cleaner, more readable, maintainable (Which is no small thing), and reduce the boilerplate code allowing us to add functionality to multiple classes using a single method. A good example of the importance and easy of use of these decorators can be seen in the decorator @login_required that provides django, and that you probably used if you have some experience with our favorite framework. It’s just a piece of code where we check if the user is not authenticated the user is redirected to the login url.\nThe way that the decorators as used is the following:\n1 2 3 4 5 6 from django.contrib.auth.decorators import login_required @login_required def my_view(request) … Each time that a user try to access to my_view, the code inside login_required will be ejecuted.\nSome of our favorite decorators In this section we will show you some of the decorators that we think are most useful or that we have ever used with positive results, keep in mind that many of these can be customized to suit your needs. For this post we will use the original decorators with their font.\nGroup Required Sometimes we need to protect some views, to allow a certain group of users to access it. Instead of checking within it if the user belongs to that group/s, we can use the following decorator\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django.contrib.auth.decorators import user_passes_test def group_required(*group_names): \u0026#34;\u0026#34;\u0026#34;Requires user membership in at least one of the groups passed in.\u0026#34;\u0026#34;\u0026#34; def in_groups(u): if u.is_authenticated(): if bool(u.groups.filter(name__in=group_names)) | u.is_superuser: return True return False return user_passes_test(in_groups) # The way to use this decorator is: @group_required(‘admins’, ‘seller’) def my_view(request, pk) ... You can get more information about it here\nAnonymous required This decorator is based on the decorator login_required of Django, but looks for the opposite case, that the user is anonymous, otherwise the user is redirected to the website defined in our settings.py and can be useful when we want to protect logged user views, such as the login or registration view\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def anonymous_required(function=None, redirect_url=None): if not redirect_url: redirect_url = settings.LOGIN_REDIRECT_URL actual_decorator = user_passes_test( lambda u: u.is_anonymous(), login_url=redirect_url ) if function: return actual_decorator(function) return actual_decorator # The way to use this decorator is: @anonymous_required def my_view(request, pk) ... You can get more information about it here\nSuperuser required This is the same case as when we want to allow certain groups access to a view, but in this case only super users can visit it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from django.core.exceptions import PermissionDenied def superuser_only(function): \u0026#34;\u0026#34;\u0026#34;Limit view to superusers only.\u0026#34;\u0026#34;\u0026#34; def _inner(request, *args, **kwargs): if not request.user.is_superuser: raise PermissionDenied return function(request, *args, **kwargs) return _inner # The way to use this decorator is: @superuser_only def my_view(request): ... You can get more information about it here\nAjax required This decorator check if the request is an AJAX request, useful decorator when we are working with Javascript frameworks as jQuery and a good way to try to secure our application\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from django.http import HttpResponseBadRequest def ajax_required(f): \u0026#34;\u0026#34;\u0026#34; AJAX request required decorator use it in your views: @ajax_required def my_view(request): .... \u0026#34;\u0026#34;\u0026#34; def wrap(request, *args, **kwargs): if not request.is_ajax(): return HttpResponseBadRequest() return f(request, *args, **kwargs) wrap.__doc__=f.__doc__ wrap.__name__=f.__name__ return wrap # The way to use this decorator is: @ajax_required def my_view(request): ... You can get more information about it here\nTime it This decorator is very helpful if you need to improve the response time of one of then our views or if you just want to know how long it takes to run.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def timeit(method): def timed(*args, **kw): ts = time.time() result = method(*args, **kw) te = time.time() print(\u0026#39;%r (%r, %r) %2.2f sec\u0026#39; % (method.__name__, args, kw, te - ts)) return result return timed # The way to use this decorator is: @timeit def my_view(request): ... You can get more information about it here\nCustom Functionality The next decorator is just an example about how you can check some permissions or some checks in a easy way and 100% customizable.\nImagine you have a blog, shop, forum\u0026hellip;. Where users need to have a number of points in order to write a review, it would be a good way to avoid SPAM for example. We\u0026rsquo;ll create a decorator to check that the user is logged in and has more than 10 points, so you could write a review, otherwise we\u0026rsquo;ll raise a Forbidden\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from django.http import HttpResponseForbidden logger = logging.getLogger(__name__) def user_can_write_a_review(func): \u0026#34;\u0026#34;\u0026#34;View decorator that checks a user is allowed to write a review, in negative case the decorator return Forbidden\u0026#34;\u0026#34;\u0026#34; @functools.wraps(func) def wrapper(request, *args, **kwargs): if request.user.is_authenticated() and request.user.points \u0026lt; 10: logger.warning(\u0026#39;The {} user has tried to write a review, but does not have enough points to do so\u0026#39;.format( request.user.pk)) return HttpResponseForbidden() return func(request, *args, **kwargs) return wrapper You can get more information about it asking myself at piglesias@emergya.com or via twitter @pypiglesias. I really hope you found the post interesting or at least curious. From BeDjango we would like to encourage you to share your decorators, ideas or questions as well as interesting topics for future posts\n参考链接 python decorator ","date":"2021-02-14T00:00:00Z","image":"https://heaciy.com/p/top-6-django-decorators/top-6-django-decorators_hu_98da4a26a0c9091f.jpg","permalink":"https://heaciy.com/p/top-6-django-decorators/","title":"Top 6 Django Decorators"},{"content":"所以到底应该是说新年快乐呢还是元旦快乐呢？ 元旦快乐好像不是很好听，新年快乐的话那过年的时候说啥呢？\n愿望太多那就先面向抽象许个愿：🎈🎊🎉愿新年，胜旧年🎈🎉🎊\n愿：\n六级、系统分析师、系统架构师、考研都能取得好成绩 愿家人、朋友还有自己都能开开心心、健健康康的生活，平安喜乐 P.s. 我发现从小到大我都有这样一种感觉，2019的年末的时候在想，2020听上去好奇怪的感觉……但是到了2020的一刹那又好像突然什么都习惯了，心里也接受了这是新的一年了。 就在昨晚我还在想2021读着一点都不顺，到了今早 1月1号，“现在就应该是2021……”\n新的一年，也请继续加油，继续努力\n","date":"2021-01-01T00:00:00Z","image":"https://heaciy.com/p/happy-new-year-2021/happy-new-year-2021_hu_8ae28f08e65f11c.jpg","permalink":"https://heaciy.com/p/happy-new-year-2021/","title":"Happy New Year"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 from typing import Tuple # char: 单字符,形如\u0026#39;h\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;k\u0026#39; # word: 词,形如\u0026#34;hack\u0026#34; class TrieNode(object): \u0026#34;\u0026#34;\u0026#34; 字符节点 \u0026#34;\u0026#34;\u0026#34; def __init__(self, char: str): self.char = char # 存储的字符 self.children = [] # 该节点的子节点 self.word_finished = False # 是否是词尾 self.counter = 1 # 出现在word中的次数 def add(root, word: str): \u0026#34;\u0026#34;\u0026#34; 向字典树中添加词 \u0026#34;\u0026#34;\u0026#34; node = root # node的初始值为root节点* for char in word: # 遍历整个word found_in_child = False # 标记当前char是否在node的子结点列表中 for child in node.children: if child.char == char: # node节点的子节点中包含当前的char child.counter += 1 # 该字符在word中出现的次数加一 node = child # node向下移动一位,即为当前字符 found_in_child = True # 标记为找到 break if not found_in_child: # 当前字符不在node的子节点列表中,则新建一个节点加入到node的子节点列表中 new_node = TrieNode(char) node.children.append(new_node) node = new_node # node移至当前节点 # 当word中所有字符被遍历完后,node即为最后一个字符,将其标记为词尾 node.word_finished = True def find_profix(root, prefix: str) -\u0026gt; Tuple[bool, int]: \u0026#34;\u0026#34;\u0026#34; 检查并返回: 1. 该前缀是否出现在添加过的词中 2. 如果是,那么有多少词组包含该前缀 \u0026#34;\u0026#34;\u0026#34; node = root if not root.children: # 如果当前节点无子节点则直接返回(False,0) return False, 0 for char in prefix: # 遍历prefix中的字符 char_not_found = True # 标记当前字符是否出现在node的子节点列表中,默认为True for child in node.children: if child.char == char: # 如果当前字符包含在node的子结点中 char_not_found = False node = child # node向前移一位,即移至当前字符的位置 break if char_not_found: # 如果当前字符不在node的子结点中则直接返回(False,0) return False, 0 # 执行至此步则表示prefix的所有字符都出现在字典树中,直接返回True和最后一个字符的counter return True, node.counter def get_all_words(root: TrieNode): \u0026#34;\u0026#34;\u0026#34; 获取Trie中所有的词组 \u0026#34;\u0026#34;\u0026#34; all_words = [] current_word = [] # 递归方式 def tmp(root: TrieNode): for node in root.children: # 遍历当前节点的所有子节点 current_word.append(node.char) # 将当前子节点加入到current_word中 if node.word_finished: # 如果当前字符为词尾 all_words.append(current_word.copy()) # 将当前词组加入到all_words中 if node.children: tmp(node) # 当前子节点有子节点, 继续递归遍历 else: current_word.pop() # 当前子节点无子节点即为词尾,出栈 if current_word: current_word.pop() return tmp(root) # 从根节点开始 return [\u0026#39;\u0026#39;.join(word) for word in all_words] if __name__ == \u0026#34;__main__\u0026#34;: # 构造根节点和字典树 root = TrieNode(\u0026#39;*\u0026#39;) add(root, \u0026#34;hackathon\u0026#34;) add(root, \u0026#34;hack\u0026#34;) # 在字典树中查找 print(find_profix(root, \u0026#34;hac\u0026#34;)) print(find_profix(root, \u0026#39;hack\u0026#39;)) print(find_profix(root, \u0026#39;hackathon\u0026#39;)) print(find_profix(root, \u0026#39;ha\u0026#39;)) print(find_profix(root, \u0026#39;hammer\u0026#39;)) print(get_all_words(root)) # 输出结果为: # (True, 2) # (True, 2) # (True, 1) # (True, 2) # (False, 0) # [\u0026#39;hack\u0026#39;, \u0026#39;hackathon\u0026#39;] 工作原理 算法的主要步骤\n首先要考虑的是如何将word加入到Trie中, 这也是add方法的职责所在。它的工作方式非常简单。它需要两个参数:root node(即根节点，一般使用*)和word 然后它从单词的第一个字符开始遍历, 一次一个字符 检查当前node的子节点中是否含有该字符 如果有, 则只增加该字符的counter, 以表明该字符是重复出现 如果没有, 则只用简单的将该字符添加到当前node节点的子节点列表中 对于4\u0026amp;5这两种情况, 在考虑下一个字符之前, 都是使用node的child node作为当前节点(这意味着, 当前的child node在下一个循环中将成为node节点) 这就是在Trie中添加一个单词的所有步骤。还需要做的另一件事是在整个过程完成后标记单词的结尾。这意味着Trie的每个叶节点的word_finished属性为True。\n要搜索前缀，只需执行几个简单的步骤\nfind_profix函数需要两个参数, root节点和需要搜索的profix 每次从peofix中按循序取一个字符与\u0026quot;当前node\u0026quot;的子节点比较, 找出包含该字符的节点 如果找到了, 则将该子节点作为当前node进行下一轮比较 如果未找到则返回(False, 0)表明在Trie中该前缀不存在 在试图找到一个比单词本身更大的前缀时, 该算法也将返回(False, 0) 如果Trie包含该前缀则返回(True, 该前缀出现在Trie包含的word中的次数)(即在Trie包含的所有词组中有多少个词包含该前缀) 摘自: Meidum: Implementing a Trie in Python\n原作者: Shubhadeep Roychowdhury\n","date":"2020-12-19T00:00:00Z","image":"https://heaciy.com/p/implementing-a-trie-in-python/trie_hu_33d061fc71a001d0.jpeg","permalink":"https://heaciy.com/p/implementing-a-trie-in-python/","title":"Implementing a Trie in Python"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import numpy import matplotlib.pyplot import scipy.special %matplotlib inline class neuralNetwork: def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate): # 初始化神经网络 self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes self.lr = learningrate # 学习率 # from node i to node j in the next layer self.wih = numpy.random.normal(0.0, pow(self.hnodes, -0.5), (self.hnodes, self.inodes)) # 权重矩阵 self.who = numpy.random.normal(0.0, pow(self.onodes, -0.5), (self.onodes, self.hnodes)) self.activation_function = lambda x: scipy.special.expit(x) # 应用激活函数 def train(self, inputs_list, targets_list): inputs = numpy.array(inputs_list, ndmin=2).T targets = numpy.array(targets_list, ndmin=2).T hidden_inputs = numpy.dot(self.wih, inputs) hidden_outputs = self.activation_function(hidden_inputs) final_inputs = numpy.dot(self.who, hidden_outputs) final_outputs = self.activation_function(final_inputs) output_errors = targets - final_outputs hidden_errors = numpy.dot(self.who.T, output_errors) self.who += self.lr*numpy.dot((output_errors*final_outputs*(1.0-final_outputs)), numpy.transpose(hidden_outputs)) # 调整隐藏层与输出层之间的权重 self.wih += self.lr*numpy.dot((hidden_errors*hidden_outputs*(1.0-hidden_outputs)), numpy.transpose(inputs)) # 调整输入层与隐藏层之间的权重 def query(self, inputs_list): inputs = numpy.array(inputs_list, ndmin=2).T # 输入矩阵的转置矩阵 hidden_inputs = numpy.dot(self.wih, inputs) hidden_outputs = self.activation_function(hidden_inputs) final_inputs = numpy.dot(self.who, hidden_outputs) final_outputs = self.activation_function(final_inputs) return final_outputs input_nodes = 784 # 28*28，输入层节点数 hidden_nodes = 100 # 隐藏层节点数 output_nodes = 10 # 输出层节点 learning_rate = 0.2 # 学习率 # 生成一个神经网络实例 n = neuralNetwork(input_nodes,hidden_nodes,output_nodes,learning_rate) # 加载训练数据 training_data_file = open(\u0026#34;mnist_dataset/mnist_train.csv\u0026#34;, \u0026#39;r\u0026#39;) training_data_list = training_data_file.readlines() training_data_file.close() # 训练神经网络 epochs = 5 # 训练5个世代(本篇的学习率为0.2，训练数据为六万组，训练五个世代，测试数据为一万组) for e in range(epochs): for record in training_data_list: all_values = record.split(\u0026#39;,\u0026#39;) inputs = (numpy.asfarray(all_values[1:])/255.0*0.99)+0.01 targets = numpy.zeros(output_nodes) + 0.01 targets[int(all_values[0])] = 0.99 n.train(inputs,targets) # 加载测试数据(本篇使用了一万组测试数据，正确率为95.11%，结果可能不大一致，但大概都在94%~95%) test_data_file = open(\u0026#34;mnist_dataset/mnist_test.csv\u0026#34;, \u0026#39;r\u0026#39;) test_data_list = test_data_file.readlines() test_data_file.close() # 测试神经网络 scorecard = [] for record in test_data_list: all_values = record.split(\u0026#39;,\u0026#39;) correct_label = int(all_values[0]) # print(correct_label, \u0026#34;correct lable\u0026#34;) inputs = (numpy.asfarray(all_values[1:])/255.0*0.99)+0.01 outputs = n.query(inputs) label = numpy.argmax(outputs) # print(label, \u0026#34;networks\u0026#39;s answer\u0026#34;) if(label == correct_label): scorecard.append(1) else: scorecard.append(0) pass pass # print(scorecard) # 输出训练成绩 scorecard_array = numpy.asarray(scorecard) print(\u0026#34;performances = \u0026#34;, scorecard_array.sum()*1.0/scorecard_array.size) ","date":"2019-10-13T00:00:00Z","image":"https://images.unsplash.com/photo-1590859808308-3d2d9c515b1a?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026amp;ixlib=rb-1.2.1\u0026amp;auto=format\u0026amp;fit=crop\u0026amp;w=1653\u0026amp;q=80","permalink":"https://heaciy.com/p/neural-network-with-python/","title":"Neural Network With Python"},{"content":"我爱一切的花朵。\n在任何一个千红万紫的花摊上，各色花朵的壮阔交杂，成了都市中最美的点缀。\n其实并不爱花圃，爱的是旷野上随着季节变化而生长的野花和那微风吹过大地的感动。\n生活在都市里的人，迫不得已在花市中捧些切花回家。对于离开泥土的鲜花，总觉对它们产生一种疼惜又抱歉的心理，可是还是要买的。这种对花的抱歉和喜悦，总也不能过分去分析它。\n我买花，不喜欢小气派。不买也罢了。如果当日要插花，喜欢一口气给它摆成一种气势，大土瓶子哗的一下把房子加添了生命。那种生活情调，可以因为花的进入，完全改观。不然，只水瓶中一朵，也有一份清幽。\n说到清幽，在所有的花朵中，如果是想区别“最爱”，我选择一切白色的花。而白色的花中，最爱野姜花以及百合──长梗的。\n许多年前，我尚在大西洋的小岛上过日子，那时，经济情况拮据，丈夫失业快一年了。我在家中种菜，屋子里插的是一人高的枯枝和芒草，那种东西，艺术品味高，并不差的。我不买花。\n有一日，丈夫和我打开邮箱，又是一封求职被拒的回信。那一阵，其实并没有山穷水尽，粗茶淡饭的日子过得没有悲伤，可是一切维持生命之外的物质享受，已不敢奢求。那是一种恐惧，眼看存款一日一日减少，心里怕得失去了安全感。这种情况只有经历过失业的人才能明白。\n我们眼看求职再一次受挫，没有说什么，去了大菜场，买些最便宜的冷冻排骨和矿泉水，就出来了。\n不知怎么一疏忽，丈夫不见了，我站在大街上等，心事重重的。一会儿，丈夫回来了，手里捧着一小把百合花，兴匆匆的递给我，说：“百合上市了。”\n那一剎间，我突然失了控制，向丈夫大叫起来：“什么时间了？什么经济能力？你有没有分寸，还去买花?!”说着我把那束花啪一下丢到地上去，转身就跑。在举步的那一剎间，其实已经后悔了。我回头，看见丈夫呆了一两秒钟，然后弯下身，把那给撒在地上的花，慢慢拾了起来。\n我往他奔回去，喊着：“荷西，对不起。”我扑上去抱他，他用手围着我的背，紧了一紧，我们对视，发觉丈夫的眼眶红了。\n回到家里，把那孤零零的三五朵百合花放在水瓶里，我好像看见了丈夫的苦心。他何尝不想买上一大缸百合，而口袋里的钱不敢挥霍。毕竟，就算是一小束吧，也是他的爱情。\n那一次，是我的浅浮和急躁，伤害了他。以后我们没有再提这件事。\n四年以后，我去上丈夫的坟，进了花店，我跟卖花的姑娘说：“这五桶满满的花，我全买下，不要担心价钱。”\n坐在满布鲜花的坟上，我盯住那一大片颜色和黄土，眼睛干干的。以后，凡是百合花上市的季节，我总是站在花摊前发呆。\n一个清晨，我去了花市，买下了数百朵百合，把那间房子，摆满了它们。在那清幽的夜晚，我打开全家的窗门，坐在黑暗中，静静的让微风，吹动那百合的气息。\n那是丈夫逝去了七年之后。又是百合花的季节了，看见它们，立即看见当年丈夫弯腰去地上拾花的景象。没有泪，而我的胃，开始抽痛起来。\n作者: 三毛 (选自《思念的长河》)\n","date":"2019-09-19T00:00:00Z","image":"https://images.unsplash.com/photo-1494154263685-1241ed054a2f?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026amp;ixlib=rb-1.2.1\u0026amp;auto=format\u0026amp;fit=crop\u0026amp;w=750\u0026amp;q=80","permalink":"https://heaciy.com/p/%E5%A4%9C%E6%B7%B1%E8%8A%B1%E7%9D%A1/","title":"夜深花睡"}]