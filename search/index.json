[{"content":" 本文基于王道的数据结构考研复习指导，仅作为本人的学习笔记，如有误欢迎指正\n 插入排序 直接插入排序 整个例表[0...i-1, i, i+1...n]，i前面的部分维持有序，从i开始向后遍历无序的部分，不断往前面有序的部分插入，插入流程是\n i与i-1（i前面的元素，即有序列表中最后一个，即最大值）比较 如果i大于i-1则说明i比0~i-1都大，故将i插入到有序部分的最后（即保持当前位置不变） 如果i比i-1小，则从i-1开始向前寻找合适的位置，一边比较，一边挪动，直到找到合适的位置，再将i对应的值放到该位置  不断地把i位置的元素插入到i前面的有序部分中，直到最后一个插入完成即有序\ndef insert_sort(A: List[int]): \u0026#34;\u0026#34;\u0026#34; 插入排序 稳定 O(n^2) \u0026#34;\u0026#34;\u0026#34; tmp = 0 for i in range(1, len(A)): # i从第二个位置开始 if A[i] \u0026lt; A[i-1]: # 与有序部分最大值比较判断是否需要挪动 tmp = A[i] # 暂存当前值 j = i-1 while(A[j] \u0026gt; tmp and j \u0026gt;= 0): # 向后挪动，将插入位置挪出来 A[j+1] = A[j] j -= 1 A[j+1] = tmp # 将当前值放入插入位置 空间效率：仅使用了常数个辅助单元，因此空间复杂度为O(1)\n时间效率：在排序时向有序子表中插入当前元素共进行了n-1趟，每趟操作都在进行比较和移动，而比较次数和移动次数取决于待排表的初始状态\n 最好情况：初始表基本有序，每趟都只需要比较一次而不用移动元素，时间复杂度为O(n) 最坏的情况：初始表逆序，总比较次数$\\sum_{i=2}^n{i}$，总移动次数$\\sum_{i=2}^n{i+1}$ 平均情况：初始表状态随机，取最坏和最好的平均值，总比较和总移动次数均约为O($\\frac{n_2}{4}$)  稳定性：由于每次插入前总是先比较再移动，所以不会出现相同元素位置发生变化的情况，故直接插入排序是一种稳定的排序方法\n适用性：适用于顺序存储和链式存储的线性表。为链式时，可以从前往后的查找元素位置\n注意：大部分排序算法都仅适用于顺序存储的线性表\n折半插入排序 同样的道理，依次遍历后面无序的部分往前面有序的部分插入，只是将从有序部分中查找插入位置的过程改成二分查找，找到正确的插入位置后再依次挪动，把插入位置挪出来，将值放入\ndef insert_sort_binary(A: List[int]): \u0026#34;\u0026#34;\u0026#34;折半插入排序 稳定 O(n^2)\u0026#34;\u0026#34;\u0026#34; for i in range(1, len(A)): tmp = A[i] # 暂存当前值 low, high = 0, i-1 while(low \u0026lt;= high): # 二分查找 mid = int((low+high)/2) if A[mid] \u0026lt; tmp: low = mid+1 else: high = mid - 1 j = i-1 while(j \u0026gt; high): # 向后挪值，将插入位置挪出来 A[j+1] = A[j] j -= 1 A[high+1] = tmp # 总是在high的下一个位置插入 时间效率：相比直接插入排序只是减少了比较次数，约为O($n\\log_2{n}$)，且与表的初始状态无关，仅取决于表中元素数量n。而元素移动次数不变，依赖于待排表的初始状态。因此时间复杂度仍为O($n^2$)\n稳定性：折半插入排序是一种稳定的排序方法\n适用性：适用于线性表为顺序存储的情况，对于数据量不是很大的排序表，折半插入排序往往具有较好的性能\n希尔排序 希尔排序也称缩小增量排序\n设置一个步长，每次从第一个元素开始，每隔一个步长取一个元素，将这些间隔步长的一组元素使用插入排序进行排序，然后逐渐缩短步长，直至步长为1。\n一边缩短步长，一边对使用当前步长划分的小组进行插入排序。每一次根据步长的排序都会使当前列表逐渐有序。列表逐渐有序，也就逐渐减小了后面几趟排序时的工作量。最后一趟步长为1，也就意味着对当前整个列表进行插入排序，但是得益于前面几趟的排序使得整个列表基本有序，那么当前的排序工作量就被减少了很多。经过最后一趟排序，整个列表就有序了\n整个过程就体现了它的名字：缩小增量排序\ndef shell_sort(A: List[int]): \u0026#34;\u0026#34;\u0026#34;希尔排序 不稳定 O(n^1.3)~O(n^2)\u0026#34;\u0026#34;\u0026#34; n = len(A) dk = int(n/2) # 初始步长 while(dk \u0026gt;= 1): # 结束出口 for i in range(dk, n, dk): # 从当前小组的第二个开始 if A[i] \u0026lt; A[i-dk]: # 与小组内前一个比较 tmp = A[i] j = i-dk while(A[j] \u0026gt; tmp and j \u0026gt;= 0): # 比较、挪动 A[j+dk] = A[j] j -= dk A[j+dk] = tmp dk = int(dk/2) # 不断地减小步长 空间效率：仅使用了常数个辅助单元，空间复杂度为O(1)\n时间效率：依赖于增量序列的函数，涉及数学上尚未解决的难题，当n在某个特定范围时时间复杂度约为O($n^{1.3}$)。最坏情况为O($n^2$)\n稳定性：当相同关键字记录被划分到不同子表时，可能会改变原有相对次序，故希尔排序是一种不稳定的排序方法\n适用性：希尔排序仅适用于线性表为顺序存储的情况\n交换排序 冒泡排序 从前往后（或从后往前）两两比较相邻元素的值，若为逆序（A[i]\u0026gt;A[i+1]）则交换他们，直到序列比较完。这一过程成为冒泡，第一次从A[0]到A[n-1]，最大值将被冒泡到最后一个位置即A[n-1]；第二次从A[0]到A[n-2]，次大值将被冒泡到A[n-2]……每一趟冒泡都将一个元素放到其最终的位置。最多n-1趟冒泡就能把所有元素排好序\ndef bubble_sort(A: List[int], n:int): \u0026#34;\u0026#34;\u0026#34;冒泡排序 稳定 O(n^2)\u0026#34;\u0026#34;\u0026#34; tmp = n-1 # 需要n-1趟冒泡,tmp也为最后一个元素的下标 while(n \u0026gt; 0): flag = False # 表示本趟冒泡是否发生值交换的标志 for i in range(0, tmp): # 一趟冒泡排序，从0到tmp-1 if A[i] \u0026gt; A[i+1]: # 若为逆序则交换 A[i], A[i+1] = A[i+1], A[i] flag = True if not flag: return # 本趟没有发生交换，则说明序列已经有序，无需再调整 tmp -= 1 空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)\n时间效率：\n 最好情况：原始序列初始有序，第一趟冒泡后flag为False，即结束排序，共比较了n-1次，移动次数为0，故时间复杂度为O(n) 最坏情况：原始序列逆序，需要n-1趟排序，第i趟要进行i-1次比较，而每次比较后都必须移动元素3次来交换元素位置（针对原书中的C语言版本tmp=a;a=b;b=tmp）故共比较了$\\sum_{i=1}^{n-1}{(n-1)}=\\frac{n(n-1)}{2}$，移动次数$\\sum_{i=1}^{n-1}3(n-i)=\\frac{3n(n-1)}{2}$。从而最坏情况下时间复杂度为O($n^2$) 平均时间复杂度：O($n^2$)  稳定性：从前往后，先比较再移动，相邻两元素若相等则不会发生交换，故稳定。\n注：冒泡排序不同于插入排序，对于冒泡排序，每一趟排序后都有一个元素被放置到最终的位置上，也就是说全局有序。\n快速排序 选定一个枢轴，将小于它的值都交换到它前面，将大于它的值都交换到它的后面，然后对前后两个部分继续递归划分。一般选列表中的第一个作为枢轴，对整个列表进行划分。设置两个标志low和high，low从第一个元素开始，high从最后一个元素开始。\n设有一个列表L\n 首先将一个元素赋值给枢轴pivot 开始划分  将high所指元素与pivot比较，如果L[high]\u0026gt;=pivot，则将high前移指向前一个元素，从后往前直到找到第一个小于pivot的值，将这个值覆盖到L[low] low从第一个往后走，直到找到第一个大于pivot的值，将这个值覆盖到L[high] 上述1、2两部交替执行，直到low=high，此时这个位置就是pivot的最终位置，将pivot放置到该位置   经过上面一趟划分之后，pivot前面的元素都小于它，后面的元素都大于它。pivot将列表L划分为前面小于它的子表，和后面大于它的子表。然后再基于分治的思想对前后两个子表进行划分  def quick_sort(A: List[int], low: int, high: int): \u0026#34;\u0026#34;\u0026#34;快排 不稳定\u0026#34;\u0026#34;\u0026#34; def partition(L: List[int], low: int, high: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;划分函数\u0026#34;\u0026#34;\u0026#34; pivot = L[low] # 将当前表中第一个元素作为枢轴,对表进行划分 while(low \u0026lt; high): # 循环跳出条件low=high # 操作1、2交替进行直到low=high，此位置即为pivot的最终位置 # 1.high从后往前，当high的值比枢轴值大时将其放到low对应的位置 while(low \u0026lt; high and L[high] \u0026gt;= pivot): high -= 1 L[low] = L[high] # 2.low从前往后前，当low对应的值大于大于枢轴值时将其放到high的位置 while(low \u0026lt; high and L[low] \u0026lt;= pivot): low += 1 L[high] = L[low] L[low] = pivot # 此时low=high,将枢轴放置该位置 return low # 返回枢轴的最终位置 if low \u0026lt; high: # 当传入的low=high时不再需要划分 pivotpos = partition(A, low, high) # 根据上一趟枢轴的位置划分子表 quick_sort(A, low, pivotpos-1) # 依次递归排序两个子表 quick_sort(A, pivotpos+1, high) 选择排序 简单选择排序 “设排序表为L[1\u0026hellip;n]，第i趟排序即从L[i..n]中选择关键字最小的元素与L[i]交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可以使得整个排序表有序”，通俗的说就是从前往后不断地把最小的值换到前面去。\ndef select_sort(A: List[int], n:int): \u0026#34;\u0026#34;\u0026#34;选择排序 不稳定\u0026#34;\u0026#34;\u0026#34; for i in range(0, n-1): # 一共进行n-1趟排序 min = i # 记录最小值位置 for j in range(i+1, n): # 在A[i...n-1]中选择最小的元素 if A[j] \u0026lt; A[min]: min = j # 更新最小元素位置 if min != i: A[i], A[min] = A[min], A[i] # 将最小值替换到前面的位置 空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)\n时间效率：简单选择排序移动次数较少，最多不会超过3(n-1)次对应逆序，最少0次对应排序表初始有序。比较次数与初始状态无关，始终是$\\frac{n(n-1)}{2}$次，因此时间复杂度始终是O($n^2$)\n稳定性：在第i趟找到最小元素后，和第i个元素交换，可能导致第i个元素与其含有相同关键字元素的相对位置发生改变。比如{2，2，1}经一趟排序后是{1，2，2}，显然2和2的相对位置发生了变化。因此，简单选择排序是一种不稳定的排序方法。\n比较直接插入、冒泡和简单选择排序\n直接插入排序：从后往前，从无序部分中取值往前面有序部分中插入，稳定\n冒泡排序：从后往前，一边比较一遍交换挪动位置，每趟都会确定一个元素的最终位置，稳定\n简单选择排序：从当前元素往后找出最小值的位置，然后将最小值和当前位置的元素交换，每趟都会确定一个元素的最终位置，但是不稳定，比如[2,2,1]交换排序后就是[1,2,2]，第一个2和第二个2相对顺序发生了变化\n堆排序 堆的定义如下：\n  L[i]\u0026gt;L[2i]且L[i]\u0026gt;L[2i+1] 或\n  L[i]\u0026lt;L[2i]且L[i]\u0026lt;L[2i+1] (1≤i\u0026lt;≤⌊n/2⌋)\n  可以将一个一维数组视为一颗完全二叉树，满足上述条件一的为大根堆，注意：节点序号是从1开始的\n当前节点序号为n，其左孩子序号为2*n，其右孩子节点为2*n+1\n借助最大堆或最小堆进行排序（注意：最大堆、最小堆与二叉排序数不同！最大堆只是根节点比子节点大，但是左右子节点之间并没有固定的大小关系；二叉排序树中，左儿子最小，根节点居中，右儿子最大，所以二叉排序树的中序遍历得到的序列即是有序的）。构建出初始最大堆后，输出堆顶元素，然后“删除”，将最后一个叶节点移到堆顶位置，重新调堆，输出堆顶元素……重复上述过程\ndef heap_sort(A: List[int], length: int): \u0026#34;\u0026#34;\u0026#34;堆排序 不稳定 O(nlog2n)\u0026#34;\u0026#34;\u0026#34; def bulid_max_heap(L: List[int], length: int): \u0026#34;\u0026#34;\u0026#34;构建最大堆\u0026#34;\u0026#34;\u0026#34; i = int(length/2) # 最后一个父节点，根据完全二叉树的性质 while(i \u0026gt; 0): # 从i= ⌊n/2⌋~1，反复调堆，注意节点下标是从1开始的 adjust_heap(L, i, length) i -= 1 def adjust_heap(L: List[int], k: int, length: int): # 调整以元素K为根节点的子树 # 第一个节点要预留（即下标为0的节点） L[0] = L[k] # 使用L[0]暂存子树的根节点 i = 2*k # 第一个子节点 while i \u0026lt;= length: if i \u0026lt; length and L[i] \u0026lt; L[i+1]: # 沿key较大的子节点向下筛选 i += 1 # 取key较大的子节点的下标 if L[0] \u0026gt; L[i]: # 根节点大于最大的子节点，不需要再调整 break else: L[k] = L[i] # 将L[i]调整到双亲节点上 k = i # 修改K值，继续向下筛选，K值即为当前的双亲节点 i *= 2 # 继续 L[k] = L[0] # 被筛选节点的值放入最终位置 bulid_max_heap(A, length) # 创建初始堆 n = length while n \u0026gt;= 1: # 注意下标为0的节点“不存储数据” A[1], A[n] = A[i], A[n] # 交换堆顶和堆低元素，相当于把最大值移到最后的位置 n -= 1 # \u0026#34;缩短长度\u0026#34;，调整堆的大小，把剩余n-1个元素整理成堆 adjust_heap(A, 1, n) 归并排序 “归并就是将前后两个有序表归并成一个有序表。设两段有序表A[low\u0026hellip;mid], A[mid+1\u0026hellip;high]存放在同一顺序表中的相邻位置，先将他们复制到数组B中。每次从对应B中的两个段中取出一个记录进行关键字比较，将较小者放入A中，当数组B中有一段的下标超出其对应的表长（即该段的所有值都已复制到A中）时，将另一段中剩余的部分直接复制到A中。”\n通俗的说：归并就是将两个有序表合成一个，将原表先拷贝一份，然后从中间分为左右两个子表，依次比较左右两个表中的值，并将较小值插入原表，若最后左右子表中还有一个有剩余的，则将剩余的元素直接复制到原表中\n递归形式的2路归并排序是基于分值的，先一直向下划分 mid = ( low + high ) / 2，直到low=high-1（递归出口），即low与high相邻，此实左右子表都只有一个元素，即左右子表此时都是有序的，然后就可以开始合并了，一直向上合并直到最上面一层合并完成\ndef merge_sort(A: List[int], low: int, high: int): \u0026#34;\u0026#34;\u0026#34;归并排序 二路归并 稳定 O(n*log2n)\u0026#34;\u0026#34;\u0026#34; def merge(A: List[int], low: int, mid: int, high: int): # 合并左右两段有序的序列A[low..mid]和A[mid+1...high] B = A.copy() # 把A拷贝一份，然后直接在A上调整 i = low j = mid+1 k = i while i \u0026lt;= mid and j \u0026lt;= high: # 比较、挪动、将较小值放回A中 if B[i] \u0026lt; B[j]: # 比较B中左右两段中的元素 A[k] = B[i] i += 1 # 将较小值放入A中 else: A[k] = B[j] j += 1 k += 1 # 下面两个while只有一个会执行 while i \u0026lt;= mid: # 左侧序列未检测完、复制 A[k] = B[i] k += 1 i += 1 while j \u0026lt;= high: # 右侧序列未检测完、复制 A[k] = B[j] k += 1 j += 1 if low \u0026lt; high: # 递归条件，只有当low=high-1时，即low、high相邻时才停止递归 # 此时，左右两段各有一个值，即左右两段都有序，则开始执行merge合并有序段 # 然后向上回退，一边回退一边merge # 递归形式的二路归并 mid = int((low+high)/2) # 从中间划分两个子序列 merge_sort(A, low, mid) # 对左侧子序列进行递归排序 merge_sort(A, mid+1, high) # 对右侧子序列进行递归排序 merge(A, low, mid, high) # 归并 各种排序算法的比较    算法 O(最好情况) O(平均情况) O(最坏情况) 空间复杂度 是否稳定     直接插入排序 O(n) O($n^2$) O($n^2$) O(1) ✅   冒泡排序 O(n) O($n^2$) O($n^2$) O(1) ✅   简单选择排序 O($n^2$) O($n^2$) O($n^2$) O(1) ❌   希尔排序     ❌   快速排序 O($nlog_2n$) O($nlog_2n$) O($n^2$) O($log_2n$) ❌   堆排序 O($nlog_2n$) O($nlog_2n$) O($nlog_2n$) O(1) ❌   2路归并排序 O($nlog_2n$) O($nlog_2n$) O($nlog_2n$) O(n) ✅    ","date":"2021-06-17T00:00:00Z","image":"https://gitee.com/Heaciy/img/raw/master/post/photo-1585776245991-cf89dd7fc73a.jpg","permalink":"https://heaciy.com/p/internal-sort/","title":"常用内部排序算法"},{"content":" 我承认，是标题党！哈哈哈哈哈哈哈，本来是准备写一篇“Django Signal源码解析——从Observer Pattern到Django Signal”的，但是我又不能一两句话把观察者模式讲清楚的，干脆就直接贴了一些相关的链接……后面越写越多、越拖越长就干脆改成简析算了…… 本文只作为个人学习记录，仅供参考，如有误欢迎讨论指正 题图来自 unsplash，原图链接🔗\n 观察者模式 “观察者模式是一种对象行为模式。它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。[1]”\n“观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。[2]”\n观察者模式有多种实现方式，比较经典的一种实现，有四个角色：Subject（被观察对象抽象类）、Observer（观察者抽象类）、ConcreateObserver（具体观察者）、ConcreateSubject(具体的被观察者)……\n这里就不赘述了……可以参见下面的链接\n wikipedia：Observer pattern 百度百科：观察者模式 观察者模式（Observer模式）详解 观察者模式 菜鸟教程：观察者模式 观察者模式的python简单实现  Signal简述 可以先看看Django的官方文档\n https://docs.djangoproject.com/zh-hans/3.0/topics/signals/ https://docs.djangoproject.com/zh-hans/3.0/ref/signals/  与观察者模式对应：sender就是被观察者、receiver是观察者。有所不同的就是多了个signal，也就是“信号”（也可使说是信号的“管理者”）。在普通观察者模式中，被观察对象抽象类中一般会维护一个观察者抽象类的引用列表，以此来传递消息，而django中则是借助Signal类进一步解耦，通过Signal类进行“信号传递”，具体解析如下：\n1. signal 信号类，维护一个receivers列表，用于存储sender和receiver的对应记录\nsignal.connect()用于往signal.receivers中添加对应的receiver和sender记录\nsignal_send()，在signal.receivers中查找sender对应的receivers并将对应信号(参数)传递给对应的receivers\ndjango预置了一些信号对象，pre_init、post_init、pre_save、post_save等，这些都是直接或间接的继承自Siganl类，单一职责原则，每个具体的信号对象只负责存储“一类信号”，比如前面列举的四个信号对象都是django model相关的。以pre_save为例，只有在调用某个model对象的save方法时（前）才会调用pre_save.send()发送相关数据（“信号”）。也就是说pre_save这个Signal对象的receivers列表中存储的sender都是model而receiver都是我们希望在进行model.save()前调用的函数来进行的一些相关操作。\n2. sender 信号的发送方，即调用signal.send()方法的类。比如，所有model类的父类都是BaseModel，而BaseModel有一个__init__函数在该函数中，首先就会调用pre_init.send(self.__class__,**kwargs)发送即将开始init的信号，然后再进行具体的init操作，在init之后再调用post_init.send发送init完成的信号。故这里的BaseModel类就是这两个信号对象(pre_init、post_init)的sender。而我们的model类都是继承自BaseModel，init方法也是继承来的，故此时的sender就是我们定义的model类。\n3. receiver 信号的接收方，为可调用对象，一般是个函数，接收signal.send()传递过来的参数，再进行相关的操作\n假如我们有个model对象为People，我们想要在构造每一个People时（new_people = People(name=\u0026quot;haha\u0026quot;,email=\u0026quot;haha@mail.com\u0026quot;)）打印出其相关信息，我们可以用一个函数打印其信息：\ndef print_info(*args,**kwargs): print(f\u0026#34;args: {args}\\nkwargs: {kwargs}\u0026#34;) 然后使用pre_init.connect(print_info, sender=People)将其与sender绑定起来,即在pre_init的receivers列表中存一条对应的记录:\n((People_id,print_info_id),print_info_weakref) 此处的print_info函数即为一个receiver，pre_init信号中People类对应的receiver。\n当然也可以直接使用装饰器，不过也是同样的道理\n@receiver(pre_init,sender=People) def print_info_before_init(sender,*args,**kwargs): print(f\u0026#34;args: {args}\\nkwargs: {kwargs}\u0026#34;) 最终打印出来的结果是\nargs: []\rkwargs: {'name':'haha','email':'haha.mail.com'}\r原理简析 django的整个信号模块都是依赖Signal这个类完成的\n\rSignal Class Diagram\r \rSignal Class Diagram Detail\r\n1. Signal的属性和__init__方法 1.receivers：一个列表用于存取该Signal中对应的sender和receiver并存下receiver的引用(或弱引用)，在调用connect()方法时会往receivers中添加对应关系，而在调用send()方法时会在其中查找对应关系\n数据结构：\n# 如果在调用connect方法添加时weak参数为True（默认为True） # 则存储receiver的弱引用，在垃圾回收时会自动处理 [((receiver_id,sender_id),receiver_weakref),] # 弱引用 # 如果connect方法的weak参数为False # 则存储receiver的强引用，最终需要调用disconnect销毁记录 # 否则相关变量无法被垃圾回收，也就是”内存泄露“ [((receiver_id,sender_id),receiver),] # 强引用 2.providing_args：该signal接受的参数的列表\n3.lock：threading.lock，对相应操作加锁以保证安全\n4.use_caching：bool类型，标识是否使用缓存，如果使用缓存我们会缓存每一个sender类的receivers并存储到self.sender_receivers_cache中\n5.sender_receivers_cache：signal对每一个sender的receivers进行缓存\n数据结构：\n{ \u0026#34;sender1\u0026#34;: [receiver1_weakref, receiver2_weakref,...], \u0026#34;sender2\u0026#34;: [receiver3_weakref, receiver4_weakref,...], } 每次send时会使用sender_receivers_cache快速判断该sender是否有receiver，如果有则再调用_live_receivers获取其对应的receivers的强应用列表\n6._dead_receivers：bool类型，用于标识self.reivers中是否含有失效的 receiver的弱引用。当弱引用指向的receiver被垃圾回收时会调用Signal._remove_receiver方法将_dead_receivers置为True\n2. Signal中的方法 说在前面：receiver和sender都必须是可哈希的\n1.connect：将receiver和sender通过对应的Signal连接起来（即将对应记录添加到对应Signal对象的receivers属性列表中）\n参数解析：\n receiver：需要接收信号的receiver sender：发送该信号的sender weak：是否使用弱引用，默认为True。如果为True则存储receiver对应的weakref否则直接存储强引用。由于设置了weakref.finalize(receiver_object, self._remove_receiver)若存储弱引用则可以在receiver垃圾回收时自动清除Signal.receivers中对应的记录（见下面的分析）若存储强引用则需要先手动调用disconnect方法删除Signal.receivers中对应的记录否则该receiver将无法被垃圾回收导致“内存泄漏” dispatch_uid：默认为None，如果使用了该值（一般为一个字符串），相当于为该receiver自定义个唯一名称（不允许重复），存储时将会使用dispatch_uid代替id(sender)  def connect(self, receiver, sender=None, weak=True, dispatch_uid=None): if dispatch_uid: lookup_key = (dispatch_uid, _make_id(sender)) # 如果设置了dispatch_uid则使用其期待id值作为唯一标识 else: lookup_key = (_make_id(receiver), _make_id(sender)) if weak: # 如果使用弱引用 ref = weakref.ref receiver_object = receiver # Check for bound methods if hasattr(receiver, \u0026#39;__self__\u0026#39;) and hasattr(receiver, \u0026#39;__func__\u0026#39;): # 如果该receiver是对象方法，则receiver_object为包含该receiver的对象 ref = weakref.WeakMethod receiver_object = receiver.__self__ receiver = ref(receiver) # 获取该receiver的弱引用 weakref.finalize(receiver_object, self._remove_receiver) # receiver_object垃圾回收时调用self._remove_receiver将self._dead_receivers置为True # 在后面的send或send_robust中对self.receivers加锁后清理 with self.lock: self._clear_dead_receivers() if not any(r_key == lookup_key for r_key, _ in self.receivers): # 检查是否有重复 self.receivers.append((lookup_key, receiver)) self.sender_receivers_cache.clear() # 每次connect或disconnect后都要清除缓存 # 该缓存会在send时构建 2.disconnect：从对应Signal对象的receivers列表中删除对应记录（一般用于手动删除在connect时使用weak=False的情况，即该条记录存的是receiver的强引用，若不手动删除该条记录会导致“内存泄漏”，与gc的引用计数有关）\ndef disconnect(self, receiver=None, sender=None, dispatch_uid=None): \u0026#34;\u0026#34;\u0026#34; 将signal中的receiver与sender“断开连接” 该函数主要针对那些在connect时weak参数为False的情况，即signal的receivers列表 中存储的是rceiver的强引用 如果在connect时使用的弱引用(weak=True), 则不需要手动调用disconnect方法 receiver和sender的记录会被自动删除 \u0026#34;\u0026#34;\u0026#34; if dispatch_uid: lookup_key = (dispatch_uid, _make_id(sender)) # 如果提供了dispatch_uid则使用其替代 id(receiver) else: lookup_key = (_make_id(receiver), _make_id(sender)) disconnected = False with self.lock: self._clear_dead_receivers() # 先清除dead_receivers for index in range(len(self.receivers)): (r_key, _) = self.receivers[index] if r_key == lookup_key: # 根据lookup_key在self.receivers中查找 disconnected = True del self.receivers[index] # 删除self.receivers中的对应记录 break self.sender_receivers_cache.clear() # 变更后清除缓存 return disconnected 3.has_listeners：检查某个sender是否有receiver\ndef has_listeners(self, sender=None): return bool(self._live_receivers(sender)) 4.send：给某个sender对应的所有receivers发送相应的信号，首先会检查这个sender是否有receivers。如果有，先调用_live_receivers获取当前sender对应的所有的receiver的强引用，然后依次调用每个receiver传入相关的参数。最后，返回[(receiver,response),]（这里的receiver是强引用即可直接调用的receiver函数，response是调用receiver函数返回的结果）\n参数解析：\n sender：发送信号的类 **named：传递给该sender对应的receivers的参数  def send(self, sender, **named): if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS: return [] return [ (receiver, receiver(signal=self, sender=sender, **named)) for receiver in self._live_receivers(sender) # _live_receivers返回的是该sender对应的所有的receivers的强引用 ] 注： 当调用某个receiver发生异常时程序会直接退出，可能导致其他剩下的receiver并没有被调用执行\n5.send_robust：“健壮版”的send，当调用某个receiver发生异常时会将异常捕捉并存储起来，故该sender的所有的receiver都能被调用执行。该函数会返回[(receiver,response / err),]\ndef send_robust(self, sender, **named): # 相比send方法调用receiver方法异常时直接退出，send_robust会收集异常并返回 if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS: return [] # Call each receiver with whatever arguments it can accept. # Return a list of tuple pairs [(receiver, response), ... ]. responses = [] for receiver in self._live_receivers(sender): try: response = receiver(signal=self, sender=sender, **named) except Exception as err: responses.append((receiver, err)) # 如果调用receiver出现异常则捕获并返回相应的异常而不影响其他receiver的调用 else: responses.append((receiver, response)) return responses 6._clean_dead_receivers：清除Signal.receivers中的dead receiver，该函数会在send或send_robust中对Signal.receivers加锁了的情况下调用\ndef _clear_dead_receivers(self): # Note: caller is assumed to hold self.lock. # 清除dead_receivers if self._dead_receivers: self._dead_receivers = False # 还原_dead_receivers为False self.receivers = [ r for r in self.receivers if not(isinstance(r[1], weakref.ReferenceType) and r[1]() is None) # 弱引用，并且该弱引用对应的对象已消亡 ] 注： 其实这里说的清除dead receiver，就是删除Signal.receivers中那些原函数/对象（即receiver函数或包含receievr函数的对象）已经被垃圾回收了的weakref，至于那些在connect时使用weak=False添加的强引用则需要手动调用disconnect进行手动清除，否则可能会导致内存泄露\n7._live_receivers：先通过self._dead_receivers检查是否有dead receivers如果有则先过滤一遍Signal.receivers，然后从Signal.receivers中找出该sender对应所有的receiver，并返回包含所有receiver强引用的列表\ndef _live_receivers(self, sender): \u0026#34;\u0026#34;\u0026#34; Filter sequence of receivers to get resolved, live receivers. This checks for weak references and resolves them, then returning only live receivers. \u0026#34;\u0026#34;\u0026#34; receivers = None if self.use_caching and not self._dead_receivers: # 如果使用缓存并且self.receivers中无dead_receivers receivers = self.sender_receivers_cache.get(sender) # 直接从缓存中获取 # We could end up here with NO_RECEIVERS even if we do check this case in # .send() prior to calling _live_receivers() due to concurrent .send() call. # 其实我们在调用_live_receivers方法的send方法中已经检查过一次了 if receivers is NO_RECEIVERS: return [] if receivers is None: # 如果不使用缓存或者存在待清理的dead receivers with self.lock: self._clear_dead_receivers() # 先清理dead_receivers senderkey = _make_id(sender) receivers = [] for (receiverkey, r_senderkey), receiver in self.receivers: # 遍历self.receivers进行查找匹配 if r_senderkey == NONE_ID or r_senderkey == senderkey: # 如果senderkey为id(None)或匹配 receivers.append(receiver) # 将receiver(weakref)添加到receivers中 # 更新缓存 if self.use_caching: # 如果使用缓存 if not receivers: # 如果该sender没有receiver (receivers为空) self.sender_receivers_cache[sender] = NO_RECEIVERS # 将cache中该sender的receivers置为空 else: # 如果该sender存在对应的receiver # Note, we must cache the weakref versions. # 注意我们应该缓存弱引用 self.sender_receivers_cache[sender] = receivers # 将该sender及其所有的receivers缓存起来 non_weak_receivers = [] for receiver in receivers: # receivers要么为[] 要么为[receiver] if isinstance(receiver, weakref.ReferenceType): # Dereference the weak reference. # https://www.kite.com/python/docs/weakref.ReferenceType receiver = receiver() # 获取弱引用所指的实际对象，若已消亡则返回None，否则返回对象的强引用(“可直接调用”) if receiver is not None: # weakref所指的原对象尚未消亡 non_weak_receivers.append(receiver) # 添加实际可调用的receiver对象 else: non_weak_receivers.append(receiver) # 不是弱引用则直接添加 return non_weak_receivers # 可调用对象receiver的列表 8._remove_receivers：将Signal._dead_receivers置为True，在后面调用send或send_robust方法时会先检查_dead_receivers，如果为True则先调用_clean_dead_receivers进行清理\ndef _remove_receiver(self, receiver=None): # Mark that the self.receivers list has dead weakrefs. If so, we will # clean those up in connect, disconnect and _live_receivers while # holding self.lock. Note that doing the cleanup here isn\u0026#39;t a good # idea, _remove_receiver() will be called as side effect of garbage # collection, and so the call can happen while we are already holding # self.lock. # 标记self.receivers中有dead weakrefs(weakref所指对象已消亡).如果存在dead receiver # 程序会在调用connect, disconnect和_live_receivers时在加锁的情况下清除dead weakrefs # 注意在这里执行具体的清除操作并不是一个好主意，在垃圾回收时_remove_receiver()会被 # 自动触发，而我们可能在其他操作中对receivers加了锁，此时清理receivers将会导致冲突 self._dead_receivers = True 注： 由于在connect方法中的设置了weakref.finalize(receiver_object, self._remove_receiver)，在receiver_object垃圾回收时会自动触发_remove_receiver方法。如果将清除过滤Signal.receivers的过程放在这个函数中，而其它地方可能正在在加锁的情况下使用receivers则会导致冲突。故_remove_receivers只将Signal._dead_receivers置为True，从而把清理dead receiver的过程延迟到了connect、disconnect、send、send_robust中加锁进行\n3. 大概流程 通过Signal.connect向Signal.receivers中注册对应的((receiver_id, sender_id), receiver_weakref)记录，然后sender会在恰当的时候调用恰当的Signal并使用Signal.send发送恰当的信号给对应的所有receiver。这就是信号的大致传递过程\n4. 很奇怪的一点 程序里面有个奇怪的None，在connect时不指定sender则sender，默认sender就会是None，而在sender中调用Siganl.send方法该方法又会调用Signal._live_receivers方法，在Signal._live_receivers中会寻找该sender对应的receiver，而匹配条件居然是if r_senderkey == NONE_ID or r_senderkey == senderkey，sender为None的receivers也会被匹配？有点不太理解这里的做法\n5. 多说一句 异步问题，当一个sender注册的receiver过多时，调用send方法时可能会非常占用时间造成阻塞，观察者模式好像都有这个问题，可以使用异步改善？（在网上看到的，具体如何改善我还没搞清楚，等弄明白了再补上……）\n源码简析 源码：\n Github Django Docs  import threading import weakref from django.utils.inspect import func_accepts_kwargs # 返回对象的id,在connect存储记录和send查询记录时会用到 # 注意：sender和receiver都必须是可哈希的 def _make_id(target): if hasattr(target, \u0026#39;__func__\u0026#39;): # 如果是对象方法 return (id(target.__self__), id(target.__func__)) return id(target) # django.utils.inspect.func_accepts_kwargs # 检查传入的函数是否接受**kwargs参数 def func_accepts_kwargs(func): return any( p for p in inspect.signature(func).parameters.values() if p.kind == p.VAR_KEYWORD ) NONE_ID = _make_id(None) # A marker for caching NO_RECEIVERS = object() class Signal: \u0026#34;\u0026#34;\u0026#34; 所有signal的基类 Base class for all signals Internal attributes: receivers { receiverkey (id) : weakref(receiver) } \u0026#34;\u0026#34;\u0026#34; def __init__(self, providing_args=None, use_caching=False): \u0026#34;\u0026#34;\u0026#34; 创建新的signal providing_args: 在调用send()方法时可以传入这个signal的参数列表 \u0026#34;\u0026#34;\u0026#34; self.receivers = [] # ((receiver_id,sender_id),receiver_weakref)或者是((dispatch_id,sender_id),receiverweak_ref) # 具体是强引用还是weakref取决于connect时的weak参数是True还是False # 默认weak为True使用弱引用，若为False则删除该条记录时需要手动disconnect if providing_args is None: providing_args = [] self.providing_args = set(providing_args) self.lock = threading.Lock() # 加锁保证操作数据时线程安全 self.use_caching = use_caching # 是否使用缓存 # 为了便利即使不使用缓存我们也会创建空的缓存 # 关于缓存需要注意的一点是：如果use_caching为True，对于每一个sender # 我们会在sender_receiver_cache中缓存其所有的receiver。 # 该缓存在调用.connect()或者.disconnect()时会被清除，而在调用send时会被填充 self.sender_receivers_cache = weakref.WeakKeyDictionary() if use_caching else {} self._dead_receivers = False # receivers属性列表中是否含有“失效”的receiver引用(已被垃圾回收) # 在_clear_dead_receivers方法中会检查其值，如果为True则代表其中 # 有失效的receiver引用，则过滤清理一遍receivers属性列表 def connect(self, receiver, sender=None, weak=True, dispatch_uid=None): \u0026#34;\u0026#34;\u0026#34; # 通过signal将receiver连接到sender Arguments: receiver A function or an instance method which is to receive signals. Receivers must be hashable objects. If weak is True, then receiver must be weak referenceable. Receivers must be able to accept keyword arguments. If a receiver is connected with a dispatch_uid argument, it will not be added if another receiver was already connected with that dispatch_uid. sender The sender to which the receiver should respond. Must either be a Python object, or None to receive events from any sender. weak Whether to use weak references to the receiver. By default, the module will attempt to use weak references to the receiver objects. If this parameter is false, then strong references will be used. dispatch_uid An identifier used to uniquely identify a particular instance of a receiver. This will usually be a string, though it may be anything hashable. \u0026#34;\u0026#34;\u0026#34; from django.conf import settings # If DEBUG is on, check that we got a good receiver # 如果在DEBUG模式下，则检查该receiver是否满足要求 if settings.configured and settings.DEBUG: assert callable(receiver), \u0026#34;Signal receivers must be callable.\u0026#34; # Check for **kwargs if not func_accepts_kwargs(receiver): raise ValueError(\u0026#34;Signal receivers must accept keyword arguments (**kwargs).\u0026#34;) if dispatch_uid: lookup_key = (dispatch_uid, _make_id(sender)) # 如果设置了dispatch_uid作为某receiver的标识 else: lookup_key = (_make_id(receiver), _make_id(sender)) # 没有dispatch_uid则使用receiver的id if weak: # 如果使用weak则存储该receiver的弱引用，否则就直接存储强引用(强引用最终需要手动disconnect) ref = weakref.ref receiver_object = receiver # 强引用 # Check for bound methods if hasattr(receiver, \u0026#39;__self__\u0026#39;) and hasattr(receiver, \u0026#39;__func__\u0026#39;): # 检查是否是对象方法 # https://docs.python.org/zh-cn/3/library/weakref.html#weakref.WeakMethod ref = weakref.WeakMethod receiver_object = receiver.__self__ # 包含该对象方法的对象 # 使用弱引用替代强引用 receiver = ref(receiver) # 普通函数方法则直接取其弱引用 # 当receiver方法、或包含该方法对象消亡时从signal的receivers列表中清除该条记录 weakref.finalize(receiver_object, self._remove_receiver) # https://docs.python.org/zh-cn/3/library/weakref.html#weakref.finalize # 当receiver对象垃圾回收时调用_remove_receiver置self._dead_receivers = True with self.lock: self._clear_dead_receivers() # 清除、过滤dead_receivers if not any(r_key == lookup_key for r_key, _ in self.receivers): # 查重 self.receivers.append((lookup_key, receiver)) # 添加((receiver_id,sender_id),receiver_weakref) self.sender_receivers_cache.clear() # 变更后清除缓存 def disconnect(self, receiver=None, sender=None, dispatch_uid=None): \u0026#34;\u0026#34;\u0026#34; 将signal中的receiver与sender“断开连接” 该函数主要针对那些在connect时weak参数为False的情况，即signal的receivers列表 中存储的是rceiver的强引用 如果在connect时使用的弱引用(weak=True), 则不需要手动调用disconnect方法 receiver和sender的记录会被自动删除 Arguments: receiver The registered receiver to disconnect. May be none if dispatch_uid is specified. sender The registered sender to disconnect dispatch_uid the unique identifier of the receiver to disconnect \u0026#34;\u0026#34;\u0026#34; if dispatch_uid: lookup_key = (dispatch_uid, _make_id(sender)) # 如果提供了dispatch_uid则使用其替代 id(receiver) else: lookup_key = (_make_id(receiver), _make_id(sender)) disconnected = False with self.lock: self._clear_dead_receivers() # 先清除dead_receivers for index in range(len(self.receivers)): (r_key, _) = self.receivers[index] if r_key == lookup_key: # 根据lookup_key在self.receivers中查找 disconnected = True del self.receivers[index] # 删除self.receivers中的对应记录 break self.sender_receivers_cache.clear() # 变更后清除缓存 return disconnected def has_listeners(self, sender=None): # 通过调用_live_receivers方法看sender的recivers是否为空 return bool(self._live_receivers(sender)) def send(self, sender, **named): \u0026#34;\u0026#34;\u0026#34; Send signal from sender to all connected receivers. 从sender中发送信号给所有连接到该sender的receiver If any receiver raises an error, the error propagates back through send, terminating the dispatch loop. So it\u0026#39;s possible that all receivers won\u0026#39;t be called if an error is raised. Arguments: sender The sender of the signal. Either a specific object or None. named Named arguments which will be passed to receivers. Return a list of tuple pairs [(receiver, response), ... ]. \u0026#34;\u0026#34;\u0026#34; if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS: # 如果该signal得receivers为空或者该sender对应的receivers缓存为空 return [] return [ (receiver, receiver(signal=self, sender=sender, **named)) # 这里的receiver就是具体的receiver函数 for receiver in self._live_receivers(sender) # _live_receiver返回的是receiver的可调用对象(就是具体的receiver函数，强引用)的列表 ] # 返回[(receiver函数,调用receiver函数的结果)]如果调用某个receiver时发生异常程序会直接退出 # 导致其他的剩下的receiver并未被执行 def send_robust(self, sender, **named): \u0026#34;\u0026#34;\u0026#34; Send signal from sender to all connected receivers catching errors. Arguments: sender The sender of the signal. Can be any Python object (normally one registered with a connect if you actually want something to occur). named Named arguments which will be passed to receivers. These arguments must be a subset of the argument names defined in providing_args. Return a list of tuple pairs [(receiver, response), ... ]. If any receiver raises an error (specifically any subclass of Exception), return the error instance as the result for that receiver. 相比send方法调用receiver方法异常时直接退出，send_robust会收集异常并返回 \u0026#34;\u0026#34;\u0026#34; if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS: return [] # Call each receiver with whatever arguments it can accept. # Return a list of tuple pairs [(receiver, response), ... ]. responses = [] for receiver in self._live_receivers(sender): try: response = receiver(signal=self, sender=sender, **named) except Exception as err: responses.append((receiver, err)) # 如果调用receiver出现异常则捕获并返回相应的异常而不影响其他receiver的调用 else: responses.append((receiver, response)) return responses def _clear_dead_receivers(self): # Note: caller is assumed to hold self.lock. # 清除dead_receivers if self._dead_receivers: self._dead_receivers = False self.receivers = [ r for r in self.receivers if not(isinstance(r[1], weakref.ReferenceType) and r[1]() is None) # 弱引用，并且该弱引用对应的对象已消亡 ] def _live_receivers(self, sender): \u0026#34;\u0026#34;\u0026#34; Filter sequence of receivers to get resolved, live receivers. This checks for weak references and resolves them, then returning only live receivers. \u0026#34;\u0026#34;\u0026#34; receivers = None if self.use_caching and not self._dead_receivers: # 如果使用缓存并且self.receivers中无dead_receivers receivers = self.sender_receivers_cache.get(sender) # 直接从缓存中获取 # We could end up here with NO_RECEIVERS even if we do check this case in # .send() prior to calling _live_receivers() due to concurrent .send() call. # 在调用_live_receivers方法的方法中已经检查过一次了 if receivers is NO_RECEIVERS: return [] if receivers is None: # 如果不使用缓存或者存在待清理的dead receivers with self.lock: self._clear_dead_receivers() # 先清理dead_receivers senderkey = _make_id(sender) receivers = [] for (receiverkey, r_senderkey), receiver in self.receivers: # 遍历self.receivers进行查找匹配 if r_senderkey == NONE_ID or r_senderkey == senderkey: # 如果senderkey为id(None)或匹配 receivers.append(receiver) # 将receiver(weakref)添加到receivers中 # 更新缓存 if self.use_caching: # 如果使用缓存 if not receivers: # 如果该sender没有receiver (receivers为空) self.sender_receivers_cache[sender] = NO_RECEIVERS # 将cache中该sender的receivers置为空 else: # 如果该sender存在对应的receiver # Note, we must cache the weakref versions. # 注意我们应该缓存弱引用 self.sender_receivers_cache[sender] = receivers # 将该sender及其所有的receivers缓存起来 non_weak_receivers = [] for receiver in receivers: # receivers要么为[] 要么为[receiver] if isinstance(receiver, weakref.ReferenceType): # Dereference the weak reference. # https://www.kite.com/python/docs/weakref.ReferenceType receiver = receiver() # 获取弱引用所指的实际对象，若已消亡则返回None，否则返回对象的强引用(“可直接调用”) if receiver is not None: # ref所指的原对象尚未消亡 non_weak_receivers.append(receiver) # 添加实际可调用的对象 else: non_weak_receivers.append(receiver) # 不是弱引用则直接添加 return non_weak_receivers # 可调用对象receiver的列表 def _remove_receiver(self, receiver=None): # Mark that the self.receivers list has dead weakrefs. If so, we will # clean those up in connect, disconnect and _live_receivers while # holding self.lock. Note that doing the cleanup here isn\u0026#39;t a good # idea, _remove_receiver() will be called as side effect of garbage # collection, and so the call can happen while we are already holding # self.lock. # 标记self.receivers中有dead weakrefs(weakref所指对象已消亡).如果存在dead receiver # 程序会在调用connect, disconnect和_live_receivers时在加锁的情况下清除dead weakrefs # 注意在这里执行具体的清除操作并不是一个好主意，在垃圾回收时_remove_receiver()会被 # 自动触发，而我们可能在其他操作中对receivers加了锁，此时清理receivers将会导致冲突 self._dead_receivers = True def receiver(signal, **kwargs): \u0026#34;\u0026#34;\u0026#34; A decorator for connecting receivers to signals. Used by passing in the signal (or list of signals) and keyword arguments to connect:: 用来将receivers连接到对应signal的装饰器. 使用时传入signal(或者是装有signal的列表) 以及相关的关键字参数 @receiver(post_save, sender=MyModel) def signal_receiver(sender, **kwargs): ... @receiver([post_save, post_delete], sender=MyModel) def signals_receiver(sender, **kwargs): ... \u0026#34;\u0026#34;\u0026#34; def _decorator(func): if isinstance(signal, (list, tuple)): # 传入的是signal列表 for s in signal: s.connect(func, **kwargs) # 调用connect方法，sender的信息包含在kwargs中了 else: signal.connect(func, **kwargs) return func return _decorator 除此之外，django已经为我们预置了一些信号:\npre_init、post_init、pre_save、post_save、pre_delete、post_delete、m2m_change……(详细用法见官方文档)\ndjango在django/db/models/signals.py中定义了与数据库Model相关的信号对象:\n pre_init \u0026amp; post_init pre_save \u0026amp; post_save pre_delete \u0026amp; post_delete m2m_change class_prepared pre_migrate \u0026amp; post_migrate  在django/core/signals.py中定义了与request和setting相关的信号对象:\n request_started \u0026amp; request_finished got_request_exception setting_changed  django为我们预置这些信号对象，并且在适当的时候调用适当的信号对象发送适当的“信号”。比如在django/db/models/base.py中，在Model类的__init__方法开始位置调用pre_init.send()在__init__的结束位置调用post_init.send()，而我们的model又都是继承自该Model。\ndjango为我们预置好了一些信号，并且在做相应操作时会发送对应的信号，所以我们需要做的就是在需要用到时，定义对应的receiver去接收对应的信号📶即可。当然我们也可以直接实例化或继承Signal类来定义我们自己的信号。具体的使用可以参见这篇博客\n一些可能有用的链接  Python 弱引用 Python 垃圾回收  python gc模块接口文档 简书 Python垃圾回收机制 知乎 Python垃圾回收机制    ","date":"2021-06-10T00:00:00Z","image":"https://gitee.com/Heaciy/img/raw/master/post/photo-1494129935429-873eafa78178.jpg","permalink":"https://heaciy.com/p/django-signal-principle-analysis/","title":"Django Signal简析"},{"content":" 苹果木桌子——或一桩前所未见的灵异事件1 作者：[美] 赫尔曼·麦尔维尔 本文出自《苹果木桌子及其他简记》，读完之后我觉得整本书就数这篇最有趣了（剩下的都很催眠……😴）\n 我第一眼看见那张陈旧发暗、布满灰尘的桌子时，它摆放在一间漏斗状老阁楼最偏僻的角落里，表面搁着大大小小碎裂而结满污垢的紫色旧玻璃瓶，以及一部样子瘆人、脱胶落线的古老四开本图书。这张破烂的小桌子似乎萦绕着巫术，没准儿是培根修士2的私人器物。它有两个不乏魅力、魔力的明显特征——圆盘和三叉支架——桌板的弧度完美，由一根扭来扭去的柱子撑持，并在离底部大约一英尺的位置岔开，形成三条弯弯曲曲的桌脚，末端是三只马蹄足。确确实实，这张古旧的小桌子看起来相当邪恶。\n为使读者更好地了解它，不妨也介绍一下它所处的环境。非常古老的阁楼，非常古老的房子，位于全美国最古老市镇的古老街区之中。该阁楼已闲置多年。大伙认为里面闹鬼——不得不承认，谣言虽很荒谬（依我之见），但本人购买宅子时不曾大加驳斥，因为颇有可能，是它帮助我在财力允许的范围内，更顺利地拿下了这份房产。\n所以，定居此间的五年时光里，尽管并不害怕高处鼎鼎大名的妖魔鬼怪，我却从未走进过阁楼。没有特别的理由非上去不可。屋顶铺得严严实实，滴水不漏。为宅子承保的公司也从不探访这间阁楼，既然如此，房主本人又何必费心劳神？它根本派不上用场，下面的房子完全够住。再说楼梯门的钥匙也已经丢失。锁头粗大且老旧。想撬开它，必须请来一名铁匠，我觉得这是自找麻烦。另外，我虽小心翼翼不让两个女儿接触以上谣言，可她们道听途说，屡有耳闻，因此挺高兴见到闹鬼场所大门紧锁。如果不是一次偶然的发现，它或许还要封闭更长时间。在我家古老、幽深、依斜坡而建的花园某处，本人找到一枚奇特的大钥匙，样式古旧，铁锈斑驳，我立即推断它应该能打开阁楼的门锁——经过试验，猜想获得证实。眼下，拥有一枚蕴含着许多未知的钥匙，我很快产生了开锁并好好探索一番的渴望。当然啰，这只是为了满足好奇的天性，而不是为了去搜求任何具体的好处。\n瞧啊，我转动生锈的旧钥匙，然后独自往上走，步入闹鬼的阁楼。\n它的面积跟宅子地基的面积相同。阁楼的天花板即屋顶，可以看见铺着页岩瓦的房椽与梁架。屋顶中央隆起，让雨水从四个方向下泄，阁楼因此很像一位将军的帐篷——不过当中摆了一座木头柱子的迷宫，起支撑作用，无数蜘蛛网悬垂此间，在夏天的正午旳旳闪烁，宛如巴格达的轻丝薄纱。到处可见奇形怪状的昆虫，在横梁和地板上或飞或窜或爬。\n屋顶最高处下方有一条粗糙、狭窄、朽烂的梯子，状若哥特式教堂的讲坛台阶，通往一个讲坛式的平台，而它又搭了一条更狭窄的梯子——类似于雅各的梯子3——通往更高处的巍然天窗。这个天窗约莫两平方英尺见方，乃是一个整体，给一小块玻璃板配了一副巨大的框子，嵌套如舷窗。亮光从这个唯一的入口照进阁楼，穿过密集的重重蛛网。的确，整座楼梯，以及平台和梯子统统由蜘蛛网点缀、覆盖、笼罩，而这些层层堆积的阴郁物质同样垂挂于幽暗的拱形屋顶，犹如柏树林里生长的卡罗莱纳苔藓。蜘蛛网好比空中坟墓，众多不同种群的昆虫木乃伊在其间悠悠摆荡。\n登上平台，我停下来调整呼吸，看到一个奇异的景象。太阳悬在半空。日光穿过小天窗，将一条清晰的彩虹隧道斜斜扎入阁楼的黑暗之中。亿万浮尘在此泛涌。成百上千的飞虫聚成金灿灿的一群，紧贴着天窗，铙钹般嗡嗡作响。\n我想让光线更为充足，打算拿掉天窗的挡板。可是找不到插销或者搭扣。我眼睛瞪了半天，才看见一个小小的挂锁，像海底的牡蛎一样深深嵌入杂草般互相绞缠的大团蛛网、蛹壳和虫卵之间。我将杂物拂开，发现它锁死了，于是试着用一片弯曲的指甲将它拧开，这时候，几十只昏昏沉沉的小蚂蚁和苍蝇钻出锁孔，感受到窗玻璃上阳光的热度，开始在我周围乱爬。其他虫子也来凑热闹。很快我便不胜其扰。它们似乎被我毁人清静的举动激怒了，成群结队从下方扑来，难以计数，马蜂似的不断在我头上叮咬。最终，我一发狠，猛然将挡板推开。啊！形势大变。仿佛离开了阴暗的墓穴，摆脱了蛆虫的陪伴，你将欣喜若狂地升向鲜活的绿意和永生的辉煌，与之相仿，在蛛网密布的旧阁楼里，我硬是把脑袋挤入芳香怡人的空气之中，望见小花园里栽植的雄伟巨木正凭借其繁茂的树冠冲我致意，它们的枝叶高高伸展于屋顶的瓦片上方。\n窗外的景致让人精神一振，我随即转过身来，仔细察看阁楼，它已十分明亮，非比往常。尽是些大而无当的过时家具。有一张旧写字桌，老鼠在它的文档格上跳来跳去，隐秘的吱吱声从它暗处的抽屉中传出，恍如从林间花栗鼠的树洞里传出一般。还有一张散架的旧椅子，布满怪诞的花纹，似乎很适合魔法师的集会。又有一只没盖子的铁皮箱，锈迹斑驳，装满发霉的旧文件，其中一份，底端能看见一道褪色的红色墨迹，颇像是浮士德博士与梅菲斯特签订的灵魂契约4。最后，在光线最昏暗的角落里，在一大堆难以描述的破旧垃圾当中，在坏掉的望远镜和凹陷破损的星象仪之间，支着一张年深日久的小桌子。马蹄足，跟撒旦的脚形一样，并因蜘蛛网的遮挡而若隐若现。灰尘极厚，落在陈旧的小药瓶和长颈瓶上几乎黏结成块，它们往日曾盛满液体。而桌子中央霉烂的旧书——科顿·马瑟5的《辉煌业绩》6——看上去非常诡异。\n我把桌子和书拿到楼下，分别修好，补好。这张悲惨的遁世小木桌被放逐得太久，远离热情的友邻，所以我决定，要用温暖的锅碗瓢盆、温暖的壁炉和温暖的心包围它，让它如沐春风。我有点儿想知道，上述一切温暖的关照究竟能孕育出什么东西来。\n我很高兴看到这张桌子的材质并不是普通的红木，而是苹果木，年月使之发黑发暗，几乎变为胡桃木的色泽。它加入家具的行列之后，效果令人惊异，竟相当契合我们的香柏木客厅——这个房间有此称呼，是因为它本属于老派风格，镶着木质的护壁板。桌子的台面，或者说圆案，格外精巧，能够轻易从平放状态折叠为垂直状态，所以不使用时，可以将其靠墙搁在角落里。我觉得，把它当作我自己、我妻子以及两个女儿的小茶桌和小餐桌，应该很不错。这对于一张安静的桌子也颇为适宜。另外，想到它还可以变成一张极好的读书桌，本人甚感愉快。\n我妻子对以上设想却没什么兴趣。她讨厌这个主意，不欢迎苹果木桌子像一个殊为落伍、寒酸的陌生人那样，闯入光鲜华丽的家具群体之中。然而，桌子接下来去了一趟木匠铺子，回家后焕然一新，锃亮夺目有如一枚畿尼7，于是我妻子比任何人都更积极地接纳它。这张桌子在香柏木客厅占据了备享尊荣的一席之地。\n但是，我的女儿朱莉娅却始终未能摆脱第一次撞见苹果木桌子时产生的怪异情绪。很不幸，那天正赶上我把它从阁楼搬下来。当时我两手抓着桌子的圆案，将它举起，因此一只结满蛛网的马蹄足直戳于前，而在楼梯拐弯处，这个奇怪的部件突然碰到了正往上走的姑娘。于是乎，她一转身，没看见任何人——我完全被桌子挡住了——只看见马蹄足鬼魅般显现，好似撒旦的一条腿，她尖声大叫，要不是我立即开口说话，真不知接下去情况会变得多严重。\n我可怜的女儿，这件事让她精神紧张了好久，迟迟无法复原。姑娘很迷信，认为我走进了不应涉足的封闭场所，故而十分悲伤。在她意识里，这张三足分岔的桌子与臭名昭著的鬼怪息息相关。她恳求我别再倒腾什么苹果木桌子。她的姐妹也支持她。我的两个女儿天生就同气连枝。而我讲究实际的妻子如今却宣布她喜欢那张桌子。她一向意志坚定，精力充沛。对她而言，朱莉娅和安娜的成见简直荒唐透顶。她觉得，作为母亲她有义务将这股柔弱之风扫荡干净。渐渐地，吃早餐以及喝午茶时，我们让两个女儿一起坐到桌子旁。持续的接触不乏成效。没多久，她们已能安坐如常，但朱莉娅仍尽量不去看桌子的马蹄足，而我若发笑，她必定投来严肃的目光，仿佛在说，啊，爸爸，换成你大概也会这么做。姑娘预言，迟早要发生跟这桌子有关的怪事。结果我反倒笑得更欢，妻子则恼怒地责备女儿。\n同时，我把它当成一张晚间的读书桌，并因此深感满意。在一场女士们张罗的大集上，我给自己买了一只漂亮的读书靠垫，可以将胳膊肘搁在上面，再用手遮挡灯光，消磨漫长的时间——屋内悄无人声，唯有那本从阁楼里拿下来的古怪旧书与我相伴。\n原本诸事皆顺，直到发生了以下变故——请记住，这个小插曲跟本文的其他叙述一样，时间上远远早于“福克斯姑娘”8活跃的年代。\n那是十二月一个星期六的夜晚。又小又旧的香柏木客厅里，我坐在又小又旧的苹果木桌子前，像往常一样独自一人。我不止一次试图起身离开，上床睡觉，却怎么也办不到。当时我兴许是着魔了。不知为何，反正我运用理智的能力大不如前。我颇为紧张。实际上，虽然科顿·马瑟在以往的夜读时分让我愉快，这个晚上却让我害怕。那些故事曾千百次使我发笑。奇闻怪谈，我原本认为还挺有趣的。可是眼下，情形大大不同。它们开始显露真实的一面。此刻，我第一次觉得《辉煌业绩》的作者绝无拉德克利芙夫人9的浪漫情调，是一个实事求是、勤奋努力、热情真挚的正直之士，也是一位满腹经纶的大学者，以及一名优秀的基督徒和正统的牧师。这样一个人又怎么可能欺世盗名？他行文的风格朴实无华，直指真理，毫无避讳地向读者详细讲解了新英格兰的巫术，每一件重要的事情均有可敬的市民作证，而其中不少最令人惊奇的例子是他本人亲眼所见。科顿·马瑟固然证实了他看到的东西。但我自问，巫术是不是确有可能。我随即想到了约翰逊博士10，这位踏踏实实的字典编纂者相信幽灵存在，其他众多杰出卓异的名流亦然。顺从于那股使人着魔的力量，我一直阅读到三更半夜。最终，我发现几乎听不到一丁点儿声音，真希望别那么安静。\n我旁边放着一杯微热的潘趣酒。每逢星期六晚上，我喜欢不温不火地来些这样的饮料。然而，本人的好太太长年反对我这嗜好，断言除非我改过自新，否则一定死得像个惨兮兮的醉鬼。有必要说明一下，事实上，在那一个个紧跟着周六之夜到来的周日早晨，我不得不极其小心谨慎，如遇突发状况，绝不能流露哪怕最轻微的焦躁情绪，否则必然留下口实，被说成是夜间纵酒的恶果。至于我妻子，她从未品尝过潘趣酒，却很喜欢没事就发发小牢骚。\n在前文提到的那个晚上，我一反平时小酌怡情的习惯，调了杯烈酒。我渴求刺激。我需要一份鼓舞以抵抗科顿·马瑟——阴郁的、可怕的、鬼气森森的科顿·马瑟。我越来越紧张。仅仅是因为着了魔，我才没有从客厅逃走。烛光昏暗，烛泪长流，烛花成堆。可是我不敢用烛剪清理它们。那么做动静过大。而先前我还指望能有点儿声响。我读啊读啊。我头发的触觉变得异常敏锐。我的眼睛干涩、疼痛。我很清楚这一点。我知道我正使它们受损。我知道第二天我会因为用眼过度而懊悔。但我还是继续往下读。我已不由自主。我是鬼上身了。\n忽然间——听！\n我的头发根根倒竖。\n从什么东西的内部传出一阵轻微的敲打声或刮擦声——奇奇怪怪、莫名其妙的响动，混合着一些细小的叩击声或嘀嗒声。\n嘀嗒！嘀嗒！\n没错，是一种微弱的嘀嗒声。\n我抬头看了看墙角伫立的斯特拉斯堡大座钟。声音不是从那儿发出来的。座钟已经停摆。\n嘀嗒！嘀嗒！\n是不是我的怀表在响？\n按照妻子往常的做法，她去睡觉时会把我的怀表拿到卧室，挂在钉子上。\n我凝神倾听。\n嘀嗒！嘀嗒！\n是护壁板在格格响？\n我颤悠悠地沿墙走了一圈，将耳朵贴到护壁板上。\n不，这声音并非来自护壁板。\n嘀嗒！嘀嗒！\n我在发抖。我为自己的胆怯而害臊。\n嘀嗒！嘀嗒！\n声音的准确度和强度均在增加。我丢下护壁板走回来。这声音似乎要来找我。\n我四下张望，什么也没看到，只瞧见小苹果木桌子的一只马蹄足。\n上帝保佑，我喃喃自语，突然感觉一阵恶心。肯定很晚了。妻子是不是在叫我？对啊，对啊。我得睡觉去。门窗大概全锁上了。没必要再巡查一番。\n着魔的状态已经解除，恐惧却有增无减。我双手颤抖，将科顿·马瑟丢到一边，拿上烛台，快步走到卧室，怀着一份撤退的奇异感觉，好像一条狗落荒而逃。我急于进入卧室，半路上撞到了一张椅子。\n“别那么吵吵闹闹，亲爱的，”妻子躺在床上说，“恐怕你喝了太多的潘趣酒。你这可悲的嗜好一天比一天严重。啊，我从没见过你晚上这样跌跌撞撞地走进房间。”\n“太太，太太，”我嗓音嘶哑，低声道，“有什么东西——嘀嘀嗒嗒的东西——在香柏木客厅里一个劲儿响。”\n“可怜的老头子——快神志不清了——我就知道要搞成这个样子。上床。来睡个好觉。”\n“太太，太太！”\n“上来吧，上床。我原谅你了。明天我不会跟你提这茬儿。不过，亲爱的，你不许再喝潘趣酒了。这是为你好。”\n“别逗我发火，”此刻我终于回过魂来，喊道，“我可出门去了！”\n“不要去！不要这个鬼样子出去。上床来，亲爱的，我不再多说一个字。”\n第二天早上，妻子醒来后压根儿不提昨晚的事情，而我觉得非常尴尬，尤其是自己一度如此恐慌，所以我也不吭气。自然，妻子把我的怪异举动归结为精神错乱，不是幽灵作祟，而是潘趣酒添堵。至于我自己，躺在床上望着窗外的太阳时，我开始认为深夜读科顿·马瑟没什么益处，那会给神经造成不良影响，并引发幻觉。我决定把科顿·马瑟束之高阁。这样一来，我就不必担忧自己再听到任何嘀嗒声。实际上，我已转而相信屋子里的嘀嗒声不过是某种在我耳内回响的嗡嗡声。\n妻子一直习惯比我起得更早。我仔仔细细、舒心惬意地洗漱完毕。意识到大多数精神失常往往有身体状况上的根源，我用洁面刷使自己看起来活力四射，又用新英格兰的朗姆酒洗头，以前有人把这个偏方推荐给我，说是可以治耳鸣。我穿上晨袍，认真系好围巾，精心修剪过指甲，洋洋自得地走到楼下，去香柏木小客厅吃早饭。\n我很惊讶看到妻子正跪在苹果木小桌近旁边的地毯上找什么东西，早餐置于桌面无人理睬，而我的两个女儿，朱莉娅和安娜，正在房间里心烦意乱地跑来跑去。\n“哦，爸爸，爸爸！”朱莉娅快步向我走来，喊道，“我就知道会这样。桌子，那张桌子！”\n“鬼魂！鬼魂！”安娜站得远远的，指着桌子大叫。\n“安静！”妻子喝道，“你们一个劲儿吵，我怎么听得清？不要动。到这边来，老头子，这是你说的嘀嗒声吗？你干吗不过来？是它吗？这儿，跪下来听听。嘀嗒，嘀嗒，嘀嗒！——现在你听到了吧？”\n“来了，来了。”我喊道，而两个女儿却恳求我们从那儿走开。\n嘀嗒，嘀嗒，嘀嗒！\n就在洁白如雪的桌布、令人愉快的大茶壶，以及热气腾腾的牛奶吐司下面，正传出不可理喻的嘀嗒声。\n“隔壁不是有炉子吗，朱莉娅？”我说，“咱们上那儿吃早饭去，亲爱的，”我朝妻子转过身来，“咱们走——留下这张桌子——让比迪把东西挪开。”\n言语间，本人泰然自若地走向房门，妻子却拦住我。\n“离开客厅之前，我一定要弄清楚这嘀嗒声是什么，”她斩钉截铁说道，“我们肯定能搞明白，毫无疑问。我不信有鬼，尤其是在早餐时间。比迪！比迪！来，把这些东西搬回厨房。”她将大茶壶递过去，然后扯掉桌布，让小桌子光秃秃地暴露在我们眼皮底下。\n“桌子，是这张桌子！”朱莉娅大喊。\n“胡诌八扯，”妻子道，“谁听说过嘀嗒作响的桌子？声音是地板传出来的。比迪！朱莉娅！安娜！把房间清空——移走桌子和其他所有的东西。平头锤在哪儿？”\n“天啊，妈妈，你不是要把地毯给掀开吧？”朱莉娅尖叫。\n“夫人，锤子。”比迪有点儿发颤，走上前说道。\n“快给我。”妻子喊道。可怜的比迪拿着锤子，离得她老远，仿佛女主人染上了瘟疫。\n“好了，老头子，你拽地毯那一边，我拽这一边。”她随即跪下来，于是我也照做不误。\n地毯移开了，耳朵直接贴在裸露的地板上，听不到一丝声响。\n“桌子——果然是那张桌子，”妻子大喊，“比迪，把它搬回来。”\n“哦，不，夫人，求求你，别叫我去，夫人。”比迪哭丧道。\n“蠢货！——老头子，你来搬。”\n“亲爱的，”我说，“桌子我们多的是，何必非要那一张？”\n“那张桌子在哪儿？”妻子喊道，完全无视我温和的反对。\n“在柴房，夫人。我把它有多远就撂多远，夫人。”比迪哭道。\n“是我去一趟柴房，还是你去？”妻子用一种可怕的、公事公办的口吻对我说。\n我立即冲出门外，找到那张苹果木小桌，它正大头朝下搁在一个料斗里。我急忙将它拎回来。妻子再度仔细检查了一番。嘀嗒，嘀嗒，嘀嗒！没错，是桌子在响。\n“夫人，请问，”比迪走进房间，“夫人，请问，能把薪水结给我吗？”\n“脱下你的帽子和披巾，”妻子说，“重新摆桌子。”\n“摆桌子，”我激动地大吼，“摆桌子，否则我叫警察来。”\n“天啊！天啊！”我的两个女儿同时大呼，“我们会变成些什么人？——鬼魂！鬼魂！”\n“你是摆桌子还是不摆？”我走向比迪，喊道。\n“我摆，我摆——遵命，夫人——遵命，老爷——我摆，我摆。鬼魂！——圣母玛利亚！”\n“老头子，”妻子说，“现在我确信，不论是什么东西在嘀嗒嘀嗒响，这声音或这桌子对我们并没有损害。但愿，那是因为我们全都善良虔诚。而且我打定主意，非搞清楚其中缘故不可，我有时间，有耐性，准能办到。只要还在这座宅子里生活一天，我就只用这张桌子吃早餐，所以，坐下来，东西都重新摆好了，让我们安安静静吃顿早饭。亲爱的，”她对朱莉娅和安娜说，“回你们的房间去，平静下来。别再跟孩子似的大呼小叫。”\n有时候，我妻子在家里说一不二。\n早餐期间，妻子徒劳地一次次打开话匣子，徒劳地说些轻松愉快的话题，想让其他人也像她一样快活有生气。朱莉娅和安娜的脑袋耷拉在她们的茶杯上方，仍旧倾听着嘀嗒声。必须承认，我也受到她们的传染。可是，有一阵子，什么也听不见。要么是嘀嗒声已经彻底消失，要么是它太过轻微，而街头的喧嚣不断增长，再加上白昼的混响，这与夜间和清晨的宁谧形成了强烈反差，因此将那道声音盖住。我们藏在心底的不安让妻子非常恼火，也让她毫无惧意的形象更为光辉。吃完早餐，她拿来我的怀表，放在桌子上，并以开玩笑的挑衅语调对所谓的鬼魂说：“来啊，继续嘀嗒响啊，看看谁嘀嗒得更大声！”\n那天我有事外出，却一直在思索那张神秘的桌子。难道科顿·马瑟所言不虚？世上真有鬼魂？而且会附在一张茶桌上？撒旦竟敢在一个清清白白的家庭里显露他的马蹄足？想到自己不顾女儿的严重警告，执意将恶魔的象征摆在那儿，我突然一阵颤抖。是的，三只马蹄足。但接近中午时，这种感觉开始消失。在街上与那么多大活人反复挨挤，令我不再胡思乱想。我记得，昨晚或今早我可没有这么勇敢地解放自己。我决心重新去赢回妻子的好感。\n为了表现得非常积极，喝过茶，玩过三局惠斯特牌11之后，而且此刻听不见嘀嗒声——这使我备感鼓舞——我点上烟斗，说接下来该睡觉了，再将椅子挪到壁炉前，脱掉拖鞋，把脚搁在壁炉的围栏上，气定神闲的样子就如同老德谟克利特12身处阿布底拉13的墓地中一般，那是一天深夜，城里顽皮的孩子们装妖作怪，企图吓唬意志坚定的哲学家。\n我还想到，面对此等情境，这位卓越的老先生以自己的举动为所有时代树立了榜样。他在那个阴森恐怖的时刻仍专注于研究学问，听见奇怪的声响，他没有从书页上移开目光，只淡淡说道：“孩子们，小调皮，回家去吧。这里不是耍闹的地方。你们会着凉的。”上述词句蕴含的哲理是：它们暗示了意料之中的结论，即我们对任何可能的灵异现象的任何可能的探查皆属荒谬。神志健全之人一看到这些事情，会本能地认定它们是装神弄鬼，丝毫不值得关注，尤其是此类现象出现在墓地时，而墓地又格外寂静冷清、死气沉沉。顺便提一句，老先生正是看中这些特质，才将阿布底拉的墓地当成了自己研究学问的场所。\n眼下我孤身一人，周围悄无声息。我放下烟斗，并不觉得此刻自己足够镇定，可以全然沉醉其间。我拿起一张报纸，借着炉旁小烛台放射的光芒，以一种紧张兮兮、匆忙潦草的方式开始阅读。至于苹果木桌子，我近来才发现它太矮，不适合做一张读书桌，那晚上我最好别用它干这个。但它离我不远，摆在屋子中央。\n尽管我努力读报，却不大成功。不知为什么，我似乎全神贯注于听，而根本没有在看。我竖着耳朵，专心致志。很快，寂静被打破了。\n嘀嗒，嘀嗒，嘀嗒！\n虽然并非第一次听到这个声音，不，应该说虽然我特意留下来等待这个声音，可是，当它出现时，似乎还是让我始料未及，好像隆隆炮声从窗外传来。\n嘀嗒！嘀嗒！嘀嗒！\n我坐着一动不动，竭力想控制——如果可能——自己最初的惊慌情绪。然后我离开座椅，颇为镇定地望着那张桌子，颇为镇定地向它走去，颇为镇定地举起它，又轻轻放下。我就这么举起放下，每次间隔那么一会儿，屏息谛听。同时，在内心深处，惊恐与哲学的较量仍未见分晓。\n嘀嗒！嘀嗒！嘀嗒！\n嘀嗒声以令人惊骇的清晰在夜间响起。\n我脉搏狂震，心脏剧烈跳动。若非德谟克利特在这一刻施以援手，我真不知道该怎么办才好。说来惭愧，我自言自语道，如果一个如此美妙的哲学范例不可以效法，那么它还有何益处？我决意直接模仿它，甚至模仿老圣人的言行和态度。\n我重新坐到椅子上阅读报纸，背对那张桌子，长久不动，仿佛埋首于研究。而嘀嗒声仍在持续，我极力以漠然、冷淡的嘲讽语气慢吞吞说道：“响吧，响吧，嘀嗒响吧，小家伙，今晚真够来劲的。”\n嘀嗒！嘀嗒！嘀嗒！\n此刻的嘀嗒声里似乎暗含着揶揄轻蔑。它好像十分欢悦，原因是本人刚才的表演收效甚微。然而，尽管遭到奚落，这份奚落却只会让我坚持下去。我拿定主意，绝不削弱言辞之锋利。\n“响吧，响吧，你越来越闹腾了，嘀嗒响吧，小家伙，真够搞笑的——该歇一歇啦。”\n话音方落，嘀嗒声便停止了。命令执行得如此精准，简直前所未见。就算天塌下来，我也要转过身去，面对那张桌子，如同面对一个能跟你有问有答的活物。这时候——我该不该相信自己的感官？——我看到什么东西在桌面上移动，或者扭动，或者蠕动。它像萤火虫一样发光。我下意识地攥紧了手中的拨火棍，但想到用拨火棍去打一只萤火虫非常荒唐，于是又把它放下。说不准我到底恍恍惚惚地坐了多久，看了多久，反正我假装云淡风轻而内心里波澜万丈。最终，我站起来，将外套从上往下扣好，突然勇猛地迈出大步，直奔那张桌子。结果呢，千真万确，我看到桌面上接近中央的位置有一个不规则的小孔，或者毋宁说类似于一个蛀蚀的小洞，发光的东西（不管它是什么）在里面极力要挣脱束缚（犹如蝴蝶破茧而出）。它动来动去的架势，显然是生物。我愣愣站着，思忖：这就是所谓的鬼魂？就是它？不，我一定是在做梦。我把目光移至壁炉的火焰上，随即又回到桌子上的苍白光芒。我看见的并不是幻象，而是真正的奇迹。震动不断加剧，此时，德谟克利特再一次使我振作精神。即便这闪烁感觉上是超自然现象，我仍努力以纯粹的科学眼光去观察它。如此一来，它又显得像是一类未知的发光小甲壳虫或小飞虫，另外，我认为，它还能发出某种声响。\n我仍在注视它，而且越来越冷静。它也仍在不停挣扎，闪闪发亮。有一阵子，它几乎就要逃出樊笼。我灵机一动，跑去拿了一只平底玻璃杯来，罩在这虫子上面，不让它飞走。\n我透过平底玻璃又看了好一会儿，随后转身离开，心安理得地回房睡觉。\n当时，我无论如何也无法理解这个现象。活生生的虫子从一张死气沉沉的桌子里钻出来？发光的虫子从一块天知道在阁楼上存放了多少年的老旧木料里钻出来？你听说过，或至少梦见过这样的事情吗？虫子是怎么进去的？没关系。我想到了德谟克利特，并决心保持冷静。反正，嘀嗒声的谜团解开了。那不过是虫子啃出一条生路时噬咬、掏挖、敲打的动静。嘀嗒声已经永远消失，令人满意。我要从中捞到些赞扬，不让这个机会轻易溜走。\n“太太，”第二天早上，我说，“你再也不必苦恼我们的桌子嘀嗒作响了。我把一切都解决了。”\n“真的吗，老头子。”她有点儿怀疑。\n“是的，太太，”我稍嫌自负地答道，“我给嘀嗒声来了一记巨石压顶。跟你打包票，那嘀嗒声往后不会来烦你了。”\n妻子请求我解释一番，可是白费功夫。我才不管她。此前我一度暴露自己的胆怯，为了扳回一城，如今我留下想象空间，让她好好猜一猜本人消灭嘀嗒声的英雄业绩。这是一个靠沉默来实施的诡计，既无恶意，也无损害，而且我认为，还相当有效。\n但我去吃早饭时，看到妻子又一次在桌子旁跪下来，我的两个女儿看上去比原先还要害怕十倍。\n“你干吗跟我吹牛皮？”妻子怒道，“你应该知道那很容易被戳破。瞧瞧这个裂缝。嘀嗒声也没停下来，反倒更响亮。”\n“不可能。”我大呼。可仔细一听，嘀嗒！嘀嗒！嘀嗒！确实嘀嗒声还在。\n我竭尽全力恢复了常态，询问虫子的情况。\n“虫子？”朱莉娅尖叫道，“天啊，爸爸！”\n“我希望，先生，你没把臭虫带进这座宅子。”妻子语气严肃。\n“那个虫子，虫子！”我喊道，“平底玻璃杯下面的虫子。”\n“平底玻璃杯下面的虫子！”姑娘们喊道，“不是我们的平底玻璃杯吧，爸爸？你没把虫子放进我们的平底玻璃杯里吧？哦，这到底——到底是什么意思？”\n“你们看到这个小孔，看到这条裂缝了吗？”我指着那地方说。\n“看到了，”妻子说，极为不满，“它怎么来的？你对桌子做了什么？”\n“你们看没看到这条裂缝？”我气呼呼地重复。\n“看到了，看到了。”朱莉娅说，“它真够吓人的。瞧着就像巫术弄成的。”\n“鬼魂！鬼魂！”安娜喊道。\n“安静！”妻子说，“请继续，先生，跟我们讲讲，这条裂缝有什么蹊跷。”\n“太太，女儿们，”我严肃道，“昨天晚上，我一个人坐在客厅，从这条裂缝或者小洞里，钻出一只美妙的……”\n说到此处，我不由自主停下来，陶醉于朱莉娅和安娜满脸的期待以及灼灼的目光。\n“一只什么？一只什么？”朱莉娅喊道。\n“一只虫子，朱莉娅。”\n“一只虫子？”妻子喊道，“一只虫子从桌板里钻出来？你对它做了什么？”\n“用一只平底玻璃杯罩住了它。”\n“比迪！比迪！”妻子走到门口喊道，“你打扫房间时，在桌子上看见过一只平底玻璃杯吗？”\n“当然看见了，夫人，里边还有一只讨厌的虫子。”\n“你怎么处理它的？”我问。\n“把虫子丢进了火里，老爷，然后把平底玻璃杯反复洗了好多遍，夫人。”\n“那只平底玻璃杯在哪儿？”安娜喊道，“希望你擦过，总之留下过记号。我绝不用那只杯子喝水。比迪，永远别把它拿到我跟前。一只虫子——虫子！啊，朱莉娅！啊，妈妈！我觉得它爬遍了我全身，眼下也正在爬！这邪乎的桌子！”\n“鬼魂！鬼魂！”朱莉娅喊道。\n“孩子们，”她俩的母亲说，眼神中透着威严，“回房间去，恢复一些理智了再出来。难道一只虫子，就可以把你们原本拥有的一丁点儿智识全吓没了？离开客厅。真让我吃惊。你们的幼稚举动使我很难过。”\n“现在，告诉我，”两个女儿一走，她立即对我说，“一五一十告诉我，从桌面的这条裂缝里当真钻出了一只虫子？”\n“太太，的确如此。”\n“你亲眼看见它钻出来？”\n“没错。”\n她俯向那条裂缝，认真观察。\n“你确定？”她抬头问道，依然弯着腰。\n“确定，我确定。”\n她沉默不语。我觉得，事物的神秘甚至也开始对她产生影响。是啊，我思忖，眼下我本该看到妻子浑身发抖，天知道会不会喊来一个老牧师给桌子驱魔，将鬼魂赶跑。\n“我打算这么干。”她突然说，表情相当兴奋。\n“什么，太太？”我极为迫切地问道，期待听到一个神奇的主意，“你要干什么？”\n“我要用以前听说过的一款大名鼎鼎的蟑螂粉，把这张桌子里里外外擦个遍。”\n“好家伙！那么说你不认为是鬼魂在作祟？”\n“鬼魂？”\n她加重的语气充满了轻蔑的怀疑之意，比之德谟克利特本人也不遑多让。\n“可是这嘀嗒声，这嘀嗒声呢？”我说。\n“我会把它烤出来的。”\n“唉，唉，太太，”我说，“你别走到另一个极端去啊。不管是抹蟑螂粉，还是搁到火上烤，都没办法救这张桌子。你不能否认，太太，它是一张古怪的桌子。”\n“那么我会它把擦干净，”她回答，“好好擦个通透。”妻子随即叫来比迪，要她给桌子打蜡，刷洗，让它焕然一新。做完了这一切，桌布重新铺好，我们坐下来吃早餐。不过两个女儿并未露面。朱莉娅和安娜当天没吃早餐。\n撤掉桌布之后，妻子高效地展开工作，用一种深色的胶剂将桌面上的小孔彻底封死。\n两个女儿脸色苍白，那天早上我坚持要带她们去散步，于是有了以下交谈。\n“爸爸，我对于那张桌子最糟糕的预感正在变成现实，”朱莉娅说，“它的马蹄足杵到我肩膀上，这样一个暗示并不是无缘无故的。”\n“净胡扯，”我说，“我们去布朗夫人餐馆，买个冰激凌。”\n眼下德谟克利特的精神在我身上越发旺盛。它随着阳光的增强而增强，奇妙的巧合。\n“但真够神的，”安娜说，“虫子怎么会从一张桌子里钻出来？”\n“没什么，我的女儿。虫子从木头里钻出来，这很平常。你肯定见过它们从壁炉里那些劈柴的一端钻出来。”\n“啊，可是这类木头几乎是刚从林中砍下来的。而那张桌子至少有一百年了。”\n“那又如何？”我快活说道，“在岩块内部，不也发现过极其古老的活蟾蜍吗？”\n“随便你怎么讲，爸爸，反正我觉得是鬼魂，”朱莉娅说，“当机立断，亲爱的爸爸，把那张闹鬼的桌子从家里弄走吧。”\n“净胡扯。”我说。\n她俩越是害怕，我越是胆壮，又一个奇妙的巧合。\n夜幕降临。\n“这嘀嗒声，”妻子说，“你觉得是另一只虫子在继续打洞吗？”\n很奇怪，我原先从未考虑过这个问题。我可没想到会有双胞胎虫子。但现在，天知道，说不定还有三胞胎虫子。\n我决定防患于未然，再者，如果第二只虫子即将现身，得确保它安全无虞。夜间，嘀嗒声重新响起。十点钟左右，我靠耳朵找到发声的大致区域，往上边罩了一只平底玻璃杯。随后我们回房休息，并把香柏木客厅锁好，钥匙揣在我裤袋里。\n第二天早晨，桌子上什么也没有，可依然能听见嘀嗒声。两个女儿又开始害怕。她们想上邻居家待着，但妻子大力反对。我们将成为整个镇子的笑柄。所以我们一致同意，家丑不可外扬。比迪受到严格的限制，而且，为了确保她不向牧师走漏消息，那个星期我们不许她去忏悔。\n我一整天足不出户，每隔一两个小时就仔细观察桌子一次，又是听又是看。随着夜晚来临，我觉得嘀嗒声越来越清晰，而且木板上凭耳朵圈定的发声区域也越来越狭小。另外我还觉得，在我倒扣平底玻璃杯的地方，可以观察到一阵微弱的搏动，或者是木头的鼓胀。为了不再瞎猜，妻子建议用刀子把那儿的桌面切开，但我有一个稍具耐心的计划，亦即她和我在桌子旁坐一晚，因为从刻下的状况来判断，虫子很可能在天亮之前钻出木板。对我而言，目睹它来到世间是很有意思的事情，好比破壳小鸡的第一次耀眼亮相。\n这个主意打动了我妻子。她坚持要朱莉娅和安娜也参与进来，好让两个女儿亲眼见识一番，抛弃所有荒谬幼稚的观念。在我妻子看来，什么鬼魂在嘀嗒作响啦，什么鬼魂可以从虫子身上跑到她们身上啦，尽是愚蠢到无以复加的妄想。确实，她没法解释这个现象，但她坚信有答案，而且迟早会找到答案，该答案也完全能够让她满意。我妻子并不知道，她其实是个女德谟克利特。至于我本人，目前的认识还很含混。在德谟克利特和科顿·马瑟之间，我正以一种既奇特又让人讨厌的方式轻轻摆荡。不过，在妻子和女儿眼里，我是个纯粹的德谟克利特主义者，对所有茶桌鬼魂不屑一顾。\n于是乎，我们准备了充足的蜡烛和饼干，四个人一同坐在桌子旁，围着它熬夜。有好一阵子，我和妻子大聊特聊，两个女儿却一声不吭。此后我和妻子又想玩他一局惠斯特牌。可是女儿们完全打不起精神，结果我们等于跟两个名副其实的木偶在打牌。妻子赢了一局，但赢得很没劲，索性也将扑克牌丢到了一边。\n十一点半。看不到虫子的影子。蜡烛开始变暗。妻子正打算掐灭它们，突然间传来一阵狂暴、空洞、洪亮的隆隆巨响。\n朱莉娅和安娜一跳三尺高。\n“万事平安！”街头有个声音大喊。是守夜人。他先拿棍棒敲打石子路面，继而来上那么一句极其令人安心的吆喝。\n“万事平安！姑娘们，听到了吗？”我高兴道。\n事实上，跟三个女人为伴，我感觉自己像布鲁斯14一样充满勇气，这可真让人吃惊，而两名姑娘几乎吓傻了。\n我起身去拿烟斗，吐了一口饱含哲思的烟雾。\n永远应选择德谟克利特，我想。\n在深沉的静默中，我坐着抽烟。这时候，你听！——嘭！嘭！嘭！——正好是桌子下面，嘭嘭声大作。\n这一次，我们四个统统一跳三尺高，我的烟斗摔裂了。\n“天啊！是什么在响？”\n“鬼魂！鬼魂！”朱莉娅喊道。\n“啊，啊，啊！”安娜喊道。\n“真丢人，”妻子说，“是地窖里新装瓶的苹果酒炸开了。今天我告诉过比迪，要用绳子捆好。”\n以下是我从那天晚上的记录中转抄的字句：\n一点钟。无虫子踪迹。嘀嗒声仍在持续。太太越来越困。\n两点钟。无虫子踪迹。嘀嗒声断断续续。太太已熟睡。\n三点钟。无虫子踪迹。嘀嗒声相当稳定。朱莉娅和安娜越来越困。\n四点钟。无虫子踪迹。嘀嗒声有规律，但不激烈。太太、朱莉娅和安娜均在椅子上熟睡。\n五点钟。无虫子踪迹。嘀嗒声微弱。我昏昏欲睡。其他人仍在睡觉。\n笔录到此为止。\n——梆！梆！梆！\n大门传来一阵可怕、不祥的敲打声。\n我们从梦中惊醒，起身站立。\n梆！梆！梆！\n朱莉娅和安娜连连尖叫。\n我缩在墙角。\n“你们这些笨蛋，”妻子喊道，“是面包师来送面包。”\n六点钟。\n妻子去拉开百叶窗，还没弄完，便听到朱莉娅一声大呼。桌板上，虫子半藏半露，正扭动不已，像颗火蛋白石一样照亮了昏暗的房间。\n即使这只虫子佩有一柄小小的利剑——一柄大马士革剑，脖子上再挂一串小小的项链——一串钻石项链，并且手中握着一支小枪——一支黄铜枪，嘴巴里还塞着一份手稿——一份占星术手稿，即使如此，朱莉娅和安娜也不会更加痴迷了。\n千真万确，这是一只漂亮的虫子——一只犹太珠宝商的虫子——一只闪耀如夕晖的虫子。\n朱莉娅和安娜从没想到会有那么一只虫子。她们原以为，虫子即丑陋的同义词。然而这只虫子堪称虫子中的炽天使。甚至，它就是美丽的化身，因为它如此美丽，宛似蝴蝶。15\n朱莉娅和安娜仔细看了又看。她们不再紧张兮兮。她们满心欢喜。\n“可是，这个奇特、漂亮的生灵是怎么钻进桌子里的？”朱莉娅问道。\n“精灵想去哪儿就去哪儿。”安娜回答。\n“哼！”妻子道。\n“你们还能听见嘀嗒声吗？”我说。\n她们竖起了耳朵，不过什么也没听到。\n“好吧，太太，女儿们，现在一切都结束了，今天上午我得去好好查一查这件事。”\n“哦，去吧，爸爸，”朱莉娅说，“去问一问帕齐太太，那个巫女。”\n“最好去问约翰逊教授，那位博物学家。”妻子说。\n“好极了，德谟克利特夫人，”我说，“我去找约翰逊教授。”\n很幸运，这位教授没出门。我简单讲了讲事情的原委，他颇有兴趣，又颇为冷静而镇定，并且郑重其事地跟我回家。我们向他展示了那张桌子、那两个小洞、那只虫子，又描述了事件的种种细节。我妻子和两个女儿均在场。\n“好了，教授，”我问道，“你怎么看？”\n戴上眼镜，这位博学的教授盯着桌子，用刀子轻轻在小洞里刮铲，但什么也没说。\n“这事情，并不寻常？”安娜焦急问道。\n“很不寻常，小姐。”\n朱莉娅和安娜交换了一个意味深长的眼神。\n“可这非常美妙，对吧？”朱莉娅问道。\n“非常美妙，小姐。”\n两个女儿交换了一个更加意味深长的眼神。受到鼓舞，朱莉娅再次开腔说话。\n“先生，您一定不承认，在这事情上发挥作用的，是鬼……”\n“鬼魂？不是。”回答不容辩驳。\n“女儿们，”我轻声道，“你俩应该清楚，回答你们提问的可不是巫女帕齐太太，而是知名的博物学家，约翰逊教授。好了，教授，”我补充说，“请您指教，让我们也长长见识。”\n我不再逐字逐句复述这位博学绅士的讲解，实际上，他虽然说得明白无误，言辞却有失单调——我将他的阐释总结如下，想来应该足够了。\n此事并非孤例。那张桌子的材质是苹果木，很受各种昆虫的欢迎，它们飞进果园，飞到活树上，把卵产在树皮下面。仔细检查最后一只虫子钻出桌面的地方，会发现它咬穿了一寸半的木头，而根据这一厚度所包含的木质层数，可以推算出桌板的木质总层数，再合理估测加工时削去的层数，则不难判断，虫卵产下的时间差不多是在苹果树遭砍伐的九十年以前。但从树木倒下到今天，又流逝了多少光阴？这张桌子的样式极其老旧。姑且认为它有八十年的历史吧，那么虫卵就存在了一百七十年。至少，这是约翰逊教授的计算。\n“朱莉娅啊，”我说，“听完这件事的科学解释（虽然，我承认，我并不完全明白），你还信是鬼魂作祟？它确实很奇妙，可鬼魂在哪里？”\n“是啊，在哪里？”妻子说。\n“如今她可不把这个纯粹的自然现象跟那些见神见鬼的浅陋说法联系到一起了，对吧？”博学的教授语带讥讽评论道。\n“随便你们怎么讲，”朱莉娅说，拿起瓶底玻璃杯里那枚莹莹发亮、光芒四射、璀璨夺目的鲜活蛋白石，“随便你们怎么讲，就算这个美丽的生物不是魂灵，它依旧让我们感受到超自然世界的力量。你看，经过一百七十年的休眠，这只小小的虫子终于来到世间，它那么灿烂，难道其中不含一星半点人类灵魂的辉煌复生？鬼魂！鬼魂！”她欣喜若狂，大叫道，“我依然相信神灵，只不过我现在满怀愉悦地相信它们，而以前我一想到它们就感到害怕。”\n那只神秘的昆虫，它没能让自己绚丽的生命延续多久，第二天便死去了。但姑娘们将它保存下来，装进一只银质的香盒里，放在苹果木桌子上，置于香柏木客厅的两扇窗户之间。\n如果哪位女士怀疑这个故事，我的两个女儿会很乐意向她展示那只虫子和那张桌子，并且指给她看，在后者经过修补的桌板上，有两个以蜡滴封好的小洞，它们正是两只虫子钻成的，这多少有点儿像人们在布拉托街教堂16标出了它被炮弹击中的地方。\n  此篇原题“The Apple-Tree Table”，1856年5月首刊于《普特南氏月刊》 （Putnam’s Monthly Magazine）。——译者注（本书注释，均为译者所加，以下不再逐一标明） \u0026#x21a9;\u0026#xfe0e;\n 培根修士（Friar Bacon），应指罗杰·培根（Roger Bacon，约1214—1293），英国修士，唯名论者，有唯物主义倾向的哲学家和自然科学家，知识广博，素有“奇异博士”之称。 \u0026#x21a9;\u0026#xfe0e;\n 雅各的梯子（Jacob’s ladder），典出《旧约》，象征通往神圣和幸福的途径。 \u0026#x21a9;\u0026#xfe0e;\n 据欧洲民间传说，浮士德博士（Doctor Faust）将灵魂出卖给魔鬼梅菲斯特（Mephistopheles），才创造出了许多奇迹。 \u0026#x21a9;\u0026#xfe0e;\n 科顿·马瑟（Cotton Mather，1663—1728），北美清教牧师，马萨诸塞的领袖人物。 \u0026#x21a9;\u0026#xfe0e;\n 《辉煌业绩》（Magnalia），全名为《基督在北美的辉煌业绩》（Magnalia Christi Amricana），是科顿·马瑟在1702年出版的一本著作。该书详尽记述了开拓新英格兰殖民地的历程，鼓吹清教徒遵循上帝的旨意到荒原上建立神圣国度。 \u0026#x21a9;\u0026#xfe0e;\n 畿尼（guinea），英国的旧金币，值一镑一先令。 \u0026#x21a9;\u0026#xfe0e;\n “福克斯姑娘”（Fox Girls），又称为“福克斯姐妹”（Fox Sisters），指十九世纪美国纽约姓福克斯的三姐妹，她们分别是利亚·福克斯（Leah Fox，1831—1890）、玛格丽特·福克斯（Margaret Fox，1833—1893）、凯瑟琳·福克斯（Catherine Fox，1837—1892），三人创建了神秘主义派别唯灵派（Spiritualism）。 \u0026#x21a9;\u0026#xfe0e;\n 拉德克利芙夫人（Mrs Radcliffe），即安·拉德克利芙（Ann Radcliffe，1764—1823），英国小说家，以创作浪漫主义的哥特小说见长，作品融恐怖、悬念和浪漫气息于一体。 \u0026#x21a9;\u0026#xfe0e;\n 约翰逊博士（Dr. Johnson），指塞缪尔·约翰逊（Samuel Johnson，1709—1784），英国作家、评论家。于1755年编成《英语大辞典》，牛津大学给他颁发荣誉博士学位，因此人们称他为“约翰逊博士”。 \u0026#x21a9;\u0026#xfe0e;\n 惠斯特牌（whist），类似于桥牌的纸牌游戏。 \u0026#x21a9;\u0026#xfe0e;\n 德谟克利特（Democritus，约公元前460—370），古希腊哲学家。 \u0026#x21a9;\u0026#xfe0e;\n 阿布底拉（Abdera），古希腊色雷斯的海滨城市，德谟克利特的出生地。传说德谟克利特常去一些荒凉之处，或者待在墓地中，以激发想象力。 \u0026#x21a9;\u0026#xfe0e;\n 布鲁斯（Bruce），应指罗伯特·布鲁斯（Robert the Bruce，1274—1329），苏格兰国王，领导苏格兰打败了英格兰，赢得民族独立。被称为“勇敢的心”（Braveheart）。 \u0026#x21a9;\u0026#xfe0e;\n “甚至……蝴蝶”一句的原文为“or, rather, all it had of the bug was the B, for it was beautiful as a butterfly”。这是一个文字游戏，直译为“B就是这只虫子所具有的一切，因为它美丽如蝴蝶”。“美丽”（beautiful）和“蝴蝶”（butterfly）的英文单词首字母大写均为“B”，故作者会如此说。 \u0026#x21a9;\u0026#xfe0e;\n 布拉托街教堂（Brattle Street Church），美国波士顿市的一座教堂，建于十七世纪末，十九世纪七十年代拆除。该教堂原有一座方塔，嵌着一枚炮弹，传说是美国独立战争时期，美军攻占波士顿时发射的。 \u0026#x21a9;\u0026#xfe0e;\n   ","date":"2021-06-06T00:00:00Z","image":"https://gitee.com/Heaciy/img/raw/master/post/photo-1524591282491-edb48a0fca8f.jpg","permalink":"https://heaciy.com/p/the-apple-tree-table/","title":"苹果木桌子"},{"content":" 作者👨‍💻：Pablo Iglesias 时间🕐：2018/06/27 原文链接🌐：https://www.bedjango.com/blog/top-6-django-decorators/ 声明👉：本文为转载，仅作为个人学习记录\n What is a Decorator? A decorator is the name of one of the most popular design patterns used nowadays, many times we use it without knowing that we are using a design pattern. And what\u0026rsquo;s so special about this pattern? As we can read at Python Wiki using It is a way of apparently modifying an object\u0026rsquo;s behavior, by enclosing it inside a decorating object with a similar interface. You can get more information about Pattern Design here.\nWhy I should use decorators in my web application? Decorators dynamically alter the functionality of a function, method or class without having to make subclasses or change the source code of the decorated class. Thanks to this our code will be more cleaner, more readable, maintainable (Which is no small thing), and reduce the boilerplate code allowing us to add functionality to multiple classes using a single method. A good example of the importance and easy of use of these decorators can be seen in the decorator @login_required that provides django, and that you probably used if you have some experience with our favorite framework. It’s just a piece of code where we check if the user is not authenticated the user is redirected to the login url.\nThe way that the decorators as used is the following:\nfrom django.contrib.auth.decorators import login_required @login_required def my_view(request) … Each time that a user try to access to my_view, the code inside login_required will be ejecuted.\nSome of our favorite decorators In this section we will show you some of the decorators that we think are most useful or that we have ever used with positive results, keep in mind that many of these can be customized to suit your needs. For this post we will use the original decorators with their font.\nGroup Required Sometimes we need to protect some views, to allow a certain group of users to access it. Instead of checking within it if the user belongs to that group/s, we can use the following decorator\nfrom django.contrib.auth.decorators import user_passes_test def group_required(*group_names): \u0026#34;\u0026#34;\u0026#34;Requires user membership in at least one of the groups passed in.\u0026#34;\u0026#34;\u0026#34; def in_groups(u): if u.is_authenticated(): if bool(u.groups.filter(name__in=group_names)) | u.is_superuser: return True return False return user_passes_test(in_groups) # The way to use this decorator is: @group_required(‘admins’, ‘seller’) def my_view(request, pk) ... You can get more information about it here\nAnonymous required This decorator is based on the decorator login_required of Django, but looks for the opposite case, that the user is anonymous, otherwise the user is redirected to the website defined in our settings.py and can be useful when we want to protect logged user views, such as the login or registration view\ndef anonymous_required(function=None, redirect_url=None): if not redirect_url: redirect_url = settings.LOGIN_REDIRECT_URL actual_decorator = user_passes_test( lambda u: u.is_anonymous(), login_url=redirect_url ) if function: return actual_decorator(function) return actual_decorator # The way to use this decorator is: @anonymous_required def my_view(request, pk) ... You can get more information about it here\nSuperuser required This is the same case as when we want to allow certain groups access to a view, but in this case only super users can visit it.\nfrom django.core.exceptions import PermissionDenied def superuser_only(function): \u0026#34;\u0026#34;\u0026#34;Limit view to superusers only.\u0026#34;\u0026#34;\u0026#34; def _inner(request, *args, **kwargs): if not request.user.is_superuser: raise PermissionDenied return function(request, *args, **kwargs) return _inner # The way to use this decorator is: @superuser_only def my_view(request): ... You can get more information about it here\nAjax required This decorator check if the request is an AJAX request, useful decorator when we are working with Javascript frameworks as jQuery and a good way to try to secure our application\nfrom django.http import HttpResponseBadRequest def ajax_required(f): \u0026#34;\u0026#34;\u0026#34; AJAX request required decorator use it in your views: @ajax_required def my_view(request): .... \u0026#34;\u0026#34;\u0026#34; def wrap(request, *args, **kwargs): if not request.is_ajax(): return HttpResponseBadRequest() return f(request, *args, **kwargs) wrap.__doc__=f.__doc__ wrap.__name__=f.__name__ return wrap # The way to use this decorator is: @ajax_required def my_view(request): ... You can get more information about it here\nTime it This decorator is very helpful if you need to improve the response time of one of then our views or if you just want to know how long it takes to run.\ndef timeit(method): def timed(*args, **kw): ts = time.time() result = method(*args, **kw) te = time.time() print(\u0026#39;%r(%r, %r) %2.2fsec\u0026#39; % (method.__name__, args, kw, te - ts)) return result return timed # The way to use this decorator is: @timeit def my_view(request): ... You can get more information about it here\nCustom Functionality The next decorator is just an example about how you can check some permissions or some checks in a easy way and 100% customizable.\nImagine you have a blog, shop, forum\u0026hellip;. Where users need to have a number of points in order to write a review, it would be a good way to avoid SPAM for example. We\u0026rsquo;ll create a decorator to check that the user is logged in and has more than 10 points, so you could write a review, otherwise we\u0026rsquo;ll raise a Forbidden\nfrom django.http import HttpResponseForbidden logger = logging.getLogger(__name__) def user_can_write_a_review(func): \u0026#34;\u0026#34;\u0026#34;View decorator that checks a user is allowed to write a review, in negative case the decorator return Forbidden\u0026#34;\u0026#34;\u0026#34; @functools.wraps(func) def wrapper(request, *args, **kwargs): if request.user.is_authenticated() and request.user.points \u0026lt; 10: logger.warning(\u0026#39;The {} user has tried to write a review, but does not have enough points to do so\u0026#39;.format( request.user.pk)) return HttpResponseForbidden() return func(request, *args, **kwargs) return wrapper You can get more information about it asking myself at piglesias@emergya.com or via twitter @pypiglesias. I really hope you found the post interesting or at least curious. From BeDjango we would like to encourage you to share your decorators, ideas or questions as well as interesting topics for future posts\n 参考链接  python decorator  ","date":"2021-02-14T00:00:00Z","image":"https://gitee.com/Heaciy/img/raw/master/post/photo-1505322033502-1f4385692e6a.jpg","permalink":"https://heaciy.com/p/top-6-django-decorators/","title":"Top 6 Django Decorators"},{"content":"所以到底应该是说新年快乐呢还是元旦快乐呢？ 元旦快乐好像不是很好听，新年快乐的话那过年的时候说啥呢？\n愿望太多那就先面向抽象许个愿：🎈🎊🎉愿新年，胜旧年🎈🎉🎊\n愿：\n 六级、系统分析师、系统架构师、考研都能取得好成绩 愿家人、朋友还有自己都能开开心心、健健康康的生活，平安喜乐  P.s. 我发现从小到大我都有这样一种感觉，2019的年末的时候在想，2020听上去好奇怪的感觉……但是到了2020的一刹那又好像突然什么都习惯了，心里也接受了这是新的一年了。 就在昨晚我还在想2021读着一点都不顺，到了今早 1月1号，“现在就应该是2021……”\n新的一年，也请继续加油，继续努力\n","date":"2021-01-01T00:00:00Z","image":"https://heaciy.com/p/happy-new-year-2021/happy-new-year-2021_hu3d03a01dcc18bc5be0e67db3d8d209a6_43916_120x120_fill_q75_box_smart1.jpg","permalink":"https://heaciy.com/p/happy-new-year-2021/","title":"Happy New Year"},{"content":"from typing import Tuple # char: 单字符,形如\u0026#39;h\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;k\u0026#39; # word: 词,形如\u0026#34;hack\u0026#34; class TrieNode(object): \u0026#34;\u0026#34;\u0026#34; 字符节点 \u0026#34;\u0026#34;\u0026#34; def __init__(self, char: str): self.char = char # 存储的字符 self.children = [] # 该节点的子节点 self.word_finished = False # 是否是词尾 self.counter = 1 # 出现在word中的次数 def add(root, word: str): \u0026#34;\u0026#34;\u0026#34; 向字典树中添加词 \u0026#34;\u0026#34;\u0026#34; node = root # node的初始值为root节点* for char in word: # 遍历整个word found_in_child = False # 标记当前char是否在node的子结点列表中 for child in node.children: if child.char == char: # node节点的子节点中包含当前的char child.counter += 1 # 该字符在word中出现的次数加一 node = child # node向下移动一位,即为当前字符 found_in_child = True # 标记为找到 break if not found_in_child: # 当前字符不在node的子节点列表中,则新建一个节点加入到node的子节点列表中 new_node = TrieNode(char) node.children.append(new_node) node = new_node # node移至当前节点 # 当word中所有字符被遍历完后,node即为最后一个字符,将其标记为词尾 node.word_finished = True def find_profix(root, prefix: str) -\u0026gt; Tuple[bool, int]: \u0026#34;\u0026#34;\u0026#34; 检查并返回: 1. 该前缀是否出现在添加过的词中 2. 如果是,那么有多少词组包含该前缀 \u0026#34;\u0026#34;\u0026#34; node = root if not root.children: # 如果当前节点无子节点则直接返回(False,0) return False, 0 for char in prefix: # 遍历prefix中的字符 char_not_found = True # 标记当前字符是否出现在node的子节点列表中,默认为True for child in node.children: if child.char == char: # 如果当前字符包含在node的子结点中 char_not_found = False node = child # node向前移一位,即移至当前字符的位置 break if char_not_found: # 如果当前字符不在node的子结点中则直接返回(False,0) return False, 0 # 执行至此步则表示prefix的所有字符都出现在字典树中,直接返回True和最后一个字符的counter return True, node.counter def get_all_words(root: TrieNode): \u0026#34;\u0026#34;\u0026#34; 获取Trie中所有的词组 \u0026#34;\u0026#34;\u0026#34; all_words = [] current_word = [] # 递归方式 def tmp(root: TrieNode): for node in root.children: # 遍历当前节点的所有子节点 current_word.append(node.char) # 将当前子节点加入到current_word中 if node.word_finished: # 如果当前字符为词尾 all_words.append(current_word.copy()) # 将当前词组加入到all_words中 if node.children: tmp(node) # 当前子节点有子节点, 继续递归遍历 else: current_word.pop() # 当前子节点无子节点即为词尾,出栈 if current_word: current_word.pop() return tmp(root) # 从根节点开始 return [\u0026#39;\u0026#39;.join(word) for word in all_words] if __name__ == \u0026#34;__main__\u0026#34;: # 构造根节点和字典树 root = TrieNode(\u0026#39;*\u0026#39;) add(root, \u0026#34;hackathon\u0026#34;) add(root, \u0026#34;hack\u0026#34;) # 在字典树中查找 print(find_profix(root, \u0026#34;hac\u0026#34;)) print(find_profix(root, \u0026#39;hack\u0026#39;)) print(find_profix(root, \u0026#39;hackathon\u0026#39;)) print(find_profix(root, \u0026#39;ha\u0026#39;)) print(find_profix(root, \u0026#39;hammer\u0026#39;)) print(get_all_words(root)) # 输出结果为: # (True, 2) # (True, 2) # (True, 1) # (True, 2) # (False, 0) # [\u0026#39;hack\u0026#39;, \u0026#39;hackathon\u0026#39;] 工作原理 算法的主要步骤\n 首先要考虑的是如何将word加入到Trie中, 这也是add方法的职责所在。它的工作方式非常简单。它需要两个参数:root node(即根节点，一般使用*)和word 然后它从单词的第一个字符开始遍历, 一次一个字符 检查当前node的子节点中是否含有该字符 如果有, 则只增加该字符的counter, 以表明该字符是重复出现 如果没有, 则只用简单的将该字符添加到当前node节点的子节点列表中 对于4\u0026amp;5这两种情况, 在考虑下一个字符之前, 都是使用node的child node作为当前节点(这意味着, 当前的child node在下一个循环中将成为node节点)  这就是在Trie中添加一个单词的所有步骤。还需要做的另一件事是在整个过程完成后标记单词的结尾。这意味着Trie的每个叶节点的word_finished属性为True。\n要搜索前缀，只需执行几个简单的步骤\n find_profix函数需要两个参数, root节点和需要搜索的profix 每次从peofix中按循序取一个字符与\u0026quot;当前node\u0026quot;的子节点比较, 找出包含该字符的节点 如果找到了, 则将该子节点作为当前node进行下一轮比较 如果未找到则返回(False, 0)表明在Trie中该前缀不存在 在试图找到一个比单词本身更大的前缀时, 该算法也将返回(False, 0) 如果Trie包含该前缀则返回(True, 该前缀出现在Trie包含的word中的次数)(即在Trie包含的所有词组中有多少个词包含该前缀)   摘自: Meidum: Implementing a Trie in Python\n原作者: Shubhadeep Roychowdhury\n ","date":"2020-12-19T00:00:00Z","image":"https://heaciy.com/p/implementing-a-trie-in-python/trie_hu5ca3eeea9d4841595d42211afa052e1d_72289_120x120_fill_q75_box_smart1.jpeg","permalink":"https://heaciy.com/p/implementing-a-trie-in-python/","title":"Implementing a Trie in Python"},{"content":"import numpy import matplotlib.pyplot import scipy.special %matplotlib inline class neuralNetwork: def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate): # 初始化神经网络 self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes self.lr = learningrate # 学习率 # from node i to node j in the next layer self.wih = numpy.random.normal(0.0, pow(self.hnodes, -0.5), (self.hnodes, self.inodes)) # 权重矩阵 self.who = numpy.random.normal(0.0, pow(self.onodes, -0.5), (self.onodes, self.hnodes)) self.activation_function = lambda x: scipy.special.expit(x) # 应用激活函数 def train(self, inputs_list, targets_list): inputs = numpy.array(inputs_list, ndmin=2).T targets = numpy.array(targets_list, ndmin=2).T hidden_inputs = numpy.dot(self.wih, inputs) hidden_outputs = self.activation_function(hidden_inputs) final_inputs = numpy.dot(self.who, hidden_outputs) final_outputs = self.activation_function(final_inputs) output_errors = targets - final_outputs hidden_errors = numpy.dot(self.who.T, output_errors) self.who += self.lr*numpy.dot((output_errors*final_outputs*(1.0-final_outputs)), numpy.transpose(hidden_outputs)) # 调整隐藏层与输出层之间的权重 self.wih += self.lr*numpy.dot((hidden_errors*hidden_outputs*(1.0-hidden_outputs)), numpy.transpose(inputs)) # 调整输入层与隐藏层之间的权重 def query(self, inputs_list): inputs = numpy.array(inputs_list, ndmin=2).T # 输入矩阵的转置矩阵 hidden_inputs = numpy.dot(self.wih, inputs) hidden_outputs = self.activation_function(hidden_inputs) final_inputs = numpy.dot(self.who, hidden_outputs) final_outputs = self.activation_function(final_inputs) return final_outputs input_nodes = 784 # 28*28，输入层节点数 hidden_nodes = 100 # 隐藏层节点数 output_nodes = 10 # 输出层节点 learning_rate = 0.2 # 学习率 # 生成一个神经网络实例 n = neuralNetwork(input_nodes,hidden_nodes,output_nodes,learning_rate) # 加载训练数据 training_data_file = open(\u0026#34;mnist_dataset/mnist_train.csv\u0026#34;, \u0026#39;r\u0026#39;) training_data_list = training_data_file.readlines() training_data_file.close() # 训练神经网络 epochs = 5 # 训练5个世代(本篇的学习率为0.2，训练数据为六万组，训练五个世代，测试数据为一万组) for e in range(epochs): for record in training_data_list: all_values = record.split(\u0026#39;,\u0026#39;) inputs = (numpy.asfarray(all_values[1:])/255.0*0.99)+0.01 targets = numpy.zeros(output_nodes) + 0.01 targets[int(all_values[0])] = 0.99 n.train(inputs,targets) # 加载测试数据(本篇使用了一万组测试数据，正确率为95.11%，结果可能不大一致，但大概都在94%~95%) test_data_file = open(\u0026#34;mnist_dataset/mnist_test.csv\u0026#34;, \u0026#39;r\u0026#39;) test_data_list = test_data_file.readlines() test_data_file.close() # 测试神经网络 scorecard = [] for record in test_data_list: all_values = record.split(\u0026#39;,\u0026#39;) correct_label = int(all_values[0]) # print(correct_label, \u0026#34;correct lable\u0026#34;) inputs = (numpy.asfarray(all_values[1:])/255.0*0.99)+0.01 outputs = n.query(inputs) label = numpy.argmax(outputs) # print(label, \u0026#34;networks\u0026#39;s answer\u0026#34;) if(label == correct_label): scorecard.append(1) else: scorecard.append(0) pass pass # print(scorecard) # 输出训练成绩 scorecard_array = numpy.asarray(scorecard) print(\u0026#34;performances = \u0026#34;, scorecard_array.sum()*1.0/scorecard_array.size) ","date":"2019-10-13T00:00:00Z","image":"https://images.unsplash.com/photo-1590859808308-3d2d9c515b1a?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026amp;ixlib=rb-1.2.1\u0026amp;auto=format\u0026amp;fit=crop\u0026amp;w=1653\u0026amp;q=80","permalink":"https://heaciy.com/p/neural-network-with-python/","title":"Neural Network With Python"},{"content":"我爱一切的花朵。\n在任何一个千红万紫的花摊上，各色花朵的壮阔交杂，成了都市中最美的点缀。\n其实并不爱花圃，爱的是旷野上随着季节变化而生长的野花和那微风吹过大地的感动。\n生活在都市里的人，迫不得已在花市中捧些切花回家。对于离开泥土的鲜花，总觉对它们产生一种疼惜又抱歉的心理，可是还是要买的。这种对花的抱歉和喜悦，总也不能过分去分析它。\n我买花，不喜欢小气派。不买也罢了。如果当日要插花，喜欢一口气给它摆成一种气势，大土瓶子哗的一下把房子加添了生命。那种生活情调，可以因为花的进入，完全改观。不然，只水瓶中一朵，也有一份清幽。\n说到清幽，在所有的花朵中，如果是想区别“最爱”，我选择一切白色的花。而白色的花中，最爱野姜花以及百合──长梗的。\n许多年前，我尚在大西洋的小岛上过日子，那时，经济情况拮据，丈夫失业快一年了。我在家中种菜，屋子里插的是一人高的枯枝和芒草，那种东西，艺术品味高，并不差的。我不买花。\n有一日，丈夫和我打开邮箱，又是一封求职被拒的回信。那一阵，其实并没有山穷水尽，粗茶淡饭的日子过得没有悲伤，可是一切维持生命之外的物质享受，已不敢奢求。那是一种恐惧，眼看存款一日一日减少，心里怕得失去了安全感。这种情况只有经历过失业的人才能明白。\n我们眼看求职再一次受挫，没有说什么，去了大菜场，买些最便宜的冷冻排骨和矿泉水，就出来了。\n不知怎么一疏忽，丈夫不见了，我站在大街上等，心事重重的。一会儿，丈夫回来了，手里捧着一小把百合花，兴匆匆的递给我，说：“百合上市了。”\n那一剎间，我突然失了控制，向丈夫大叫起来：“什么时间了？什么经济能力？你有没有分寸，还去买花?!”说着我把那束花啪一下丢到地上去，转身就跑。在举步的那一剎间，其实已经后悔了。我回头，看见丈夫呆了一两秒钟，然后弯下身，把那给撒在地上的花，慢慢拾了起来。\n我往他奔回去，喊着：“荷西，对不起。”我扑上去抱他，他用手围着我的背，紧了一紧，我们对视，发觉丈夫的眼眶红了。\n回到家里，把那孤零零的三五朵百合花放在水瓶里，我好像看见了丈夫的苦心。他何尝不想买上一大缸百合，而口袋里的钱不敢挥霍。毕竟，就算是一小束吧，也是他的爱情。\n那一次，是我的浅浮和急躁，伤害了他。以后我们没有再提这件事。\n四年以后，我去上丈夫的坟，进了花店，我跟卖花的姑娘说：“这五桶满满的花，我全买下，不要担心价钱。”\n坐在满布鲜花的坟上，我盯住那一大片颜色和黄土，眼睛干干的。以后，凡是百合花上市的季节，我总是站在花摊前发呆。\n一个清晨，我去了花市，买下了数百朵百合，把那间房子，摆满了它们。在那清幽的夜晚，我打开全家的窗门，坐在黑暗中，静静的让微风，吹动那百合的气息。\n那是丈夫逝去了七年之后。又是百合花的季节了，看见它们，立即看见当年丈夫弯腰去地上拾花的景象。没有泪，而我的胃，开始抽痛起来。\n 作者: 三毛 (选自《思念的长河》)\n ","date":"2019-09-19T00:00:00Z","image":"https://images.unsplash.com/photo-1494154263685-1241ed054a2f?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8\u0026amp;ixlib=rb-1.2.1\u0026amp;auto=format\u0026amp;fit=crop\u0026amp;w=750\u0026amp;q=80","permalink":"https://heaciy.com/p/%E5%A4%9C%E6%B7%B1%E8%8A%B1%E7%9D%A1/","title":"夜深花睡"}]